require './editor.scss'

TextCommandHandler = require './commandhandler'
Viewer = require './viewer'

CreateForm = require './createform'
GridTextGroup = require './gridtextgroup'
TableControls = require './table-controls'
GridButton = require './gridbutton'
SelectionHandler = require './selectionhandler'

Common = window.ObojoboDraft.Common
OBO = window.OBO

TextGroupSelection = Common.textGroup.TextGroupSelection
TextGroupCursor = Common.textGroup.TextGroupCursor
StyleableText = Common.text.StyleableText
TextGroup = Common.textGroup.TextGroup
TextGroupEl = Common.chunk.textChunk.TextGroupEl
Chunk = Common.models.Chunk
NonEditableChunk = Common.chunk.NonEditableChunk
FocusableChunk = Common.chunk.FocusableChunk
Keyboard = Common.page.Keyboard
ChunkUtil = Common.chunk.util.ChunkUtil
Button = Common.components.Button
EditButton = Common.components.EditButton
DeleteButton = Common.components.DeleteButton
ToggleSelectionHandler = Common.chunk.focusableChunk.ToggleSelectionHandler

Editor = window.Editor
ToggleCommandHandler = Editor.chunk.focusableChunk.ToggleCommandHandler

commandHandler = new ToggleCommandHandler(new TextCommandHandler())
selectionHandler = new ToggleSelectionHandler(new SelectionHandler)

Table = React.createClass
	statics:
		type: 'ObojoboDraft.Chunks.Table'
		register: ->
			OBO.registerChunk Table, {
				insertItem:
					label: 'Table'
					icon: require 'svg-url?noquotes!./assets/insert-icon.svg'
					onInsert: Common.chunk.util.Insert
			}
			OBO.registerToolbarItem {
				id: 'insertTable'
				type: GridButton
				# type: 'button'
				label: 'Table'
				icon: require 'svg-url?noquotes!./assets/toolbar-icon.svg'
				onClick: (toolbarItem, editorState, selection, data) ->
					newChunk = Chunk.create Table
					console.clear()
					console.log 'DATA', data
					newChunk.modelState.textGroup.setDimensions data.rows, data.cols
					console.log(newChunk.modelState.textGroup)
					ChunkUtil.replaceTextsWithinSelection editorState.selection, newChunk, editorState.selection.virtual.type isnt 'caret'
			}
		getCommandHandler: (chunk, selection) -> commandHandler
		getSelectionHandler: (chunk, selection) -> selectionHandler

		createNewNodeData: Viewer.createNewNodeData
		cloneNodeData: Viewer.cloneNodeData
		createNodeDataFromDescriptor: Viewer.createNodeDataFromDescriptor
		getDataDescriptor: Viewer.getDataDescriptor

	getInitialState: ->
		focus:
			row: 0
			col: 0
			offset: 'start'

	addRow: (index = null) ->
		@props.chunk.markDirty()

		data = @props.chunk.modelState

		if not index? then index = data.textGroup.numRows

		data.textGroup.addRow index

		@setState {
			focus:
				row: index
				col: @state.focus.col
				offset: 'start'
		}

	addCol: (index = null) ->
		@props.chunk.markDirty()

		data = @props.chunk.modelState

		if not index? then index = data.textGroup.numCols

		data.textGroup.addCol index

		@setState {
			focus:
				row: @state.focus.row
				col: index
				offset: 'start'
		}

	removeRow: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.modelState

		if data.textGroup.numRows is 1
			@props.chunk.revert()
			@props.saveAndRenderModuleFn()
			return

		data.textGroup.removeRow index

		if @state.focus.row >= index
			@setState {
				focus:
					row: Math.min(index, data.textGroup.numRows - 1)
					col: @state.focus.col
					offset: 'end'
			}

	removeCol: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.modelState

		if data.textGroup.numCols is 1
			@props.chunk.revert()
			@props.saveAndRenderModuleFn()
			return

		data.textGroup.removeCol index

		if @state.focus.col >= index
			@setState {
				focus:
					row: @state.focus.row
					col: Math.min(index, data.textGroup.numCols - 1)
					offset: 'end'
			}

	updateControls: (event) ->
		@props.updateSelectionFromDOMFn()

		tgs = new TextGroupSelection @props.chunk, @props.selection.virtual

		if tgs.type is 'caret'
			groupIndex = tgs.start.groupIndex

			@props.chunk.markForUpdate()
			@props.saveAndRenderModuleFn()

	onKeyDown2: (newFocus) ->
		if @props.chunk.modelState.textGroup.getIndexForCellPosition(newFocus) isnt -1
			@setState { focus: newFocus }
			@props.chunk.markForUpdate()
			return true

		false

	onKeyDown: (event) ->
		arrowKeyPressed = false

		tgs = new TextGroupSelection @props.chunk, @props.selection.virtual
		return true if tgs.type isnt 'caret'

		switch event.keyCode
			when Keyboard.UP_ARROW
				@onKeyDown2 {
					row: @state.focus.row - 1
					col: @state.focus.col
					offset: 'end'
				}

				arrowKeyPressed = true

			when Keyboard.DOWN_ARROW
				@onKeyDown2 {
					row: @state.focus.row + 1
					col: @state.focus.col
					offset: 'end'
				}

				arrowKeyPressed = true

			when Keyboard.RIGHT_ARROW
				if tgs.start.isTextEnd
					if @state.focus.col is @props.chunk.modelState.textGroup.numCols - 1
						@onKeyDown2 {
							row: @state.focus.row + 1
							col: 0
							offset: 'start'
						}
					else
						@onKeyDown2 {
							row: @state.focus.row
							col: @state.focus.col + 1
							offset: 'start'
						}

					arrowKeyPressed = true

			when Keyboard.LEFT_ARROW

				if tgs.start.isTextStart
					if @state.focus.col is 0
						if @state.focus.row isnt 0
							@onKeyDown2 {
								row: @state.focus.row - 1
								col: @props.chunk.modelState.textGroup.numCols - 1
								offset: 'end'
							}
					else
						@onKeyDown2 {
							row: @state.focus.row
							col: @state.focus.col - 1
							offset: 'end'
						}

					arrowKeyPressed = true

		if arrowKeyPressed
			event.preventDefault()
			event.stopPropagation()
			return false

		true

	componentWillReceiveProps: (nextProps) ->
		if nextProps.shouldPreventTab isnt @props.shouldPreventTab
			@props.chunk.markForUpdate()

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate

	componentDidUpdate: (prevProps, prevState) ->
		@props.chunk.markUpdated()

		if @props.isEditing and not prevProps.isEditing
			setTimeout (->
				@refs.editTable.focus()
				@updateControls()
			).bind(@)

		setTimeout (->
			@selectCell()
		).bind(@)

	selectCell: ->
		tgs = new TextGroupSelection @props.chunk, @props.selection.virtual
		chunk = @props.chunk
		data = chunk.modelState

		if tgs.type is 'caret'
			groupIndex = data.textGroup.getIndexForCellPosition @state.focus

			if tgs.start.groupIndex isnt groupIndex
				offset = switch @state.focus.offset
					when 'start' then 0
					when 'end' then data.textGroup.get(groupIndex).text.length

				@props.selection.virtual.setCaret @props.chunk, { offset:offset, groupIndex:groupIndex }
				@props.selection.selectDOM()
				# desc = @props.selection.getFutureDescriptor()

				# @props.selection.selectFromDescriptor @props.module, desc

	onTableMenuCommand: (info) ->
		@refs.editTable.focus()

		switch info.command
			when 'insertColLeft'
				@addCol info.col

			when 'insertColRight'
				@addCol info.col + 1

			when 'insertRowAbove'
				@addRow info.row

			when 'insertRowBelow'
				@addRow info.row + 1

			when 'deleteCol'
				@removeCol info.col

			when 'deleteRow'
				@removeRow info.row

	onEditButtonClick: (event) ->
		event.preventDefault()
		@startEditing()

	onDeleteButtonClick: (event) ->
		chunk = @props.chunk
		chunk.revert()
		chunk.selectStart()

		@props.saveAndRenderModuleFn()

	onDoubleClick: (event) ->
		if document.elementsFromPoint?
			els = document.elementsFromPoint event.clientX, event.clientY

			for el in els
				if el.getAttribute('data-table-position')?
					attrs = el.getAttribute('data-table-position').split(',')
					if attrs[0] is @props.chunk.get('id')
						return @startEditing ~~attrs[1], ~~attrs[2]

		@startEditing 0, 0

	startEditing: (row = 0, col = 0) ->
		@setFocus row, col, 'end'
		@props.editChunk @props.chunk, { textControlsEnabled:true }

	setFocus: (row, col, offset) ->
		@props.chunk.markForUpdate()

		@setState {
			focus:
				row: row
				col: col
				offset: offset
		}

	onAnchorKeyDown: (event) ->
		@props.onKeyDownPutChunkOnClipboard event, @props.chunk

		if event.keyCode is Keyboard.ENTER
			@startEditing()
			event.preventDefault()
			false

		true

	onCloseButtonClick: (event) ->
		@props.stopEditing()

		# @props.selection.virtual.setCaret @props.chunk.get('index'), { groupIndex:'anchor:main', offset:0 }
		@props.chunk.selectStart()
		@props.saveAndRenderModuleFn()

	render: ->
		if @props.isEditing
			@renderTableWithControls()
		else
			@renderPreview()

	renderTableWithControls: ->
		chunk = @props.chunk

		`<NonEditableChunk className="obojobo-draft--chunks--table editor pad">
			<div className="container editing">
				<TableControls
					selection={this.props.selection}
					chunk={this.props.chunk}
					focus={this.state.focus}
					addRow={this.addRow}
					addCol={this.addCol}
					removeRow={this.removeRow}
					removeCol={this.removeCol}
					onTableMenuCommand={this.onTableMenuCommand}
				/>
				{this.renderEditTable()}

			</div>
			<Button onClick={this.onCloseButtonClick} value="Done" />
		</NonEditableChunk>`

	renderEditTable: ->
		chunk = @props.chunk
		data = chunk.modelState
		numCols = data.textGroup.numCols
		setFocus = @setFocus



		if data.header
			row = data.textGroup.items.slice(0, numCols).map (textGroupItem, index) ->
				`<th
					key={index}
					className={'cell row-0 col-' + index}
					data-table-position={chunk.get('id') + ',0,' + index}
					onClick={setFocus.bind(null, 0, index, 'end')}
				>
					<TextGroupEl text={textGroupItem.text} groupIndex={index} />
				</th>`

			header = `<tr key="header">
				{ row }
			</tr>`
		else
			header = null

		startIndex = if data.header then 1 else 0
		rows = [startIndex...data.textGroup.numRows].map (rowNum) ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
				`<td
					key={index}
					className={'cell row-' + rowNum + ' col-' + index}
					data-table-position={chunk.get('id') + ',' + rowNum + ',' + index}
					onClick={setFocus.bind(null, rowNum, index, 'end')}
				>
					<TextGroupEl text={textGroupItem.text} groupIndex={rowNum * numCols + index} />
				</td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`


		`<table
			className='edit-table'
			ref="editTable"
			key="editTable"
			contentEditable="true"
			suppressContentEditableWarning={true}
			onClick={this.updateControls}
			onKeyDown={this.onKeyDown}
			onFocus={this.updateControls}
		>
			<thead key="thead">
				{header}
			</thead>
			<tbody key="tbody">
				{rows}
			</tbody>
		</table>`

	renderPreview: ->
		`<FocusableChunk
			className="obojobo-draft--chunks--table preview outline-on-selection highlight-on-hover"
			onKeyDown={this.onAnchorKeyDown}
			onDoubleClick={this.onDoubleClick}
			shouldPreventTab={this.props.shouldPreventTab}
		>
			<Viewer {...this.props} />
			<EditButton onClick={this.onEditButtonClick} />
			<DeleteButton onClick={this.onDeleteButtonClick} />
		</FocusableChunk>`


Table.register()

module.exports = Table