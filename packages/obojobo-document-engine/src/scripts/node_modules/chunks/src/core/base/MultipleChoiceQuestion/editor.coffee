require './editor.scss'

QuestionUtil = require './questionutil'
SelectableAnswerItem = require './selectableansweritem'
Viewer = require './viewer'

CommandHandler = require './commandhandler'
editCommandHandler = new CommandHandler()

ObojoboDraft = window.ObojoboDraft
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Chunk = ObojoboDraft.models.Chunk
Text = ObojoboDraft.components.Text
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
FocusableChunk = ObojoboDraft.components.FocusableChunk
Anchor = ObojoboDraft.components.Anchor
Keyboard = ObojoboDraft.page.Keyboard
FocusableCommandHandler = ObojoboDraft.command.FocusableCommandHandler
EditButton = ObojoboDraft.components.EditButton

console.clear()
console.log 'EDIT BUTTON', EditButton

nonEditCommandHandler = new FocusableCommandHandler()


Question = React.createClass
	statics:
		type: 'ObojoboDraft.Chunks.MultipleChoiceQuestion'
		register: ->
			OBO.registerChunk Question, {
				insertItem:
					label: 'MC Question'
					icon: require 'svg-url?noquotes!./assets/insert-icon.svg'
					onInsert: ObojoboDraft.chunk.insertWithText
			}
		getCommandHandler: (chunk) ->
			console.log 'getCommandHandler', chunk.componentContent.editing
			if chunk.componentContent.editing
				editCommandHandler
			else
				nonEditCommandHandler

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			group = TextGroup.create(Infinity, { score:0 })
			group.first.text = new StyleableText
			group.add          new StyleableText, { score:100 }
			group.add          new StyleableText
			group.add          new StyleableText, { score:0 }
			group.add          new StyleableText

			textGroup: group
			responseType: 'pick-one'
			editing: false

		cloneNodeData: (data) ->
			clone = data.textGroup.clone()

			textGroup: clone
			responseType: data.responseType
			editing: data.editing

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			textGroup: TextGroup.fromDescriptor descriptor.content.textGroup, Infinity, { score:0 }
			responseType: descriptor.content.responseType
			editing: false

		getDataDescriptor: (chunk) ->
			# console.log 'ST.getDataDescriptor', chunk
			#@TODO
			data = chunk.componentContent

			textGroup: data.textGroup.toDescriptor()
			responseType: data.responseType

	getInitialState: ->
		selectedAnswers: []

	deleteAnswer: (answerItem) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		index = data.textGroup.indexOf(answerItem)
		data.textGroup.remove index
		data.textGroup.remove index

		@props.updateFn()

	addAnswer: ->
		@props.chunk.componentContent.textGroup.add()
		@props.chunk.componentContent.textGroup.add()
		@props.chunk.markDirty()
		@props.updateFn()

	startEditing: ->
		@props.chunk.markDirty()

		@focusOnceEditing = true
		@props.chunk.componentContent.editing = true
		@props.editChunk @props.chunk, null, @onStopEditing

	onStopEditing: ->
		@props.chunk.componentContent.editing = false

	#@DUPLICATE
	getCorrectAnswers: ->
		correct = []
		for textItem in @props.chunk.componentContent.textGroup.items
			if textItem.data.score and textItem.data.score is 100
				correct.push textItem

		correct

	setCorrectAnswer: (answerItem) ->
		if @props.chunk.componentContent.responseType is 'pick-one'
			correctAnswers = @getCorrectAnswers()
			for correctAnswer in correctAnswers
				@setIncorrectAnswer correctAnswer

		answerItem.data.score = 100

		@props.chunk.markDirty()
		@props.updateFn()

	setIncorrectAnswer: (answerItem) ->
		console.log 'setIncorrectAnswer', answerItem

		answerItem.data.score = 0

		@props.chunk.markDirty()
		@props.updateFn()

	toggleCorrectAnswer: (answerItem) ->
		console.log 'toggleCorrectAnswer', answerItem

		if answerItem.data.score is 100
			@setIncorrectAnswer answerItem
		else
			@setCorrectAnswer answerItem

	onAnchorKeyDown: (event) ->
		console.log 'ON ANCHOR KEY DOWN', event.keyCode
		# event.preventDefault()
		# event.stopPropagation()

		# origSel = DOMSelection.get()

		# alert 'yo'
		if @props.onKeyDownPutChunkOnClipboard event, @props.chunk, @onAfterHijackCopy
			@restoreSelection = true

			return true

		if event.keyCode is 13
			event.preventDefault()
			@startEditing()

	onAfterHijackCopy: (event) ->
		if @restoreSelection?
			console.log @props.updateFn

			@props.selection.setFutureCaret @props.chunk, { offset:0, groupIndex:'anchor:main' }
			@props.updateFn()

			delete @restoreSelection

	componentWillReceiveProps: (nextProps) ->
		if nextProps.shouldPreventTab isnt @props.shouldPreventTab
			@props.chunk.markForUpdate()

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate
		# true

	componentDidUpdate: ->
		console.log '###update'
		@props.chunk.markUpdated()

		if @focusOnceEditing
			delete @focusOnceEditing
			@props.selection.setFutureStart @props.chunk, { offset:0, groupIndex:0 }
			@props.selection.setFutureEnd @props.chunk, { offset:@props.chunk.componentContent.textGroup.first.text.length, groupIndex:0 }
			# @props.chunk.selectStart @props.selection
			@props.updateFn()

	enableControls: ->
		# return
		@props.editChunk @props.chunk, { textControlsEnabled:true }, @onStopEditing

	disableControls: ->
		# return
		@props.editChunk @props.chunk, null, @onStopEditing

	setResponseType: (event) ->
		@props.chunk.componentContent.responseType = event.target.value

		if event.target.value is 'pick-one'
			correctAnswers = @getCorrectAnswers()
			correctAnswers.shift()

			for answer in correctAnswers
				answer.data.score = 0

		@props.chunk.markDirty()
		@props.updateFn()

	getEditorInputType: ->
		data = @props.chunk.componentContent

		if data.responseType is 'pick-one' then return 'radio'
		'checkbox'

	allowTab: (event) ->
		if event.keyCode is Keyboard.TAB
			event.stopPropagation()
			return false

		true

	render: ->
		console.log '##########_____render QUESTION', @props.isEditing

		data = @props.chunk.componentContent

		switch data.editing
			when true  then @renderEditor()
			when false then @renderPreview()

	renderPreview: ->
		data = @props.chunk.componentContent

		`<FocusableChunk
			className="obojobo-draft--chunks--question preview outline-on-selection"
			ref="component"
			onKeyDown={this.onAnchorKeyDown}
			onKeyUp={this.onAnchorKeyUp}
			onDoubleClick={this.startEditing}
			shouldPreventTab={this.props.shouldPreventTab}
		>
			<div>
				<EditButton onClick={this.startEditing} shouldPreventTab={this.props.shouldPreventTab} />
				<Viewer {...this.props} ref="viewer" />
			</div>
		</FocusableChunk>`

	renderEditor: ->

		data = @props.chunk.componentContent

		# editButtonStyles =
		# 	backgroundImage: ObojoboDraft.util.getBackgroundImage(Assets.BUTTON_EDIT)

		allowTab = @allowTab
		deleteAnswer = @deleteAnswer
		chunkIndex = @props.chunk.get('index')
		setCorrectAnswer = @setCorrectAnswer
		enableControls = @enableControls
		disableControls = @disableControls
		toggleCorrectAnswer = @toggleCorrectAnswer
		correctAnswers = @getCorrectAnswers()
		# console.clear()
		# console.log '----------------------'
		# console.log '----------------------'
		# console.log '----------------------'
		# console.log correctAnswers
		answers = []
		for i in [1...data.textGroup.items.length] by 2
			answer = data.textGroup.get(i)
			feedback = data.textGroup.get(i + 1)

			answers.push `<SelectableAnswerItem
							key={i}
							type="editor"
							inputType={this.getEditorInputType()}
							answer={answer}
							feedback={feedback}
							chunkIndex={chunkIndex}
							checked={correctAnswers.indexOf(answer) > -1}
							onSelect={toggleCorrectAnswer}
							onDeleteAnswer={deleteAnswer}
							onFocus={enableControls}
							onBlur={disableControls}
							onKeyDown={allowTab}
						/>`

		`<NonEditableChunk className="obojobo-draft--chunks--question editor outline-on-selection" ref="component">
			<div className="question">
				<div className="input" contentEditable="true" suppressContentEditableWarning={true} onKeyDown={this.allowTab} onFocus={this.enableControls} onBlur={this.disableControls}>
					<Text text={data.textGroup.first.text} groupIndex="0" />
				</div>
			</div>
			<div className="question-type">
				<span>Response type:</span>
				<select onChange={this.setResponseType} value={data.responseType}>
					<option value="pick-one">One correct answer - Student picks one</option>
					<option value="pick-one-multiple-correct">Multiple correct answers - Student picks one</option>
					<option value="pick-one-or-more">Multiple correct answers - Student picks all</option>
				</select>
			</div>
			<ul>
				{answers}
				<li className="answer blank pad" key="-1">
					<button onClick={this.addAnswer} className="button add-answer">+ New Answer Choice</button>
				</li>
			</ul>
		</NonEditableChunk>`


module.exports = Question