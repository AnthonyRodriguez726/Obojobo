Assets = require 'Editor/assets'

ObojoboDraft = window.ObojoboDraft

TextGroup = ObojoboDraft.text.TextGroup
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
BaseCommandHandler = ObojoboDraft.command.BaseCommandHandler
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk

#@TODO:
linkify = ObojoboDraft.util.linkify

mergeDataFn = (consumer, digested) -> consumer

class TextGroupCommandHandler extends BaseCommandHandler
	# STATE QUERIES
	# ================================================
	getCaretEdge: (selection, chunk) ->
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		return if not sel.start.text?

		s = sel.start
		if sel.start.isGroupStart and sel.start.isGroupEnd then return 'startAndEnd'
		if sel.start.isGroupStart then return 'start'
		if sel.start.isGroupEnd then return 'end'
		'none'

	canRemoveSibling: (selection, chunk) -> true

	# CARET OPERATIONS
	# ================================================
	insertText: (selection, chunk, textToInsert, stylesToApply = null, stylesToRemove = null) ->
		console.log 'insertText', textToInsert

		chunk.markDirty()

		console.time 'insertText'

		sel = new TextGroupSelection chunk, selection

		console.log 'text is', sel, sel.start.text

		return if not sel.start.text?

		sel.start.text.insertText sel.start.offset, textToInsert

		if stylesToApply?
			for style in stylesToApply
				sel.start.text.styleText sel.start.offset, sel.start.offset + textToInsert.length, style

		if stylesToRemove?
			for style in stylesToRemove
				sel.start.text.unstyleText sel.start.offset, sel.start.offset + textToInsert.length, style

		if textToInsert is ' ' and not sel.start.text.getStyles(sel.start.offset - 1, sel.start.offset)['a']?
			console.log '@TODO!'
			# linkify sel.start.text

		selection.setFutureCaret selection.startChunk, { offset: sel.start.offset + textToInsert.length, groupIndex: sel.start.groupIndex }

		console.timeEnd 'insertText'

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		# info = POS.getCaretInfo selection.chunk.start, chunk
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		return if not sel.start.text?

		s = sel.start
		tg = data.textGroup

		# If backspacing at the start of the first text so there's nothing to delete...
		if not deleteForwards and s.isGroupStart
			# If chunk is indented...
			if data.indent? and ~~data.indent > 0
				# ...decrease indent
				data.indent--
				return true

			# If this is an empty item, delete it and select the previous sibling
			if tg.isBlank and chunk.prevSibling()?
				chunk.prevSibling().selectEnd selection
				chunk.remove()
				return true

			# Otherwise, delete unsuccessful
			return false

		# If using delete key at the end of the last text...
		if deleteForwards and s.isGroupEnd
			# ...and its blank then remove this chunk and let the item below it sit in it's place
			if tg.isBlank
				nextSibling = chunk.nextSibling()
				chunk.remove()
				nextSibling.selectStart selection
				return true

			# else, unsuccessful
			return false

		# If backspacing and the start of a text that's not the first text...
		if not deleteForwards and s.isTextStart and not s.isFirstText
			# ...merge that text with the previous one
			selection.setFutureCaret chunk, { offset: tg.get(s.groupIndex - 1).text.length, groupIndex: s.groupIndex - 1}
			tg.merge s.groupIndex - 1, mergeDataFn
			return true

		# If using delete key on the end of a text that's not the last text...
		if deleteForwards and s.isTextEnd and not s.isLastText and tg.length > 1
			# ...merge that text with the next one
			selection.setFutureCaret chunk, { offset: s.offset, groupIndex: s.groupIndex }
			tg.merge s.groupIndex, mergeDataFn
			return true

		# Otherwise, delete the text
		[start, end] = if not deleteForwards then [s.offset - 1, s.offset] else [s.offset, s.offset + 1]

		sel.start.text.deleteText start, end

		selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }
		true

	splitText: (selection, chunk, shiftKey) ->
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection

		return if not sel.start.text?

		textGroup = chunk.componentContent.textGroup
		textGroup.splitText sel.start.groupIndex, sel.start.offset
		selection.setFutureCaret chunk, { offset:0, groupIndex:sel.start.groupIndex + 1}

	# MODIFY SELECTION OPERATIONS
	# ================================================

	deleteSelection: (selection, chunk) ->
		console.log '@TODO - should this remove the chunk if all of the content is deleted????'
		console.log 'TGCH.dS', arguments
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection

		chunk.componentContent.textGroup.deleteSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, true, @mergeTextGroups

		pos = selection.chunk.getPosition chunk
		if pos is 'start' or pos is 'contains'
			selection.setFutureCaret chunk, sel.start.toObject()

	getCopyOfSelection: (selection, chunk) ->
		clone = chunk.clone true

		if selection.chunk.getPosition(chunk) isnt 'contains'
			sel = new TextGroupSelection chunk, selection

			clone.componentContent.textGroup.deleteSpan sel.chunkStart.groupIndex, sel.chunkStart.offset, sel.start.groupIndex, sel.start.offset, true, @mergeTextGroups
			clone.componentContent.textGroup.deleteSpan sel.end.groupIndex, sel.end.offset, sel.chunkEnd.groupIndex, sel.chunkEnd.offset, true, @mergeTextGroups

		clone

	styleSelection: (selection, chunk, styleType, styleData) ->
		console.log '~tgch~~~~~~~~~~~~~styleSelection', arguments

		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		data.textGroup.styleText sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, styleType, styleData

	unstyleSelection: (selection, chunk, styleType, styleData) ->
		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		data.textGroup.unstyleText sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, styleType, styleData

	getSelectionStyles: (selection, chunk) ->
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		#@todo:
		if not sel.start? or not sel.end? then return {}

		data.textGroup.getStyles sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

	canMergeWith: (selection, chunk, otherChunk) ->
		console.log 'TG.canMergeWith', chunk, otherChunk
		chunk.componentContent.textGroup? and otherChunk.componentContent.textGroup?

	merge: (selection, consumerChunk, digestedChunk, mergeText = true) ->
		console.log 'merge', consumerChunk.componentContent.textGroup, digestedChunk.componentContent.textGroup

		consumerChunk.markDirty()

		consumerData = consumerChunk.componentContent
		digestedData = digestedChunk.componentContent

		if not digestedData.textGroup?
			digestedChunk.remove()
			return

		if consumerData.textGroup.isEmpty
			oldTextLength = 0
		else
			oldTextLength = consumerData.textGroup.last.text.length

		oldIndex = consumerData.textGroup.length - 1

		if mergeText
			consumerData.textGroup.last.text.merge digestedData.textGroup.first.text
			digestedData.textGroup.remove 0

		while not consumerData.textGroup.isFull and digestedData.textGroup.length > 0
			item = digestedData.textGroup.first
			consumerData.textGroup.add item.text, item.data
			digestedData.textGroup.remove 0

		if digestedData.textGroup.length is 0
			digestedChunk.remove()

		selection.setFutureCaret consumerChunk, { offset: oldTextLength, groupIndex: oldIndex }

	onTab: (selection, chunk, untab) ->
		sel = new TextGroupSelection chunk, selection

		if sel.type is 'caret' and not sel.start.isGroupStart
			return chunk.insertText selection, "\t"

		chunk.indent selection, untab

	# Return true if chunkToBeDigested is OK with its contents being absorbed by consumerChunk
	acceptAbsorb: (selection, chunkToBeDigested, consumerChunk) ->
		chunkToBeDigested.componentContent.textGroup? and consumerChunk.componentContent.textGroup?

	# consumerChunk should absorb the contents of digestedChunk
	absorb: (selection, consumerChunk, digestedChunk) ->
		if not digestedChunk.acceptAbsorb selection, consumerChunk
			digestedChunk.remove()
			consumerChunk.selectAll selection
			return

		textGroup = consumerChunk.componentContent.textGroup
		digestedTextGroup = digestedChunk.componentContent.textGroup

		textGroup.clear()

		if not digestedTextGroup.isEmpty
			while not digestedTextGroup.isEmpty
				if not textGroup.isFull
					item = digestedTextGroup.remove(0)
					textGroup.add item.text, item.data
				else
					item = digestedTextGroup.remove(0)
					textGroup.last.text.merge item.text

		digestedChunk.remove()
		textGroup.fill()

		consumerChunk.selectAll selection

	# split chunk into a possible total of three new chunks - one before the selection, one containing the selection and one after the selection
	split: (selection, chunk) ->
		chunk.markDirty()

		result = {
			prev: null
			next: null
		}

		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		allTextSelected = sel.start.isGroupStart and sel.end.isGroupEnd
		return result if allTextSelected

		top = chunk.clone()
		middle = chunk
		bottom = chunk.clone()

		ttg = top.componentContent.textGroup
		mtg = middle.componentContent.textGroup
		btg = bottom.componentContent.textGroup

		ttg.deleteSpan sel.start.groupIndex, sel.start.offset, ttg.length - 1, ttg.last.text.length, false
		mtg.deleteSpan sel.end.groupIndex, sel.end.offset, mtg.length - 1, mtg.last.text.length, false
		mtg.deleteSpan 0, 0, sel.start.groupIndex, sel.start.offset, false
		btg.deleteSpan 0, 0, sel.end.groupIndex, sel.end.offset, false

		ttg.toSlice    0,                 sel.start.groupIndex
		mtg.toSlice sel.start.groupIndex, sel.end.groupIndex
		btg.toSlice sel.end.groupIndex

		if not ttg.isBlank
			middle.addBefore top
			result.prev = top

		if not btg.isBlank
			middle.addAfter bottom
			result.next = bottom

		if mtg.isEmpty
			middle.revert selection

		middle.selectAll selection

		result



	# STORING SELECTION OPERATIONS
	# ================================================

	saveSelection: (selection, chunk, position) ->
		# info = POS.getCaretInfo cursor, chunk
		sel = new TextGroupSelection chunk, selection
		sel[position].toObject()

	# Take descriptor at savedSelData and turn it into selection.chunk.*
	restoreSelection: (selection, chunk, position, savedSelData) ->
		node = Text.getTextNode chunk, savedSelData.groupIndex
		return null if not node?

		domPos = Text.getDomPosition savedSelData.offset, node

		if position is 'start'
			selection.chunk.setTextStart domPos.textNode, domPos.offset
		else if position is 'end'
			selection.chunk.setTextEnd domPos.textNode, domPos.offset

	getDOMStateBeforeInput: (selection, chunk) ->
		start = @saveSelection selection, chunk, 'start'
		end   = @saveSelection selection, chunk, 'end'

		sel = new TextGroupSelection chunk, selection
		end.offset = sel.start.text.length - end.offset

		start: start
		end: end

	getDOMModificationAfterInput: (selection, chunk, domStateBefore) ->
		textNode = Text.getTextNode chunk, domStateBefore.start.groupIndex
		newText = textNode.textContent

		newText.substring domStateBefore.start.offset, textNode.textContent.length - domStateBefore.end.offset

	applyDOMModification: (selection, chunk, domModifications) ->
		@deleteSelection selection, chunk
		@insertText selection, chunk, domModifications

	selectStart: (selection, chunk, asRange = false) ->
		start = TextGroupSelection.startCursorOf chunk
		console.log '!!'
		console.log '!!'
		console.log '!!'
		console.log 'SELECT START', start

		if asRange
			selection.setFutureStart chunk, start.toObject()
		else
			selection.setFutureCaret chunk, start.toObject()

	selectEnd: (selection, chunk, asRange = false) ->
		# info = POS.getEndInfo chunk
		end = TextGroupSelection.endCursorOf chunk

		if asRange
			selection.setFutureEnd chunk, end.toObject()
		else
			selection.setFutureCaret chunk, end.toObject()

	# TEXT MENU OPERATIONS
	# ================================================

	getTextMenuCommands: (selection, chunk) ->
		[
			{
				label: 'Bold'
				image: Assets.TEXTMENU_BOLD
				fn: (selection, chunk) ->
					if selection.styles['b']
						chunk.unstyleSelection selection, 'b'
					else
						chunk.styleSelection selection, 'b'

			},
			{
				label: 'Italic'
				image: Assets.TEXTMENU_ITALIC
				fn: (selection, chunk) ->
					if selection.styles['i']
						chunk.unstyleSelection selection, 'i'
					else
						chunk.styleSelection selection, 'i'
			},
			{
				label: 'Link...'
				image: Assets.TEXTMENU_LINK
				onBeforeFn: -> { href: prompt('Href?') }
				fn: (selection, chunk, data) ->
					return if not data?.href?
					chunk.styleSelection selection, 'a', { href:data.href }
			},
			{
				label: 'Sup'
				image: Assets.TEXTMENU_SUP
				fn: (selection, chunk) ->
					chunk.styleSelection selection, 'sup', 1
			},
			{
				label: 'Sub'
				image: Assets.TEXTMENU_SUB
				fn: (selection, chunk) ->
					chunk.styleSelection selection, 'sup', -1
			}
		]


module.exports = TextGroupCommandHandler