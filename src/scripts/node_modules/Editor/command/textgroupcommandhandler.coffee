Assets = require 'Editor/assets'

ObojoboDraft = window.ObojoboDraft

TextGroup = ObojoboDraft.text.TextGroup
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
BaseCommandHandler = ObojoboDraft.command.BaseCommandHandler
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk
StyleableText = ObojoboDraft.text.StyleableText
HtmlUtil = ObojoboDraft.util.HtmlUtil

#@TODO:
linkify = ObojoboDraft.util.linkify

mergeDataFn = (consumer, digested) -> consumer

class TextGroupCommandHandler extends BaseCommandHandler
	getCaretEdge: (selection, chunk) ->
		tgs = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		s = tgs.start
		switch
			when not s.text?                     then 'none'
			when s.isGroupStart and s.isGroupEnd then 'startAndEnd'
			when s.isGroupStart                  then 'start'
			when s.isGroupEnd                    then 'end'
			else                                      'none'

	isEmpty: (selection, chunk) ->
		console.clear()
		console.log 'isEmpty', chunk.componentContent.textGroup.isBlank
		chunk.componentContent.textGroup.isBlank

	canRemoveSibling: (selection, chunk) -> true

	insertText: (selection, chunk, textToInsert, stylesToApply = null, stylesToRemove = null) ->
		chunk.markDirty()

		console.time 'insertText'

		sel = new TextGroupSelection chunk, selection.virtual

		return if not sel.start.text?

		sel.start.text.insertText sel.start.offset, textToInsert

		if stylesToApply?
			for style in stylesToApply
				sel.start.text.styleText style, sel.start.offset, sel.start.offset + textToInsert.length

		if stylesToRemove?
			for style in stylesToRemove
				sel.start.text.unstyleText style, sel.start.offset, sel.start.offset + textToInsert.length

		if textToInsert is ' ' and not sel.start.text.getStyles(sel.start.offset - 1, sel.start.offset)['a']?
			console.log '@TODO!'
			# linkify sel.start.text

		selection.virtual.start.data.offset += textToInsert.length
		selection.virtual.collapse()

		console.timeEnd 'insertText'

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		# info = POS.getCaretInfo selection.chunk.start, chunk
		tgs = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		return if not tgs.start.text?

		s = tgs.start
		tg = data.textGroup

		# If backspacing at the start of the first text so there's nothing to delete...
		if not deleteForwards and s.isGroupStart
			# If chunk is indented...
			if data.indent? and ~~data.indent > 0
				# ...decrease indent
				data.indent--
				return true

			# If this is an empty item, delete it and select the previous sibling
			if tg.isBlank and chunk.prevSibling()?
				chunk.prevSibling().selectEnd()
				chunk.remove()
				return true

			# Otherwise, delete unsuccessful
			return false

		# If using delete key at the end of the last text...
		if deleteForwards and s.isGroupEnd
			# ...and its blank then remove this chunk and let the item below it sit in it's place
			if tg.isBlank
				nextSibling = chunk.nextSibling()
				chunk.remove()
				nextSibling.selectStart()
				return true

			# else, unsuccessful
			return false

		# If backspacing and the start of a text that's not the first text...
		if not deleteForwards and s.isTextStart and not s.isFirstText
			# ...merge that text with the previous one
			# selection.setFutureCaret chunk, { offset: tg.get(s.groupIndex - 1).text.length, groupIndex: s.groupIndex - 1}
			# selection.virtual.start.data.offset  chunk, { offset: tg.get(s.groupIndex - 1).text.length, groupIndex: s.groupIndex - 1 }
			# end = TextGroupSelection.getTextEndCursor chunk, s.groupIndex - 1
			# selection.virtual.setCaret end.chunk, end.data
			tgs.setCaretToTextEnd s.groupIndex - 1

			tg.merge s.groupIndex - 1, mergeDataFn
			return true

		# If using delete key on the end of a text that's not the last text...
		if deleteForwards and s.isTextEnd and not s.isLastText and tg.length > 1
			# ...merge that text with the next one
			# selection.setFutureCaret chunk, { offset: s.offset, groupIndex: s.groupIndex }
			tg.merge s.groupIndex, mergeDataFn
			return true

		# Otherwise, delete the text
		[start, end] = if not deleteForwards then [s.offset - 1, s.offset] else [s.offset, s.offset + 1]

		tgs.start.text.deleteText start, end

		# selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }
		tgs.setCaret tgs.start.groupIndex, start
		true

	splitText: (selection, chunk, shiftKey) ->
		chunk.markDirty()

		tgs = new TextGroupSelection chunk, selection.virtual

		return if not tgs.start.text?

		textGroup = chunk.componentContent.textGroup
		textGroup.splitText tgs.start.groupIndex, tgs.start.offset
		# selection.setFutureCaret chunk, { offset:0, groupIndex:sel.start.groupIndex + 1}
		tgs.setCaretToTextStart tgs.start.groupIndex + 1

	deleteSelection: (selection, chunk) ->
		console.log '@TODO - should this remove the chunk if all of the content is deleted????'
		console.log 'TGCH.dS', arguments
		chunk.markDirty()

		tgs = new TextGroupSelection chunk, selection.virtual
		console.log '__tgs', tgs

		chunk.componentContent.textGroup.deleteSpan tgs.start.groupIndex, tgs.start.offset, tgs.end.groupIndex, tgs.end.offset, true, @mergeTextGroups

		pos = selection.virtual.getPosition chunk
		if pos is 'start' or pos is 'contains'
			# selection.setFutureCaret chunk, tgs.start.toObject()
			# selection.virtual.setStart chunk, tgs.start.virtualCursor
			selection.virtual.collapse()

	getCopyOfSelection: (selection, chunk) ->
		clone = chunk.clone()

		position = selection.virtual.getPosition(chunk)
		if position is 'contains' or position is 'start' or position is 'end'
			sel = new TextGroupSelection chunk, selection.virtual

			clone.componentContent.textGroup.deleteSpan sel.end.groupIndex, sel.end.offset, sel.chunkEnd.groupIndex, sel.chunkEnd.offset, true, @mergeTextGroups
			clone.componentContent.textGroup.deleteSpan sel.chunkStart.groupIndex, sel.chunkStart.offset, sel.start.groupIndex, sel.start.offset, true, @mergeTextGroups

		clone

	styleSelection: (selection, chunk, styleType, styleData) ->
		console.log '~tgch~~~~~~~~~~~~~styleSelection', arguments

		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		data.textGroup.styleText sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, styleType, styleData

	unstyleSelection: (selection, chunk, styleType, styleData) ->
		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		data.textGroup.unstyleText sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, styleType, styleData

	getSelectionStyles: (selection, chunk) ->
		sel = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		#@todo:
		if not sel.start? or not sel.end? then return {}

		data.textGroup.getStyles sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

	canMergeWith: (selection, chunk, otherChunk) ->
		console.log 'TG.canMergeWith', chunk, otherChunk
		chunk.componentContent.textGroup? and otherChunk.componentContent.textGroup? and chunk isnt otherChunk

	merge: (selection, consumerChunk, digestedChunk, mergeText = true) ->
		console.log 'merge', arguments

		consumerChunk.markDirty()

		consumerData = consumerChunk.componentContent
		digestedData = digestedChunk.componentContent

		if not digestedData.textGroup?
			digestedChunk.remove()
			return

		if consumerData.textGroup.isEmpty
			oldTextLength = 0
		else
			oldTextLength = consumerData.textGroup.last.text.length

		oldIndex = consumerData.textGroup.length - 1

		if mergeText
			consumerData.textGroup.last.text.merge digestedData.textGroup.first.text
			digestedData.textGroup.remove 0

		i = 0
		# console.clear()
		# console.log consumerData.textGroup is digestedData.textGroup
		while not consumerData.textGroup.isFull and digestedData.textGroup.length > 0
			# console.log consumerData.textGroup.length, digestedData.textGroup.length
			item = digestedData.textGroup.first
			consumerData.textGroup.add item.text, item.data
			digestedData.textGroup.remove 0

		if digestedData.textGroup.length is 0
			digestedChunk.remove()

		# selection.setFutureCaret consumerChunk, { offset: oldTextLength, groupIndex: oldIndex }
		selection.virtual.setCaret consumerChunk, { groupIndex:oldIndex, offset:oldTextLength }

	indent: (selection, chunk, decreaseIndent) ->
		chunk.markDirty()

		data = chunk.componentContent
		tgs = new TextGroupSelection chunk, selection.virtual

		if tgs.end.isFirstText
			all = data.textGroup.items
		else
			all = tgs.getAllSelectedTexts()

		for textItem in all
			if textItem.data.indent? and not isNaN(textItem.data.indent)
				if not decreaseIndent
					textItem.data.indent++
				else if textItem.data.indent > 0
					textItem.data.indent--

	onTab: (selection, chunk, untab) ->
		sel = new TextGroupSelection chunk, selection.virtual

		if sel.type is 'caret' and not sel.start.isTextStart
			return chunk.insertText "\t"

		chunk.indent untab

	_insertTextGroup: (selection, chunk, textGroup) ->
		chunk.markDirty()

		# Single chunk paste algorithm
		# 1. Split chunk text
		# 2. Insert pasted chunk's textGroup inbetween the split
		# 3. Merge the first and last pasted texts with the text above and below

		tgs = new TextGroupSelection chunk, selection.virtual

		ctg = tgs.start.textGroup
		ptg = textGroup
		groupIndex = tgs.start.groupIndex

		chunk.splitText()

		ctg.addGroupAt ptg, groupIndex + 1
		ctg.merge groupIndex + ptg.length
		ctg.merge groupIndex

		if ptg.length is 1
			offset = ptg.last.text.length + tgs.start.offset
		else
			offset = ptg.last.text.length

		selection.virtual.start.data =
			groupIndex: groupIndex + ptg.length - 1
			offset: offset

		selection.virtual.collapse()

	paste: (selection, chunk, text, html, chunks) ->
		console.clear()
		console.log 'PASTE!??', arguments

		console.log html.replace(/style="(.*?)"/g, '')

		# debugger;

		switch chunks.length
			when 0
				if html?.length > 0
					el = document.createElement 'div'
					el.innerHTML = html
					el = HtmlUtil.sanitize el

					document.body.appendChild(el)

					sts = StyleableText.createFromElement el
					ptg = TextGroup.create()
					for st in sts
						ptg.add st

					@_insertTextGroup selection, chunk, ptg

					document.body.removeChild(el)

					return true
			when 1
				if not chunk.canMergeWith(chunks[0]) or not chunks[0].canMergeWith(chunk)
					return false

				@_insertTextGroup selection, chunk, chunks[0].componentContent.textGroup

				true
			else
				chunk.markDirty()

				# Multiple chunk paste algorithm (two or more)
				# 1. Split chunk --> prev, split and next
				# 2. Add pasted chunks after split chunk
				# 3. Merge prev and first pasted chunk
				# 4. Merge last pasted chunk and next
				# 5. Delete split chunk

				# Get a copy of the current caret state, need it to
				# calculate where to move the caret
				caret = selection.virtual.start.clone()

				splitChunks = chunk.split()



				for pastedChunk in chunks
					# if chunk.acceptAbsorb pastedChunk
					# 	clone = chunk.clone()
					# 	chunk.addChunkBefore clone
					# 	clone.absorb pastedChunk
					# else
					chunk.addChunkBefore pastedChunk

				if splitChunks.prev? and splitChunks.prev.canMergeWith(chunks[0]) and chunks[0].canMergeWith(splitChunks.prev)
					splitChunks.prev.selectEnd()
					splitChunks.prev.merge chunks[0]

				lastPastedChunk = chunks[chunks.length - 1]
				if splitChunks.next? and lastPastedChunk.canMergeWith(splitChunks.next) and splitChunks.next.canMergeWith(lastPastedChunk)
					lastPastedChunk.selectEnd()
					lastPastedChunk.merge splitChunks.next
				else
					lastPastedChunk.selectEnd()

				chunk.remove()

				true

	# Return true if chunkToBeDigested is OK with its contents being absorbed by consumerChunk
	acceptAbsorb: (selection, chunkToBeDigested, consumerChunk) ->
		chunkToBeDigested.componentContent.textGroup? and consumerChunk.componentContent.textGroup? and chunkToBeDigested isnt consumerChunk

	# consumerChunk should absorb the contents of digestedChunk
	absorb: (selection, consumerChunk, digestedChunk) ->
		console.log 'ABSORB', arguments

		if not digestedChunk.acceptAbsorb consumerChunk
			digestedChunk.remove()
			consumerChunk.selectAll()
			return

		textGroup = consumerChunk.componentContent.textGroup
		digestedTextGroup = digestedChunk.componentContent.textGroup

		textGroup.clear()

		while not digestedTextGroup.isEmpty
			if not textGroup.isFull
				item = digestedTextGroup.remove(0)
				textGroup.add item.text, item.data
			else
				item = digestedTextGroup.remove(0)
				item.text.insertText 0, ' '
				textGroup.last.text.merge item.text

		digestedChunk.remove()
		textGroup.fill()

		# consumerChunk.selectAll()

	# split: (selection, chunk) ->
	# 	selection.saveVirtualSelection()

	# 	selection.virtual.collapseToEnd()
	# 	chunk.splitText()

	# 	selection.restoreVirtualSelection()
	# 	selection.virtual.collapse()
	# 	chunk.splitText()

	# 	{
	# 		prev: null
	# 		next: null
	# 	}

	# split chunk into a possible total of three new chunks - one before the selection, one containing the selection and one after the selection
	split: (selection, chunk) ->
		chunk.markDirty()

		result = {
			prev: null
			next: null
		}

		sel = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		allTextSelected = sel.start.isGroupStart and sel.end.isGroupEnd
		return result if allTextSelected

		top = chunk.clone()
		middle = chunk
		bottom = chunk.clone()

		ttg = top.componentContent.textGroup
		mtg = middle.componentContent.textGroup
		btg = bottom.componentContent.textGroup

		ttg.toSlice    0,                 sel.start.groupIndex
		mtg.toSlice sel.start.groupIndex, sel.end.groupIndex
		btg.toSlice sel.end.groupIndex

		ttg.deleteSpan ttg.length - 1, sel.start.offset, ttg.length - 1, ttg.last.text.length, false
		mtg.deleteSpan mtg.length - 1, sel.end.offset, mtg.length - 1, mtg.last.text.length, false
		mtg.deleteSpan 0, 0, 0, sel.start.offset, false
		btg.deleteSpan 0, 0, 0, sel.end.offset, false

		if not ttg.isBlank
			middle.addChunkBefore top
			result.prev = top

			if ttg.last.text.length is 0
				ttg.remove ttg.last.index

		if not btg.isBlank
			middle.addChunkAfter bottom
			result.next = bottom

			if btg.first.text.length is 0
				btg.remove 0

		if mtg.isEmpty
			middle.revert()

		middle.selectAll()

		result

	getDOMStateBeforeInput: (selection, chunk) ->
		tgs = new TextGroupSelection chunk, selection.virtual

		# debugger;

		charsFromStart: tgs.start.offset
		charsFromEnd:   tgs.start.text.length - tgs.end.offset

	getDOMModificationAfterInput: (selection, chunk, domStateBefore) ->
		el = Text.getTextElementAtCursor selection.virtual.start
		newText = el.textContent

		# debugger;

		text: newText.substring domStateBefore.charsFromStart, newText.length - domStateBefore.charsFromEnd

	applyDOMModification: (selection, chunk, domModifications) ->
		# debugger;

		chunk.deleteSelection()
		chunk.insertText domModifications.text

	selectStart: (selection, chunk, asRange = false) ->
		selection.virtual.start = TextGroupSelection.getGroupStartCursor(chunk).virtualCursor
		if not asRange then selection.virtual.collapse()

	selectEnd: (selection, chunk, asRange = false) ->
		selection.virtual.end = TextGroupSelection.getGroupEndCursor(chunk).virtualCursor
		if not asRange then selection.virtual.collapseToEnd()

	selectAll: (selection, chunk) ->
		TextGroupSelection.selectGroup chunk, selection.virtual

	getTextMenuCommands: (selection, chunk) ->
		[
			{
				label: 'Bold'
				image: Assets.TEXTMENU_BOLD
				fn: (selection, chunk) ->
					if selection.styles['b']
						chunk.unstyleSelection 'b'
					else
						chunk.styleSelection 'b'

			},
			{
				label: 'Italic'
				image: Assets.TEXTMENU_ITALIC
				fn: (selection, chunk) ->
					if selection.styles['i']
						chunk.unstyleSelection 'i'
					else
						chunk.styleSelection 'i'
			},
			{
				label: 'Link...'
				image: Assets.TEXTMENU_LINK
				onBeforeFn: -> { href: prompt('Href?') }
				fn: (selection, chunk, data) ->
					return if not data?.href?
					chunk.styleSelection 'a', { href:data.href }
			}#,
			# {
			# 	label: 'Sup'
			# 	image: Assets.TEXTMENU_SUP
			# 	fn: (selection, chunk) ->
			# 		chunk.styleSelection 'sup', 1
			# },
			# {
			# 	label: 'Sub'
			# 	image: Assets.TEXTMENU_SUB
			# 	fn: (selection, chunk) ->
			# 		chunk.styleSelection 'sup', -1
			# }
		]

	getVirtualSelectionStartData: (selection, chunk) ->
		if not selection.dom?.startText? then return null
		TextGroupSelection.getCursorDataFromDOM selection.dom.startText, selection.dom.startOffset

	getVirtualSelectionEndData: (selection, chunk) ->
		if not selection.dom?.startText? then return null
		TextGroupSelection.getCursorDataFromDOM selection.dom.endText, selection.dom.endOffset

	getDOMSelectionStart: (selection, chunk) ->
		Text.getDomPosition selection.virtual.start

	getDOMSelectionEnd: (selection, chunk) ->
		Text.getDomPosition selection.virtual.end

	areCursorsEquivalent: (selectionWhichIsNullTODO, chunk, thisCursorData, otherCursorData) ->
		thisCursorData.offset is otherCursorData.offset and thisCursorData.groupIndex is otherCursorData.groupIndex

module.exports = TextGroupCommandHandler