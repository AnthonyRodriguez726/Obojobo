Assets = require 'Editor/assets'

ObojoboDraft = window.ObojoboDraft

TextGroup = ObojoboDraft.text.TextGroup
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
BaseCommandHandler = ObojoboDraft.command.BaseCommandHandler
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk

#@TODO:
linkify = ObojoboDraft.util.linkify

mergeDataFn = (consumer, digested) -> consumer

class TextGroupCommandHandler extends BaseCommandHandler
	getCaretEdge: (selection, chunk) ->
		tgs = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		s = tgs.start
		switch
			when not s.text?                     then 'none'
			when s.isGroupStart and s.isGroupEnd then 'startAndEnd'
			when s.isGroupStart                  then 'start'
			when s.isGroupEnd                    then 'end'
			else                                      'none'

	isEmpty: (selection, chunk) ->
		console.clear()
		console.log 'isEmpty', chunk.componentContent.textGroup.isBlank
		chunk.componentContent.textGroup.isBlank

	canRemoveSibling: (selection, chunk) -> true

	insertText: (selection, chunk, textToInsert, stylesToApply = null, stylesToRemove = null) ->
		# console.log 'insertText', arguments


		chunk.markDirty()

		console.time 'insertText'

		sel = new TextGroupSelection chunk, selection.virtual

		return if not sel.start.text?

		sel.start.text.insertText sel.start.offset, textToInsert

		if stylesToApply?
			for style in stylesToApply
				sel.start.text.styleText sel.start.offset, sel.start.offset + textToInsert.length, style

		if stylesToRemove?
			for style in stylesToRemove
				sel.start.text.unstyleText sel.start.offset, sel.start.offset + textToInsert.length, style

		if textToInsert is ' ' and not sel.start.text.getStyles(sel.start.offset - 1, sel.start.offset)['a']?
			console.log '@TODO!'
			# linkify sel.start.text

		# selection.setFutureCaret selection.startChunk, { offset: sel.start.offset + textToInsert.length, groupIndex: sel.start.groupIndex }
		selection.virtual.start.data.offset += textToInsert.length
		selection.virtual.collapse()

		console.timeEnd 'insertText'

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		# info = POS.getCaretInfo selection.chunk.start, chunk
		tgs = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		return if not tgs.start.text?

		s = tgs.start
		tg = data.textGroup

		# If backspacing at the start of the first text so there's nothing to delete...
		if not deleteForwards and s.isGroupStart
			# If chunk is indented...
			if data.indent? and ~~data.indent > 0
				# ...decrease indent
				data.indent--
				return true

			# If this is an empty item, delete it and select the previous sibling
			if tg.isBlank and chunk.prevSibling()?
				chunk.prevSibling().selectEnd()
				chunk.remove()
				return true

			# Otherwise, delete unsuccessful
			return false

		# If using delete key at the end of the last text...
		if deleteForwards and s.isGroupEnd
			# ...and its blank then remove this chunk and let the item below it sit in it's place
			if tg.isBlank
				nextSibling = chunk.nextSibling()
				chunk.remove()
				nextSibling.selectStart()
				return true

			# else, unsuccessful
			return false

		# If backspacing and the start of a text that's not the first text...
		if not deleteForwards and s.isTextStart and not s.isFirstText
			# ...merge that text with the previous one
			# selection.setFutureCaret chunk, { offset: tg.get(s.groupIndex - 1).text.length, groupIndex: s.groupIndex - 1}
			# selection.virtual.start.data.offset  chunk, { offset: tg.get(s.groupIndex - 1).text.length, groupIndex: s.groupIndex - 1 }
			# end = TextGroupSelection.getTextEndCursor chunk, s.groupIndex - 1
			# selection.virtual.setCaret end.chunk, end.data
			tgs.setCaretToTextEnd s.groupIndex - 1

			tg.merge s.groupIndex - 1, mergeDataFn
			return true

		# If using delete key on the end of a text that's not the last text...
		if deleteForwards and s.isTextEnd and not s.isLastText and tg.length > 1
			# ...merge that text with the next one
			# selection.setFutureCaret chunk, { offset: s.offset, groupIndex: s.groupIndex }
			tg.merge s.groupIndex, mergeDataFn
			return true

		# Otherwise, delete the text
		[start, end] = if not deleteForwards then [s.offset - 1, s.offset] else [s.offset, s.offset + 1]

		tgs.start.text.deleteText start, end

		# selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }
		tgs.setCaret tgs.start.groupIndex, start
		true

	splitText: (selection, chunk, shiftKey) ->
		chunk.markDirty()

		tgs = new TextGroupSelection chunk, selection.virtual

		return if not tgs.start.text?

		textGroup = chunk.componentContent.textGroup
		textGroup.splitText tgs.start.groupIndex, tgs.start.offset
		# selection.setFutureCaret chunk, { offset:0, groupIndex:sel.start.groupIndex + 1}
		tgs.setCaretToTextStart tgs.start.groupIndex + 1

	deleteSelection: (selection, chunk) ->
		console.log '@TODO - should this remove the chunk if all of the content is deleted????'
		console.log 'TGCH.dS', arguments
		chunk.markDirty()

		tgs = new TextGroupSelection chunk, selection.virtual
		console.log '__tgs', tgs

		chunk.componentContent.textGroup.deleteSpan tgs.start.groupIndex, tgs.start.offset, tgs.end.groupIndex, tgs.end.offset, true, @mergeTextGroups

		pos = selection.virtual.getPosition chunk
		if pos is 'start' or pos is 'contains'
			# selection.setFutureCaret chunk, tgs.start.toObject()
			# selection.virtual.setStart chunk, tgs.start.virtualCursor
			selection.virtual.collapse()

	getCopyOfSelection: (selection, chunk) ->
		clone = chunk.clone true

		if selection.chunk.getPosition(chunk) isnt 'contains'
			sel = new TextGroupSelection chunk, selection.virtual

			clone.componentContent.textGroup.deleteSpan sel.chunkStart.groupIndex, sel.chunkStart.offset, sel.start.groupIndex, sel.start.offset, true, @mergeTextGroups
			clone.componentContent.textGroup.deleteSpan sel.end.groupIndex, sel.end.offset, sel.chunkEnd.groupIndex, sel.chunkEnd.offset, true, @mergeTextGroups

		clone

	styleSelection: (selection, chunk, styleType, styleData) ->
		console.log '~tgch~~~~~~~~~~~~~styleSelection', arguments

		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		data.textGroup.styleText sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, styleType, styleData

	unstyleSelection: (selection, chunk, styleType, styleData) ->
		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		data.textGroup.unstyleText sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, styleType, styleData

	getSelectionStyles: (selection, chunk) ->
		sel = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		#@todo:
		if not sel.start? or not sel.end? then return {}

		data.textGroup.getStyles sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

	canMergeWith: (selection, chunk, otherChunk) ->
		console.log 'TG.canMergeWith', chunk, otherChunk
		chunk.componentContent.textGroup? and otherChunk.componentContent.textGroup? and chunk isnt otherChunk

	merge: (selection, consumerChunk, digestedChunk, mergeText = true) ->
		console.log 'merge', consumerChunk.componentContent.textGroup, digestedChunk.componentContent.textGroup

		consumerChunk.markDirty()

		consumerData = consumerChunk.componentContent
		digestedData = digestedChunk.componentContent

		if not digestedData.textGroup?
			digestedChunk.remove()
			return

		if consumerData.textGroup.isEmpty
			oldTextLength = 0
		else
			oldTextLength = consumerData.textGroup.last.text.length

		oldIndex = consumerData.textGroup.length - 1

		if mergeText
			consumerData.textGroup.last.text.merge digestedData.textGroup.first.text
			digestedData.textGroup.remove 0

		i = 0
		# console.clear()
		# console.log consumerData.textGroup is digestedData.textGroup
		while not consumerData.textGroup.isFull and digestedData.textGroup.length > 0
			# console.log consumerData.textGroup.length, digestedData.textGroup.length
			item = digestedData.textGroup.first
			consumerData.textGroup.add item.text, item.data
			digestedData.textGroup.remove 0

		if digestedData.textGroup.length is 0
			digestedChunk.remove()

		# selection.setFutureCaret consumerChunk, { offset: oldTextLength, groupIndex: oldIndex }
		selection.virtual.setCaret consumerChunk, { groupIndex:oldIndex, offset:oldTextLength }

	indent: (selection, chunk, decreaseIndent) ->
		chunk.markDirty()

		data = chunk.componentContent
		tgs = new TextGroupSelection chunk, selection.virtual

		if tgs.end.isFirstText
			all = data.textGroup.items
		else
			all = tgs.getAllSelectedTexts()

		for textItem in all
			if textItem.data.indent? and not isNaN(textItem.data.indent)
				if not decreaseIndent
					textItem.data.indent++
				else if textItem.data.indent > 0
					textItem.data.indent--

	onTab: (selection, chunk, untab) ->
		sel = new TextGroupSelection chunk, selection.virtual

		if sel.type is 'caret' and not sel.start.isTextStart
			return chunk.insertText "\t"

		chunk.indent untab

	# Return true if chunkToBeDigested is OK with its contents being absorbed by consumerChunk
	acceptAbsorb: (selection, chunkToBeDigested, consumerChunk) ->
		chunkToBeDigested.componentContent.textGroup? and consumerChunk.componentContent.textGroup? and chunkToBeDigested isnt consumerChunk

	# consumerChunk should absorb the contents of digestedChunk
	absorb: (selection, consumerChunk, digestedChunk) ->
		console.log 'ABSORB', arguments

		if not digestedChunk.acceptAbsorb consumerChunk
			digestedChunk.remove()
			consumerChunk.selectAll()
			return

		textGroup = consumerChunk.componentContent.textGroup
		digestedTextGroup = digestedChunk.componentContent.textGroup

		textGroup.clear()

		while not digestedTextGroup.isEmpty
			if not textGroup.isFull
				item = digestedTextGroup.remove(0)
				textGroup.add item.text, item.data
			else
				item = digestedTextGroup.remove(0)
				item.text.insertText 0, ' '
				textGroup.last.text.merge item.text

		digestedChunk.remove()
		textGroup.fill()

		# consumerChunk.selectAll()

	# split: (selection, chunk) ->
	# 	selection.saveVirtualSelection()

	# 	selection.virtual.collapseToEnd()
	# 	chunk.splitText()

	# 	selection.restoreVirtualSelection()
	# 	selection.virtual.collapse()
	# 	chunk.splitText()

	# 	{
	# 		prev: null
	# 		next: null
	# 	}

	# split chunk into a possible total of three new chunks - one before the selection, one containing the selection and one after the selection
	split: (selection, chunk) ->
		chunk.markDirty()

		result = {
			prev: null
			next: null
		}

		sel = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		allTextSelected = sel.start.isGroupStart and sel.end.isGroupEnd
		return result if allTextSelected

		top = chunk.clone()
		middle = chunk
		bottom = chunk.clone()

		ttg = top.componentContent.textGroup
		mtg = middle.componentContent.textGroup
		btg = bottom.componentContent.textGroup

		ttg.toSlice    0,                 sel.start.groupIndex
		mtg.toSlice sel.start.groupIndex, sel.end.groupIndex
		btg.toSlice sel.end.groupIndex

		ttg.deleteSpan ttg.length - 1, sel.start.offset, ttg.length - 1, ttg.last.text.length, false
		mtg.deleteSpan mtg.length - 1, sel.end.offset, mtg.length - 1, mtg.last.text.length, false
		mtg.deleteSpan 0, 0, 0, sel.start.offset, false
		btg.deleteSpan 0, 0, 0, sel.end.offset, false

		if not ttg.isBlank
			middle.addChunkBefore top
			result.prev = top

			if ttg.last.text.length is 0
				ttg.remove ttg.last.index

		if not btg.isBlank
			middle.addChunkAfter bottom
			result.next = bottom

			if btg.first.text.length is 0
				btg.remove 0

		if mtg.isEmpty
			middle.revert()

		middle.selectAll()

		result

	getDOMStateBeforeInput: (selection, chunk) ->
		# start = @saveSelection selection, chunk, 'start'
		# end   = @saveSelection selection, chunk, 'end'

		tgs = new TextGroupSelection chunk, selection.virtual
		tgs.end.offset = tgs.start.text.length - tgs.end.offset

		start: start.data
		end: end.data

	getDOMModificationAfterInput: (selection, chunk, domStateBefore) ->
		# textNode = Text.getTextNode chunk, domStateBefore.start.groupIndex
		node = chunk.getDomEl()
		newText = node.textContent

		newText.substring domStateBefore.start.offset, node.textContent.length - domStateBefore.end.offset

	applyDOMModification: (selection, chunk, domModifications) ->
		console.log '@TODO - these should use chunk methods!'
		@deleteSelection selection, chunk
		@insertText selection, chunk, domModifications

	selectStart: (selection, chunk, asRange = false) ->
		selection.virtual.start = TextGroupSelection.getGroupStartCursor(chunk).virtualCursor
		if not asRange then selection.virtual.collapse()

	selectEnd: (selection, chunk, asRange = false) ->
		selection.virtual.end = TextGroupSelection.getGroupEndCursor(chunk).virtualCursor
		if not asRange then selection.virtual.collapseToEnd()

	selectAll: (selection, chunk) ->
		TextGroupSelection.selectGroup chunk, selection.virtual

	getTextMenuCommands: (selection, chunk) ->
		[
			{
				label: 'Bold'
				image: Assets.TEXTMENU_BOLD
				fn: (selection, chunk) ->
					if selection.styles['b']
						chunk.unstyleSelection 'b'
					else
						chunk.styleSelection 'b'

			},
			{
				label: 'Italic'
				image: Assets.TEXTMENU_ITALIC
				fn: (selection, chunk) ->
					if selection.styles['i']
						chunk.unstyleSelection 'i'
					else
						chunk.styleSelection 'i'
			},
			{
				label: 'Link...'
				image: Assets.TEXTMENU_LINK
				onBeforeFn: -> { href: prompt('Href?') }
				fn: (selection, chunk, data) ->
					return if not data?.href?
					chunk.styleSelection 'a', { href:data.href }
			},
			{
				label: 'Sup'
				image: Assets.TEXTMENU_SUP
				fn: (selection, chunk) ->
					chunk.styleSelection 'sup', 1
			},
			{
				label: 'Sub'
				image: Assets.TEXTMENU_SUB
				fn: (selection, chunk) ->
					chunk.styleSelection 'sup', -1
			}
		]

	getVirtualSelectionStartData: (selection, chunk) ->
		if not selection.dom?.startText? then return null
		TextGroupSelection.getCursorDataFromDOM selection.dom.startText, selection.dom.startOffset

	getVirtualSelectionEndData: (selection, chunk) ->
		if not selection.dom?.startText? then return null
		TextGroupSelection.getCursorDataFromDOM selection.dom.endText, selection.dom.endOffset

	getDOMSelectionStart: (selection, chunk) ->
		Text.getDomPosition selection.virtual.start

	getDOMSelectionEnd: (selection, chunk) ->
		Text.getDomPosition selection.virtual.end

	areCursorsEquivalent: (selectionWhichIsNullTODO, chunk, thisCursorData, otherCursorData) ->
		thisCursorData.offset is otherCursorData.offset and thisCursorData.groupIndex is otherCursorData.groupIndex

module.exports = TextGroupCommandHandler