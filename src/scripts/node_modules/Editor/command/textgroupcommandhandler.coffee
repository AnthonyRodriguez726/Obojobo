Editor = require 'Editor'
Assets = Editor.assets

ObojoboDraft = require 'ObojoboDraft'

TextGroup = ObojoboDraft.text.TextGroup
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
BaseCommandHandler = ObojoboDraft.command.BaseCommandHandler
Text = ObojoboDraft.components.Text

#@TODO:
linkify = require 'ObojoboDraft/util/linkify'

mergeDataFn = (consumer, digested) -> consumer

class TextGroupCommandHandler extends BaseCommandHandler
	# STATE QUERIES
	# ================================================
	getCaretEdge: (selection, chunk) ->
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		return if not sel.start.text?

		if sel.start.groupIndex is 0 and sel.start.offset <= 0
			if data.textGroup.length is 1 and sel.start.text.length is 0 then return 'startAndEnd'
			return 'start'
		if sel.start.groupIndex is data.textGroup.length - 1 and sel.start.offset >= data.textGroup.last.text.length then return 'end'
		'inside'

	canRemoveSibling: (selection, chunk) -> true

	# CARET OPERATIONS
	# ================================================
	insertText: (selection, chunk, textToInsert, stylesToApply = null, stylesToRemove = null) ->
		chunk.markDirty()

		console.time 'insertText'

		sel = new TextGroupSelection chunk, selection

		return if not sel.start.text?

		sel.start.text.insertText sel.start.offset, textToInsert

		if stylesToApply?
			for style in stylesToApply
				sel.start.text.styleText sel.start.offset, sel.start.offset + 1, style

		if stylesToRemove?
			for style in stylesToRemove
				sel.start.text.unstyleText sel.start.offset, sel.start.offset + 1, style

		if textToInsert is ' ' and not sel.start.text.getStyles(sel.start.offset - 1, sel.start.offset)['a']?
			linkify sel.start.text

		selection.setFutureCaret selection.chunk.start.chunk, { offset: sel.start.offset + textToInsert.length, groupIndex: sel.start.groupIndex }

		console.timeEnd 'insertText'

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		# info = POS.getCaretInfo selection.chunk.start, chunk
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		return if not sel.start.text?

		# If backspacing at the start and the chunk is indented...
		if not deleteForwards and sel.start.offset is 0 and sel.start.groupIndex is 0 and data.indent? and ~~data.indent > 0
			# ...decrease indent
			data.indent--
			return true

		# If backspacing and the start of a text that's not the first text...
		if not deleteForwards and sel.start.offset is 0 and sel.start.text isnt data.textGroup.first.text
			# ...merge that text with the previous one
			selection.setFutureCaret chunk, { offset: data.textGroup.get(sel.start.groupIndex - 1).text.length, groupIndex: sel.start.groupIndex - 1}
			data.textGroup.merge sel.start.groupIndex - 1, mergeDataFn
			return true

		# If using delete key on the end of a text that's not the last text...
		if deleteForwards and sel.start.offset is sel.start.text.length and sel.start.text isnt data.textGroup.last.text and data.textGroup.length > 1
			# ...merge that text with the next one
			selection.setFutureCaret chunk, { offset: sel.start.offset, groupIndex: sel.start.groupIndex }
			data.textGroup.merge sel.start.groupIndex, mergeDataFn
			return true

		# If backspacing at the start of the first text so there's nothing to delete...
		if not deleteForwards and sel.start.offset is 0 and sel.start.text is data.textGroup.first.text
			# If this is an empty item, delete it and select the previous sibling
			if data.textGroup.isEmpty or (data.textGroup.length is 1 and data.textGroup.first.text.length is 0) and chunk.prevSibling()?
				chunk.prevSibling().selectEnd selection
				chunk.remove()
				return true

			# Otherwise, delete unsuccessful
			return false

		# Likewise, if using delete key at the end of the last text then nothing to delete, so unsuccessful
		if deleteForwards and sel.start.offset is sel.start.text.length and sel.start.text is data.textGroup.last.text
			return false

		# Otherwise, delete the text
		[start, end] = if not deleteForwards then [sel.start.offset - 1, sel.start.offset] else [sel.start.offset, sel.start.offset + 1]

		sel.start.text.deleteText start, end

		selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }
		true

	splitText: (selection, chunk, shiftKey) ->
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection

		return if not sel.start.text?

		newText = sel.start.text.split sel.start.offset

		clonedNode = chunk.clone()
		clonedNode.componentContent.textGroup.first.text = newText
		chunk.addAfter clonedNode

		selection.setFutureCaret clonedNode, { offset: 0, groupIndex: 0 }

	# MODIFY SELECTION OPERATIONS
	# ================================================

	deleteSelection: (selection, chunk) ->
		console.log 'TGCH.dS', arguments
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection

		chunk.componentContent.textGroup.deleteSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, true, @mergeTextGroups

		pos = selection.chunk.getPosition chunk
		if pos is 'start' or pos is 'contains'
			selection.setFutureCaret chunk, sel.start.toObject()

	getCopyOfSelection: (selection, chunk) ->
		clone = chunk.clone true

		if selection.chunk.getPosition(chunk) isnt 'contains'
			sel = new TextGroupSelection chunk, selection

			clone.componentContent.textGroup.deleteSpan sel.chunkStart.groupIndex, sel.chunkStart.offset, sel.start.groupIndex, sel.start.offset, true, @mergeTextGroups
			clone.componentContent.textGroup.deleteSpan sel.end.groupIndex, sel.end.offset, sel.chunkEnd.groupIndex, sel.chunkEnd.offset, true, @mergeTextGroups

		clone

	styleSelection: (selection, chunk, styleType, styleData) ->
		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		data.textGroup.styleText sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, styleType, styleData

	unstyleSelection: (selection, chunk, styleType, styleData) ->
		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		data.textGroup.unstyleText sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset, styleType, styleData

	getSelectionStyles: (selection, chunk) ->
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		#@todo:
		if not sel.start? or not sel.end? then return {}

		data.textGroup.getStyles sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

	canMergeWith: (selection, digestedChunk, consumerChunk) ->
		digestedChunk.componentContent.textGroup? and consumerChunk.componentContent.textGroup?

	merge: (selection, consumerChunk, digestedChunk) ->
		consumerChunk.markDirty()

		consumerData = consumerChunk.componentContent
		digestedData = digestedChunk.componentContent

		if not digestedData.textGroup?
			digestedChunk.remove()
			return

		oldTextLength = consumerData.textGroup.last.text.length
		oldIndex = consumerData.textGroup.length - 1

		consumerData.textGroup.last.text.merge digestedData.textGroup.first.text
		digestedData.textGroup.remove 0

		while not consumerData.textGroup.isFull and digestedData.textGroup.length > 0
			item = digestedData.textGroup.first
			consumerData.textGroup.add item.text, item.data
			digestedData.textGroup.remove 0

		if digestedData.textGroup.length is 0
			digestedChunk.remove()

		selection.setFutureCaret consumerChunk, { offset: oldTextLength, groupIndex: oldIndex }

	indent: (selection, chunk, decreaseIndent) ->
		chunk.markDirty()

		data = chunk.componentContent

		if data.indent?
			if not decreaseIndent
				data.indent++
			else if data.indent > 0
				data.indent--

	onTab: (selection, chunk, untab) ->
		@deleteSelection selection, chunk
		@insertText selection, chunk, ["\t"]

	#@TODO - GET RID OF THIS
	init: (selection, chunk) ->
		chunk.componentContent.textGroup.init 0

	# Return true if chunkToBeDigested is OK with its contents being absorbed by consumerChunk
	acceptAbsorb: (selection, chunkToBeDigested, consumerChunk) ->
		chunkToBeDigested.componentContent.textGroup? and consumerChunk.componentContent.textGroup?

	# consumerChunk will absorb the contents of digestedChunk
	# returns the newly created chunks
	absorb: (selection, consumerChunk, digestedChunk) ->
		# return [] if not digestedChunk.callComponentFn 'acceptAbsorb', selection, [consumerChunk]
		return [] if not digestedChunk.acceptAbsorb selection, consumerChunk

		addedChunks = []
		digestedTextGroup = digestedChunk.componentContent.textGroup

		while not digestedTextGroup.isEmpty
			newChunk = consumerChunk.clone()
			newTextGroup = newChunk.componentContent.textGroup
			newTextGroup.clear()

			while not newTextGroup.isFull and not digestedTextGroup.isEmpty
				item = digestedTextGroup.remove(0)
				newTextGroup.add item.text, item.data

			addedChunks.push newChunk
			digestedChunk.addBefore newChunk

		digestedChunk.remove()

		addedChunks

	# The selection will be transformed into one or more newChunk chunks
	transformSelection: (selection, newChunk) ->
		console.log 'TS', selection, newChunk
		data = newChunk.componentContent

		if selection.chunk.type isnt 'chunkSpan'
			selection.chunk.start.chunk.split selection
			# return

			newChunks = newChunk.absorb selection, selection.chunk.start.chunk

			return if newChunks.length is 0

			firstChunk = newChunks[0]
			lastChunk = newChunks[newChunks.length - 1]
		else
			selection.chunk.start.chunk.split selection
			newTopChunks = newChunk.absorb selection, selection.chunk.start.chunk

			for digestableChunk in selection.chunk.inbetween
				newChunk.absorb selection, digestableChunk

			selection.chunk.end.chunk.split selection
			newBottomChunks = newChunk.absorb selection, selection.chunk.end.chunk

			firstChunk = newTopChunks[0]
			lastChunk = newBottomChunks[newBottomChunks.length - 1]

		startInfo = TextGroupSelection.startCursorOf firstChunk
		endInfo = TextGroupSelection.endCursorOf lastChunk
		selection.setFutureStart firstChunk, startInfo.toObject()
		selection.setFutureEnd lastChunk, endInfo.toObject()

	# split chunk into a possible total of three new chunks - one before the selection, one containing the selection and one after the selection
	split: (selection, chunk) ->
		chunk.markDirty()

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		allTextSelected = sel.start.groupIndex is 0 and sel.end.groupIndex is data.textGroup.length - 1
		return if allTextSelected

		top = chunk.clone()
		middle = chunk
		bottom = chunk.clone()

		top.componentContent.textGroup.toSlice    0,                      sel.start.groupIndex
		middle.componentContent.textGroup.toSlice sel.start.groupIndex,   sel.end.groupIndex + 1
		bottom.componentContent.textGroup.toSlice sel.end.groupIndex + 1

		if top.componentContent.textGroup.length > 0
			middle.addBefore top

		if bottom.componentContent.textGroup.length > 0
			middle.addAfter bottom

	# STORING SELECTION OPERATIONS
	# ================================================

	saveSelection: (selection, chunk, position) ->
		# info = POS.getCaretInfo cursor, chunk
		sel = new TextGroupSelection chunk, selection
		sel[position].toObject()

	# Take descriptor at savedSelData and turn it into selection.chunk.*
	restoreSelection: (selection, chunk, type, savedSelData) ->
		node = Text.getTextNode chunk, savedSelData.groupIndex
		return null if not node?

		domPos = Text.getDomPosition savedSelData.offset, node

		if type is 'start'
			selection.chunk.setTextStart domPos.textNode, domPos.offset
		else if type is 'end'
			selection.chunk.setTextEnd domPos.textNode, domPos.offset

	saveDOMStateBeforeInput: (selection, chunk) ->
		start = @saveSelection selection, chunk, 'start'
		end   = @saveSelection selection, chunk, 'end'

		sel = new TextGroupSelection chunk, selection
		end.offset = sel.start.text.length - end.offset

		start: start
		end: end

	getDOMModificationAfterInput: (selection, chunk, domStateBefore) ->
		textNode = Text.getTextNode chunk, domStateBefore.start.groupIndex
		newText = textNode.textContent

		newText.substring domStateBefore.start.offset, textNode.textContent.length - domStateBefore.end.offset

	applyDOMModification: (selection, chunk, domModifications) ->
		@deleteSelection selection, chunk
		@insertText selection, chunk, domModifications

	selectAll: (selection, chunk) ->
		@selectStart selection, chunk, true
		@selectEnd selection, chunk, true

	selectStart: (selection, chunk, asRange = false) ->
		start = TextGroupSelection.startCursorOf chunk

		if asRange
			selection.setFutureStart chunk, start.toObject()
		else
			selection.setFutureCaret chunk, start.toObject()

	selectEnd: (selection, chunk, asRange = false) ->
		# info = POS.getEndInfo chunk
		end = TextGroupSelection.endCursorOf chunk

		if asRange
			selection.setFutureEnd chunk, end.toObject()
		else
			selection.setFutureCaret chunk, end.toObject()

	# TEXT MENU OPERATIONS
	# ================================================

	getTextMenuCommands: (selection, chunk) ->
		[
			{
				label: 'Bold'
				image: Assets.TEXTMENU_BOLD
				fn: (selection, chunk) ->
					if selection.styles['b']
						chunk.unstyleSelection selection, 'b'
					else
						chunk.styleSelection selection, 'b'

			},
			{
				label: 'Italic'
				image: Assets.TEXTMENU_ITALIC
				fn: (selection, chunk) ->
					if selection.styles['i']
						chunk.unstyleSelection selection, 'i'
					else
						chunk.styleSelection selection, 'i'
			},
			{
				label: 'Link...'
				image: Assets.TEXTMENU_LINK
				pre: -> { href: prompt('Href?') }
				fn: (selection, chunk, data) ->
					return if not data?.href?
					chunk.styleSelection selection, 'a', { href:data.href }
			},
			{
				label: 'Sup'
				image: Assets.TEXTMENU_SUP
				fn: (selection, chunk) ->
					chunk.styleSelection selection, 'sup', 1
			},
			{
				label: 'Sub'
				image: Assets.TEXTMENU_SUB
				fn: (selection, chunk) ->
					chunk.styleSelection selection, 'sup', -1
			},
		]


module.exports = TextGroupCommandHandler