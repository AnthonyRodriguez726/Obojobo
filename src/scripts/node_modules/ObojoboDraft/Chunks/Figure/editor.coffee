ObojoboDraft = require 'ObojoboDraft'


# POS = ObojoboDraft.text.TextPositionMethods
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Text = ObojoboDraft.components.Text
Anchor = ObojoboDraft.components.Anchor
Chunk = ObojoboDraft.models.Chunk
DOMSelection = ObojoboDraft.page.DOMSelection
Keyboard = ObojoboDraft.util.Keyboard
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
TextGroupCommandHandler = ObojoboDraft.text.TextGroupCommandHandler
SingleInputBubble = ObojoboDraft.components.modal.bubble.SingleInputBubble
DOMUtil = ObojoboDraft.page.DOMUtil

positions = ['left', 'center', 'right']

require './figure.scss'

class CommandHandler extends TextGroupCommandHandler
	splitText: (selection, chunk, shiftKey) ->
		chunk.markDirty()

		# info = POS.getCaretInfo selection.chunk.start, chunk
		sel = new TextGroupSelection selection.chunk, chunk

		newText = sel.start.text.split sel.start.offset

		newNode = Chunk.create() #@TODO - assumes it has a textGroup
		newNode.componentContent.textGroup.first.text = newText
		chunk.addAfter newNode

		selection.setFutureCaret newNode, { offset: 0, groupIndex: 0 }

	selectStart: (selection, chunk) ->
		selection.setFutureCaret chunk, { groupIndex:'anchor:img-anchor', offset:0 }

	selectEnd: (selection, chunk) ->
		selection.setFutureCaret chunk, { groupIndex:'anchor:img-anchor', offset:0 }


Figure = React.createClass
	statics:
		consumableElements: []
		commandHandler: new CommandHandler

		insertLabel: ['Image']
		onInsert: (position, referenceChunk, selection, opts, callback) ->
			# # url = prompt('URL?')
			# url = '/img/img.png'

			# newChunk = Chunk.create @, {
			# 	textGroup: TextGroup.create(1)
			# 	position: 'center'
			# 	url: url
			# }

			# # selection.setFutureCaret atIndex, { groupIndex:0, offset:0 }
			# selection.setFutureCaret atIndex, { groupIndex:'anchor:img-anchor', offset:0 }

			# callback newChunk



			url = '/img/img.png'
			newChunk = Chunk.create @

			switch position
				when 'before'
					referenceChunk.addBefore newChunk

				when 'after'
					referenceChunk.addAfter newChunk

			newChunk.selectStart selection

			callback()

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			textGroup: TextGroup.create(1)
			url: null
			position: 'center'

		cloneNodeData: (data) ->
			textGroup: data.textGroup.clone()
			url: data.url
			position: data.position

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			console.log 'descr be all like', descriptor
			textGroup: TextGroup.fromDescriptor descriptor.content.textGroup, 1
			url: descriptor.content.url
			position: descriptor.content.position

		getDataDescriptor: (chunk) ->
			data = chunk.componentContent

			textGroup: data.textGroup.toDescriptor()
			url: data.url
			position: data.position

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			group = TextGroup.create(1)
			group.first.text = StyleableText.createFromElement(el)

			[
				Chunk.create @, {
					textGroup: group
					indent: 0
				}
			]

	getInitialState: ->
		{ chunk:@props.chunk }

	componentWillReceiveProps: (nextProps) ->
		@setState {
			chunk: nextProps.chunk
			active: nextProps.isActive
		}

	setPosition: (position) ->
		@state.chunk.markDirty()

		data = @state.chunk.componentContent

		data.position = position

		@setState { chunk:@state.chunk }
		@props.updateFn()

	decreasePosition: ->
		data = @state.chunk.componentContent
		index = positions.indexOf(data.position) - 1

		if index < 0 then return

		@setPosition positions[index]

	increasePosition: ->
		data = @state.chunk.componentContent
		index = positions.indexOf(data.position) + 1

		if index > positions.length - 1 then return

		@setPosition positions[index]

	setPositionLeft: (event) ->
		event.preventDefault()
		@setPosition 'left'

	setPositionCenter: (event) ->
		event.preventDefault()
		@setPosition 'center'

	setPositionRight: (event) ->
		event.preventDefault()
		@setPosition 'right'

	onAnchorKeyDown: (event) ->
		switch event.keyCode
			when Keyboard.LEFT_ARROW
				event.preventDefault()
				@decreasePosition()
				return

			when Keyboard.RIGHT_ARROW
				event.preventDefault()
				@increasePosition()
				return

	todo: ->
		alert '@TODO'

	setImageURL: ->
		@props.editChunk @state.chunk

	onChange: (newValue) ->
		console.log 'YT on Change', newValue
		# @state.chunk.markDirty()
		# data = @state.chunk.componentContent
		# data.videoId = newValue
		@setState { userImageURL:newValue }

	onClose: ->
		@state.chunk.markDirty()
		@state.chunk.componentContent.url = @state.userImageURL

		@setState {
			chunk: @state.chunk
		}

		# @props.setTextMode on
		@props.editChunk null

		@props.selection.setFutureCaret @state.chunk.get('index'), { groupIndex:'anchor:img-anchor', offset:0 }
		@props.updateFn()

	render: ->
		data = @state.chunk.componentContent

		# focusedInCaption = (new TextGroupSelection @props.selection.chunk, @state.chunk).includes data.textGroup.first
		focusedInCaption = DOMSelection.includes @refs.caption
		focusedInAnchor = DOMSelection.includes @refs.anchorContainer

		`<NonEditableChunk className="obojobo-draft--chunks--figure" ref="component">
			<figure className={data.position + (data.textGroup.first.text.length === 0 && !focusedInCaption ? ' empty-caption' : '') + (focusedInAnchor ? ' focus-anchor' : '')} unselectable="on">
				<div className='anchor-container' ref="anchorContainer">
					<Anchor focusOutline name="img-anchor" onKeyDown={this.onAnchorKeyDown} />
					<img src={data.url} unselectable="on" />
					<div className="position-controls">
						<button onMouseDown={this.setPositionLeft}>Left</button>
						<button onMouseDown={this.setPositionCenter}>Center</button>
						<button onMouseDown={this.setPositionRight}>Right</button>
					</div>
					<div className="img-controls">
						<button onMouseDown={this.setImageURL}>Set image from URL</button>
						<button onMouseDown={this.todo}>Upload image</button>
					</div>
				</div>
				<figcaption contentEditable="true" onFocus={this.onFocus} onBlur={this.onBlur} ref="caption">
					<Text text={data.textGroup.first.text} groupIndex="0" />
				</figcaption>
			</figure>
			{ this.props.isEditing ? <SingleInputBubble label="Image URL" value={this.state.userImageURL} onChange={this.onChange} onClose={this.onClose} onCancel={this.onCancel} /> : null }
		</NonEditableChunk>`


module.exports = Figure