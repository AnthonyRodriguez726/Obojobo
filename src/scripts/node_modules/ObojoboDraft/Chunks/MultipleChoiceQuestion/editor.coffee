require './question.scss'

SelectableAnswerItem = require './selectableansweritem'

ObojoboDraft = require 'ObojoboDraft'

Assets = ObojoboDraft.Assets
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
TextGroupCommandHandler = ObojoboDraft.text.TextGroupCommandHandler
Chunk = ObojoboDraft.models.Chunk
Text = ObojoboDraft.components.Text
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
FocusableChunk = ObojoboDraft.components.FocusableChunk
Anchor = ObojoboDraft.components.Anchor
TextGroupSelection = ObojoboDraft.text.TextGroupSelection

class CommandHandler extends TextGroupCommandHandler
	selectAll: (selection, chunk) ->
		sel = new TextGroupSelection chunk, selection

		if sel.start.groupIndex is sel.end.groupIndex
			selection.setFutureStart chunk, { offset: 0, groupIndex: sel.start.groupIndex }
			selection.setFutureEnd chunk, { offset: chunk.componentContent.textGroup.get(sel.start.groupIndex).text.length, groupIndex: sel.start.groupIndex }

			return true

		false

	split: (selection, chunk) -> false
	splitText: (selection, chunk, shiftKey) ->
		chunk.insertText selection, "\n"

	getTextMenuCommands: (selection, chunk) ->
		if not chunk.editing then return []
		super selection, chunk

	deleteText: (selection, chunk, deleteForwards) ->
		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		# If backspacing and the start of a text that's not the first text...
		if not deleteForwards and sel.start.offset is 0 and sel.start.text isnt data.textGroup.first.text
			return false

		# If using delete key on the end of a text that's not the last text...
		if deleteForwards and sel.start.offset is sel.start.text.length and sel.start.text isnt data.textGroup.last.text and data.textGroup.length > 1
			return false

		super selection, chunk, deleteForwards

	canMergeWith: (selection, digestedChunk, consumerChunk) ->
		false

	deleteSelection: (selection, chunk) ->
		chunk.markDirty()
		data = chunk.componentContent

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection

		if sel.end.groupIndex isnt sel.start.groupIndex
			sel.end.groupIndex = sel.start.groupIndex
			sel.end.offset = data.textGroup.get(sel.start.groupIndex).text.length

		chunk.componentContent.textGroup.deleteSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

		pos = selection.chunk.getPosition chunk
		if pos is 'start' or pos is 'contains'
			selection.setFutureCaret chunk, sel.start.toObject()

	acceptAbsorb: (selection, chunkToBeDigested, consumerChunk) -> false
	absorb: (selection, consumerChunk, digestedChunk) -> false

	# onTab: (selection, chunk, untab) ->
	# 	sel = new TextGroupSelection chunk, selection

	# 	if sel.type is 'caret'
	# 		textGroup = chunk.componentContent.textGroup
	# 		if not untab
	# 			nextTextLen = textGroup.get(sel.start.groupIndex + 1).text.length
	# 			selection.setFutureCaret chunk, { offset: nextTextLen, groupIndex: sel.start.groupIndex + 1}
	# 		else
	# 			prevTextLen = textGroup.get(sel.start.groupIndex - 1).text.length
	# 			selection.setFutureCaret chunk, { offset: prevTextLen, groupIndex: sel.start.groupIndex - 1}

	# 		return true

	# 	super.onTab selection, chunk, onTab

Question = React.createClass
	statics:
		commandHandler: new CommandHandler
		consumableElements: ['p']
		insertLabel: ['Text']
		onInsert: (position, referenceChunk, selection, opts, callback) ->
			newChunk = Chunk.create @
			extraChunk = null

			switch position
				when 'before'
					referenceChunk.addBefore newChunk

					if newChunk.isFirst()
						extraChunk = Chunk.create()
						newChunk.addBefore extraChunk
					else
						extraChunk = newChunk.prevSibling()

				when 'after'
					referenceChunk.addAfter newChunk

					if newChunk.isLast()
						extraChunk = Chunk.create()
						newChunk.addAfter extraChunk
					else
						extraChunk = newChunk.nextSibling()

			# extraChunk.selectEnd selection
			# extraChunk.selectStart selection
			selection.setFutureCaret newChunk, { offset:0, groupIndex:'anchor:main' }

			callback()

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			group = TextGroup.create(Infinity, { score:0 })
			group.first.text = new StyleableText('Your question goes here?')
			group.add new StyleableText('First answer choice'), { score:100 }
			group.add new StyleableText('Correct feedback')
			group.add new StyleableText('Second answer choice'), { score:0 }
			group.add new StyleableText('Incorrect feedback')

			textGroup: group
			responseType: 'pick-one'

		cloneNodeData: (data) ->
			clone = data.textGroup.clone()
			# console.log 'ST.cloneNodeData', data
			textGroup: clone
			indent: data.indent
			type: data.type
			responseType: data.responseType

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			# console.log 'ST.createNodeDataFromDescriptor', descriptor
			#@TODO
			textGroup: TextGroup.fromDescriptor descriptor.content.textGroup, 1
			indent: descriptor.content.indent
			type: descriptor.content.type

		getDataDescriptor: (chunk) ->
			# console.log 'ST.getDataDescriptor', chunk
			#@TODO
			data = chunk.componentContent

			indent: data.indent
			textGroup: data.textGroup.toDescriptor()
			type: data.type

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			#@TODO
			group = TextGroup.create(1)
			group.first.text = StyleableText.createFromElement(el)

			[
				Chunk.create @, {
					textGroup: group
					indent: 0
					type: 'p'
				}
			]

	getInitialState: ->
		selectedAnswers: []

	deleteAnswer: (answerItem) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		# correctAnswer = @props.chunk.componentContent.correctAnswer * 2 + 1

		# console.clear()
		# console.log 'DELETE ANSWER!', index, correctAnswer
		# @props.chunk.componentContent.textGroup.remove index
		# @props.chunk.componentContent.textGroup.remove index

		# if @props.chunk.componentContent.textGroup.length is 1
		# 	console.log 'YAS'
		# 	@props.chunk.componentContent.textGroup.add()
		# 	@props.chunk.componentContent.textGroup.add()

		# if index is correctAnswer
		# 	@props.chunk.componentContent.correctAnswer = null
		# else if index < correctAnswer
		# 	@setCorrectAnswer index - 1

		index = data.textGroup.indexOf(answerItem)
		data.textGroup.remove index
		data.textGroup.remove index

		# @forceUpdate()
		@props.updateFn()

	addAnswer: ->
		@props.chunk.componentContent.textGroup.add()
		@props.chunk.componentContent.textGroup.add()
		@props.chunk.markDirty()
		@props.updateFn()

	toggleEditing: ->
		@props.chunk.markForUpdate()

		if @props.isEditing
			@props.stopEditing()

			setTimeout ( ->
				@props.selection.setFutureCaret @props.chunk, { offset:0, groupIndex:'anchor:main' }
				@props.updateFn()
			).bind(@)
		else
			@focusOnceEditing = true
			console.log '$$$$$$$$$$$$$$$$$$$$$$$$$$Edit', @onStopEditing
			@props.editChunk @props.chunk, false, @onStopEditing

	onStopEditing: ->
		# alert 'stop'
		@clearAnswers()

	onSelectAnswer: (answerItem) ->
		@props.chunk.markForUpdate()

		index = @state.selectedAnswers.indexOf(answerItem)
		if index > -1
			@state.selectedAnswers.splice index, 1
		else
			if @getPreviewInputType() is 'radio'
				@state.selectedAnswers = [answerItem]
			else
				@state.selectedAnswers.push answerItem

		# if @props.chunk.componentContent.responseType is 'pick-one-multiple-correct' and answerItem.data.score is 100
		# 	@setState { revealAll:true }

		@setState {
			selectedAnswers: @state.selectedAnswers
			revealAll: false
		}

	clearAnswers: ->
		@props.chunk.markForUpdate()
		@setState {
			selectedAnswers: []
			revealAll: false
		}

	getCorrectAnswers: ->
		correct = []
		for textItem in @props.chunk.componentContent.textGroup.items
			if textItem.data.score and textItem.data.score is 100
				correct.push textItem

		correct

	# setCorrectAnswer: (answerItem) ->
	# 	console.clear()

	# 	data = @props.chunk.componentContent

	# 	# console.log 'set correct answer', data.correctAnswer, data.correctAnswer * 2 + 1, data.textGroup

	# 	if data.correctAnswer?
	# 		data.correctAnswer.data.score = 0

	# 	data.correctAnswer = answerItem
	# 	data.correctAnswer.data.score = 100

	# 	# data.textGroup.get(data.correctAnswer * 2 + 1).data.score = 0

	# 	# data.correctAnswer = index
	# 	# data.textGroup.get(data.correctAnswer * 2 + 1).data.score = 100

	# 	@props.chunk.markDirty()
	# 	@props.updateFn()

	setCorrectAnswer: (answerItem) ->
		if @props.chunk.componentContent.responseType is 'pick-one'
			correctAnswers = @getCorrectAnswers()
			for correctAnswer in correctAnswers
				@setIncorrectAnswer correctAnswer

		answerItem.data.score = 100

		@props.chunk.markDirty()
		@props.updateFn()

	setIncorrectAnswer: (answerItem) ->
		console.log 'setIncorrectAnswer', answerItem

		answerItem.data.score = 0

		@props.chunk.markDirty()
		@props.updateFn()

	toggleCorrectAnswer: (answerItem) ->
		console.log 'toggleCorrectAnswer', answerItem

		if answerItem.data.score is 100
			@setIncorrectAnswer answerItem
		else
			@setCorrectAnswer answerItem

	onAnchorKeyDown: (event) ->
		if event.keyCode is 13
			event.preventDefault()
			@toggleEditing()

	shouldComponentUpdate: ->
		console.log '###should update', @props.chunk.needsUpdate
		@props.chunk.needsUpdate
		# true

	componentDidUpdate: ->
		console.log '###update'
		@props.chunk.markUpdated()

		if @focusOnceEditing
			delete @focusOnceEditing
			@props.selection.setFutureStart @props.chunk, { offset:0, groupIndex:0 }
			@props.selection.setFutureEnd @props.chunk, { offset:@props.chunk.componentContent.textGroup.first.text.length, groupIndex:0 }
			# @props.chunk.selectStart @props.selection
			@props.updateFn()

	render: ->
		console.log '##########_____render QUESTION', @props.isEditing

		data = @props.chunk.componentContent

		isEditing = @props.isEditing

		switch @props.isEditing
			when true  then @renderEditor()
			when false then @renderPreview()

	enableControls: ->
		# return
		@props.editChunk @props.chunk, true, @onStopEditing

	disableControls: ->
		# return
		@props.editChunk @props.chunk, false, @onStopEditing

	setResponseType: (event) ->
		@props.chunk.componentContent.responseType = event.target.value

		if event.target.value is 'pick-one'
			correctAnswers = @getCorrectAnswers()
			correctAnswers.shift()

			for answer in correctAnswers
				answer.data.score = 0

		@props.chunk.markDirty()
		@props.updateFn()

	revealAll: ->
		@props.chunk.markForUpdate()
		@setState { revealAll:true }

	getEditorInputType: ->
		data = @props.chunk.componentContent

		if data.responseType is 'pick-one' then return 'radio'
		'checkbox'

	getPreviewInputType: ->
		data = @props.chunk.componentContent

		if data.responseType is 'pick-one' or data.responseType is 'pick-one-multiple-correct' then return 'radio'
		'checkbox'

	renderPreview: ->
		data = @props.chunk.componentContent

		editButtonStyles =
			backgroundImage: Assets.getBackgroundImage(Assets.BUTTON_EDIT)

		instructions = switch data.responseType
			when 'pick-one' then 'Pick the correct answer'
			when 'pick-one-multiple-correct' then 'Pick a correct answer'
			when 'pick-one-or-more' then 'Pick all the correct answers'

		selectedAnswers = @state.selectedAnswers
		onSelectAnswer = @onSelectAnswer
		chunkIndex = @props.chunk.get('index')
		answers = []
		inputType = this.getPreviewInputType()
		correctAnswers = @getCorrectAnswers()
		completelyCorrect = false
		incorrect = false

		if selectedAnswers.length > 0
			switch inputType
				when 'radio'
					if correctAnswers.indexOf(selectedAnswers[0]) > -1
						completelyCorrect = true
					else
						incorrect = true

				when 'checkbox'
					if @state.revealAll
						completelyCorrect = true
						for answer in selectedAnswers
							if correctAnswers.indexOf(answer) is -1
								completelyCorrect = false
								break

						for answer in correctAnswers
							if selectedAnswers.indexOf(answer) is -1
								completelyCorrect = false
								break

						if not completelyCorrect then incorrect = true

		incorrect

		for i in [1...data.textGroup.items.length] by 2
			answer = data.textGroup.get(i)
			feedback = data.textGroup.get(i + 1)

			isCorrect = selectedAnswers.indexOf(answer) > -1

			answers.push `<SelectableAnswerItem
							key={i}
							type="preview"
							inputType={inputType}
							answer={answer}
							feedback={feedback}
							chunkIndex={chunkIndex}
							onSelect={onSelectAnswer}
							open={inputType === 'radio' ? (this.state.revealAll || isCorrect) : this.state.revealAll}
							checked={isCorrect}
						/>`

		`<FocusableChunk className={'obojobo-draft--chunks--question preview' + (completelyCorrect ? ' correct' : '') + (incorrect ? ' incorrect' : '')} ref="component" onKeyDown={this.onAnchorKeyDown} onDoubleClick={this.toggleEditing}>
			<button className="edit-button" onClick={this.toggleEditing} style={editButtonStyles}>Edit</button>
			<div className="question">
				<div className="input">
					<Text text={data.textGroup.first.text} groupIndex="0" />
				</div>
			</div>
			<span className="instructions">{instructions}:</span>
			<ul>
				{answers}
				<li className="answer blank" key="-1">
					<button onClick={this.revealAll} className="button reveal-all" disabled={this.state.revealAll}>
						{
							data.responseType === 'pick-one-or-more'
							?
							'Check your answers'
							:
							'Show All Answers'
						}
					</button>
					{
						true
						?
						<div className="container">
							<span className="divider"> - </span>
							<button onClick={this.clearAnswers} className="button clear" disabled={!(this.state.revealAll || selectedAnswers.length > 0)}>Reset</button>
						</div>
						:
						null
					}
				</li>
			</ul>
		</FocusableChunk>`

	renderEditor: ->

		data = @props.chunk.componentContent

		# editButtonStyles =
		# 	backgroundImage: Assets.getBackgroundImage(Assets.BUTTON_EDIT)

		deleteAnswer = @deleteAnswer
		chunkIndex = @props.chunk.get('index')
		setCorrectAnswer = @setCorrectAnswer
		enableControls = @enableControls
		disableControls = @disableControls
		toggleCorrectAnswer = @toggleCorrectAnswer
		correctAnswers = @getCorrectAnswers()
		# console.clear()
		# console.log '----------------------'
		# console.log '----------------------'
		# console.log '----------------------'
		# console.log correctAnswers
		answers = []
		for i in [1...data.textGroup.items.length] by 2
			answer = data.textGroup.get(i)
			feedback = data.textGroup.get(i + 1)

			answers.push `<SelectableAnswerItem
							key={i}
							type="editor"
							inputType={this.getEditorInputType()}
							answer={answer}
							feedback={feedback}
							chunkIndex={chunkIndex}
							checked={correctAnswers.indexOf(answer) > -1}
							onSelect={toggleCorrectAnswer}
							onDeleteAnswer={deleteAnswer}
							onFocus={enableControls}
							onBlur={disableControls}
						/>`

		`<NonEditableChunk className="obojobo-draft--chunks--question editor" ref="component">
			<div className="question">
				<div className="input" contentEditable="true" suppressContentEditableWarning={true} onFocus={this.enableControls} onBlur={this.disableControls}>
					<Text text={data.textGroup.first.text} groupIndex="0" />
				</div>
			</div>
			<div className="question-type">
				<span>Response type:</span>
				<select onChange={this.setResponseType} value={data.responseType}>
					<option value="pick-one">One correct answer - Student picks one</option>
					<option value="pick-one-multiple-correct">Multiple correct answers - Student picks one</option>
					<option value="pick-one-or-more">Multiple correct answers - Student picks all</option>
				</select>
			</div>
			<ul>
				{answers}
				<li className="answer blank" key="-1">
					<button onClick={this.addAnswer} className="button add-answer">+ New Answer Choice</button>
				</li>
			</ul>
		</NonEditableChunk>`


module.exports = Question