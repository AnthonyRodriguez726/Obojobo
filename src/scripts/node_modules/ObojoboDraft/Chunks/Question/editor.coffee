require './question.scss'

ObojoboDraft = require 'ObojoboDraft'

StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
TextGroupCommandHandler = ObojoboDraft.text.TextGroupCommandHandler
Chunk = ObojoboDraft.models.Chunk
Text = ObojoboDraft.components.Text
NonEditableChunk = ObojoboDraft.components.NonEditableChunk

Question = React.createClass
	statics:
		commandHandler: new TextGroupCommandHandler
		consumableElements: ['p']
		insertLabel: ['Text']
		onInsert: (position, referenceChunk, selection, opts, callback) ->
			newChunk = Chunk.create @

			switch position
				when 'before'
					referenceChunk.addBefore newChunk

				when 'after'
					referenceChunk.addAfter newChunk

			newChunk.selectStart selection

			callback()

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			group = TextGroup.create()
			group.add new StyleableText('a1'), { score:0 }
			group.add new StyleableText('a2'), { score:0 }

			textGroup: group

		cloneNodeData: (data) ->
			# console.log 'ST.cloneNodeData', data
			textGroup: data.textGroup.clone()
			indent: data.indent
			type: data.type

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			# console.log 'ST.createNodeDataFromDescriptor', descriptor
			textGroup: TextGroup.fromDescriptor descriptor.content.textGroup, 1
			indent: descriptor.content.indent
			type: descriptor.content.type

		getDataDescriptor: (chunk) ->
			# console.log 'ST.getDataDescriptor', chunk
			data = chunk.componentContent

			indent: data.indent
			textGroup: data.textGroup.toDescriptor()
			type: data.type

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			group = TextGroup.create(1)
			group.first.text = StyleableText.createFromElement(el)

			[
				Chunk.create @, {
					textGroup: group
					indent: 0
					type: 'p'
				}
			]

	deleteAnswer: (index) ->
		@props.chunk.componentContent.textGroup.remove index
		@props.chunk.markDirty()

	addAnswer: ->
		@props.chunk.componentContent.textGroup.add()
		@props.chunk.markDirty()

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate

	componentDidUpdate: ->
		@props.chunk.markUpdated()

	render: ->
		data = @props.chunk.componentContent

		deleteAnswer = @deleteAnswer
		answers = data.textGroup.items.map (item, index) ->
			if index is 0 then return null
			`<li key={index}>
				<div contentEditable="true"><Text text={item.text} groupIndex={index} /></div>
				<button onClick={deleteAnswer.bind(null, index)}>delete</button>
			</li>`



		`<NonEditableChunk className="obojobo-draft--chunks--question" ref="component">
			<p>Q:</p>
			<div className="question" contentEditable="true" suppressContentEditableWarning={true}>
				<Text text={data.textGroup.first.text} groupIndex="0" />
			</div>
			<p>A:</p>
			<ul>
				{answers}
			</ul>
			<button onClick={this.addAnswer}>Add answer</button>
		</NonEditableChunk>`


module.exports = Question