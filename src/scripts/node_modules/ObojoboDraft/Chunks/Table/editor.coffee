require './table.scss'

ObojoboDraft = require 'ObojoboDraft'

CreateForm = require './createform'
GridTextGroup = require './gridtextgroup'
TableControls = require './table-controls'

TextGroupCommandHandler = ObojoboDraft.text.TextGroupCommandHandler
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
TextGroupCursor = ObojoboDraft.text.TextGroupCursor
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk
MockElement = ObojoboDraft.mockDOM.MockElement
MockTextNode = ObojoboDraft.mockDOM.MockTextNode
SimpleMessage = ObojoboDraft.components.modal.SimpleMessage
Question = ObojoboDraft.components.modal.Question
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
Keyboard = ObojoboDraft.util.Keyboard


class CommandHandler extends TextGroupCommandHandler
	splitText: (sel, chunk, shiftKey) ->
		return @insertText sel, chunk, "\n"

	deleteSelection: (selection, chunk) ->
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection.module

		chunk.componentContent.textGroup.clearSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

		if sel.position is 'start' or sel.position is 'contains'
			selection.setFutureCaret chunk, { offset: sel.start.offset, groupIndex: sel.start.groupIndex }

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection.module
		data = chunk.componentContent

		[start, end] = if not deleteForwards then [sel.start.offset - 1, sel.start.offset] else [sel.start.offset, sel.start.offset + 1]

		sel.start.text.deleteText start, end

		selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }

	acceptAbsorb: -> false
	absorb: -> false
	split: -> false
	transformSelection: -> false

	# navigate: (selection, chunk, oldSelectionDescriptor) ->
	# 	##console.log 'navigate', oldSelectionDescriptor.start.data.groupIndex, selection.getSelectionDescriptor().start.data.groupIndex

	# 	currentIndex = selection.getSelectionDescriptor().start.data.groupIndex
	# 	oldIndex     = oldSelectionDescriptor.start.data.groupIndex

	# 	if currentIndex != oldIndex
	# 		selection.setFutureCaret chunk, { offset:0, groupIndex:3 }



Table = React.createClass
	statics:
		consumableElements: ['table']
		commandHandler: new CommandHandler
		insertLabel: ['Table']
		onInsert: (position, referenceChunk, selection, opts, callback) ->
			newChunk = Chunk.create @

			switch position
				when 'before'
					referenceChunk.addBefore newChunk

				when 'after'
					referenceChunk.addAfter newChunk

			newChunk.selectStart selection

			callback()






			# ##console.log 'onInsert', opts
			# if not opts.rows then opts.rows = ~~prompt('Rows?')
			# if not opts.cols then opts.cols = ~~prompt('Cols?')

			# group = TextGroup.create(opts.rows * opts.cols, {}, opts.rows * opts.cols)

			# newChunk = Chunk.create @, {
			# 	textGroup: group
			# 	position: 'center'
			# 	rows: opts.rows
			# 	cols: opts.cols
			# }

			# selection.setFutureCaret atIndex, { groupIndex:0, offset:0 }

			# callback newChunk

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			##console.log 'CNND', GridTextGroup.create(3, 3)
			textGroup: GridTextGroup.create(3, 3)
			position: 'center'
			header: true

		cloneNodeData: (data) ->
			textGroup: data.textGroup.clone()
			position: data.position
			header: data.header

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			content = descriptor.content

			gridTextGroup: GridTextGroup.fromDescriptor content.gridTextGroup
			position: content.position
			header: content.header

		getDataDescriptor: (chunk) ->
			data = chunk.componentContent

			gridTextGroup: data.textGroup.toDescriptor()
			position: data.position
			header: data.header

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			null
			# group = new TextGroup

			# maxNumCols = 0
			# rows = Array.prototype.slice.call el.getElementsByTagName('tr')
			# for row in rows
			# 	cols = Array.prototype.slice.call row.getElementsByTagName('td')
			# 	maxNumCols = Math.max maxNumCols, cols.length
			# 	for col in cols
			# 		group.add StyleableText.createFromElement(col)

			# group.maxItems = group.length

			# [
			# 	Chunk.create @, {
			# 		textGroup: group
			# 		position: 'center'
			# 		rows: rows.length
			# 		cols: maxNumCols
			# 	}
			# ]

	getInitialState: ->
		focus:
			row: 0
			col: 0

	addRow: (index) ->
		# console.clear()
		##console.log 'addRow', index
		##console.log @props.chunk.componentContent.textGroup.numRows

		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.addRow index

		@props.chunk.markForUpdate()

		#console.log 'addRow setState'
		@preventBlur = true
		@setState {
			focus:
				row: index
				col: @state.focus.col
		}

		##console.log 'addRow2', index
		##console.log @props.chunk.componentContent.textGroup.numRows


		# @props.updateSelectionFn()
		# @props.updateFn()

	addCol: (index) ->
		#console.log '~~~~addcol', __ds().startContainer

		sel = new TextGroupSelection @props.chunk, @props.selection.module
		#console.log 'sel', sel.type

		# return

		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.addCol index

		# @setState {
		# 	focus:
		# 		row: @state.focus.row
		# 		col: index
		# }

		@props.chunk.markForUpdate()
		# @props.updateSelectionFn()
		# @props.updateFn()

		# @preventBlur = {
		# 	row: @state.focus.row
		# 	col: index
		# }

		# setTimeout (->
		# 	# #console.log 'focus on', @refs.table, @state
		# 	@setState {
		# 		focus:
		# 			row: 0
		# 			col: index
		# 	}
		# # @refs.table.focus()
		# ).bind(@), 1000
		@preventBlur = true
		@setState {
			focus:
				row: 0
				col: index
		}

	removeRow: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if data.textGroup.numRows is 1
			@props.chunk.revert @props.selection
			@props.updateFn()
			return

		data.textGroup.removeRow index

		@props.chunk.markForUpdate()

		#console.log 'removeRow setState'
		@preventBlur = true
		@setState {
			focus:
				row: Math.min(Math.max(0, index), data.textGroup.numRows - 1)
				col: @state.focus.col
		}


		# @props.updateSelectionFn()
		# @props.updateFn()

	removeCol: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.removeCol index

		@props.chunk.markForUpdate()

		#console.log 'removeCol setState'
		@preventBlur = true
		@setState {
			focus:
				row: @state.focus.row
				col: Math.min(Math.max(0, index), data.textGroup.numCols - 1)
		}


		# @props.updateSelectionFn()
		# @props.updateFn()

	setDimensions: (rows, cols) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.setDimensions rows, cols

		@props.updateFn()

	onBlur: ->
		# console.clear()
		#console.log '~~~blur', __ds().startContainer, @preventBlur

		@props.chunk.markForUpdate()

		if @preventBlur?
			delete @preventBlur
			event.preventDefault()
		else

			#console.log 'onBlur null setState'
			@setState {
				focus: null
			}

		@props.updateFn()


	updateControls: (event) ->
		# return #@TODO
		# return
		#console.log '~~~update controls', __ds().startContainer
		# return
		# if @props.selection?.chunk?.start?.node?
		# 	##console.log 'Table::onMouseUp', @props.selection.chunk.start.chunk.get('index'), ObojoboDraft.components.Text.getOboTextInfo(@props.selection.chunk.start.node)

		# # alert 'was working on a way to get the buttons to show up where i want them to'
		# ##console.log event.target
		@props.updateSelectionFn()

		sel = new TextGroupSelection @props.chunk, @props.selection.module
		##console.log 'ssel', sel
		if sel.type is 'caret'
			groupIndex = sel.start.groupIndex


			# ti = Text.getOboTextInfo @props.selection.chunk.start.node, 0

			#console.log 'updateControls setState'
			@setState {
				focus:
					@props.chunk.componentContent.textGroup.getCellPositionForIndex groupIndex
			}

			@props.chunk.markForUpdate()
			@props.updateFn()

	onKeyDown: (event) ->
		##console.log 'TABLE ON KEY DOWN'
		if event.keyCode is Keyboard.UP_ARROW
			sel = new TextGroupSelection @props.chunk, @props.selection.module
			##console.log '____on key down', sel

			focus =
				row: @state.focus.row - 1
				col: @state.focus.col

			newIndex = @props.chunk.componentContent.textGroup.getIndexForCellPosition focus
			if newIndex isnt -1
				event.preventDefault()
				event.stopPropagation()

				#console.log 'onKeyDown setState'
				@setState {
					focus: focus
				}
				@skipKeyUp = true
				@props.chunk.markForUpdate()

				return false
			else
				# console.clear()
				event.preventDefault()
				event.stopPropagation()
				@props.chunk.prevSibling().selectEnd @props.selection
				@skipKeyUp = true
				@props.updateFn()
				return false
		else if event.keyCode is Keyboard.DOWN_ARROW
			sel = new TextGroupSelection @props.chunk, @props.selection.module
			##console.log '____on key down', sel

			focus =
				row: @state.focus.row + 1
				col: @state.focus.col

			newIndex = @props.chunk.componentContent.textGroup.getIndexForCellPosition focus
			if newIndex isnt -1
				event.preventDefault()
				event.stopPropagation()

				#console.log 'onKeyDown 2 setState'
				@setState {
					focus: focus
				}
				@skipKeyUp = true
				@props.chunk.markForUpdate()

				return false
			else
				# console.clear()
				event.preventDefault()
				event.stopPropagation()
				@props.chunk.nextSibling().selectStart @props.selection
				@skipKeyUp = true
				@props.updateFn()
				return false
		else if event.keyCode is Keyboard.RIGHT_ARROW
			sel = new TextGroupSelection @props.chunk, @props.selection.module
			##console.log '____on key down', sel

			if @state.focus.col is @props.chunk.componentContent.textGroup.numCols - 1
				focus =
					row: @state.focus.row + 1
					col: 0
			else
				focus =
					row: @state.focus.row
					col: @state.focus.col + 1

			newIndex = @props.chunk.componentContent.textGroup.getIndexForCellPosition focus
			if newIndex isnt -1 and sel.start.text.length is 0
				event.preventDefault()
				event.stopPropagation()

				#console.log 'onKeyDown 3 setState'
				@setState {
					focus: focus
				}
				@skipKeyUp = true
				@props.chunk.markForUpdate()

				return false
		else if event.keyCode is Keyboard.LEFT_ARROW
			sel = new TextGroupSelection @props.chunk, @props.selection.module
			##console.log '____on key down', sel

			if @state.focus.col is 0
				focus =
					row: @state.focus.row - 1
					col: @props.chunk.componentContent.textGroup.numCols - 1
			else
				focus =
					row: @state.focus.row
					col: @state.focus.col - 1

			newIndex = @props.chunk.componentContent.textGroup.getIndexForCellPosition focus
			if newIndex isnt -1 and sel.start.text.length is 0
				event.preventDefault()
				event.stopPropagation()

				#console.log 'onKeyDown 4 onSetState'
				@setState {
					focus: focus
				}
				@skipKeyUp = true
				@props.chunk.markForUpdate()

				return false

		true

	onKeyUp: (event) ->
		# return
		# event.preventDefault()
		# return
		if @skipKeyUp
			delete @skipKeyUp
			return

		##console.log 'TABLE ON KEY UP'
		# if @props.chunk.needsUpdate then return true
		@updateControls()
		return true

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate

	componentDidUpdate: ->
		@props.chunk.markUpdated()
		#
		sel = new TextGroupSelection @props.chunk, @props.selection.module
		if sel.type isnt 'none'
			@refs.table.focus()

	render: ->
		#console.log '___RENDER', @state, __ds().startContainer
		# if @state.focus?.col?
			#console.log @state.focus.col
		chunk = @props.chunk
		data = chunk.componentContent
		numCols = data.textGroup.numCols

		sel = new TextGroupSelection chunk, @props.selection.module
		#console.log '>>>>>>>>>>>>>>>>>>>Table.Render', sel.type
		if sel.type is 'caret'
			##console.log 'oh cool', @state.focus
			groupIndex = data.textGroup.getIndexForCellPosition @state.focus
			#console.log '%%%%%compare', sel.start.groupIndex, groupIndex
			if sel.start.groupIndex isnt groupIndex
				#console.log '%%%%%%%%%%%%%%%%%%%%%%%%%%lets do it!'
				@props.selection.setFutureCaret @props.chunk, { offset:Math.min(sel.start.offset, data.textGroup.get(groupIndex).text.length), groupIndex:groupIndex }
				desc = @props.selection.getFutureDescriptor()
				##console.log 'desc', desc

				# ##console.log 'module', @props, @props.module
				@props.selection.selectFromDescriptor @props.module, desc
		# ##console.log cellPos, (cellPos.col / data.textGroup.numCols * 100) + '%'

		if data.header
			row = data.textGroup.items.slice(0, numCols).map (textGroupItem, index) ->
				`<th key={index} className={'cell row-0 col-' + index}><Text text={textGroupItem.text} groupIndex={index} /></th>`

			header = `<tr key="header">
				{ row }
			</tr>`
		else
			header = null

		startIndex = if data.header then 1 else 0
		rows = [startIndex...data.textGroup.numRows].map (rowNum) ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
				`<td key={index} className={'cell row-' + rowNum + ' col-' + index}><Text text={textGroupItem.text} groupIndex={rowNum * numCols + index} /></td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`


		`<NonEditableChunk className="obojobo-draft--chunks--table">
			<div className="container">
				{
					sel.type === 'caret'
					?
					<TableControls
						selection={this.props.selection}
						chunk={this.props.chunk}
						focus={this.state.focus}
						addRow={this.addRow}
						addCol={this.addCol}
						removeRow={this.removeRow}
						removeCol={this.removeCol}
					/>
					:
					null
				}
				<table
					ref="table"
					key="table"
					contentEditable="true"
					suppressContentEditableWarning={true}
					onMouseUp={this.updateControls}
					onKeyDown={this.onKeyDown}
					onKeyUp={this.onKeyUp}
					onFocus={this.updateControls}
					onBlur={this.onBlur}
				>
					<thead key="thead">
						{header}
					</thead>
					<tbody key="tbody">
						{rows}
					</tbody>
				</table>
			</div>
		</NonEditableChunk>`


module.exports = Table