require './table.scss'

ObojoboDraft = require 'ObojoboDraft'

CreateForm = require './createform'
GridTextGroup = require './gridtextgroup'
TableControls = require './table-controls'

TextGroupCommandHandler = ObojoboDraft.text.TextGroupCommandHandler
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
TextGroupCursor = ObojoboDraft.text.TextGroupCursor
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk
MockElement = ObojoboDraft.mockDOM.MockElement
MockTextNode = ObojoboDraft.mockDOM.MockTextNode
SimpleMessage = ObojoboDraft.components.modal.SimpleMessage
Question = ObojoboDraft.components.modal.Question
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
Keyboard = ObojoboDraft.util.Keyboard


class CommandHandler extends TextGroupCommandHandler
	splitText: (sel, chunk, shiftKey) ->
		return @insertText sel, chunk, "\n"

	deleteSelection: (selection, chunk) ->
		chunk.markDirty()

		sel = new TextGroupSelection selection.chunk, chunk

		chunk.componentContent.textGroup.clearSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

		if sel.position is 'start' or sel.position is 'contains'
			selection.setFutureCaret chunk, { offset: sel.start.offset, groupIndex: sel.start.groupIndex }

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		sel = new TextGroupSelection selection.chunk, chunk
		data = chunk.componentContent

		[start, end] = if not deleteForwards then [sel.start.offset - 1, sel.start.offset] else [sel.start.offset, sel.start.offset + 1]

		sel.start.text.deleteText start, end

		selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }

	acceptAbsorb: -> false
	absorb: -> false
	split: -> false
	transformSelection: -> false

	# navigate: (selection, chunk, oldSelectionDescriptor) ->
	# 	#console.log 'navigate', oldSelectionDescriptor.start.data.groupIndex, selection.getSelectionDescriptor().start.data.groupIndex

	# 	currentIndex = selection.getSelectionDescriptor().start.data.groupIndex
	# 	oldIndex     = oldSelectionDescriptor.start.data.groupIndex

	# 	if currentIndex != oldIndex
	# 		selection.setFutureCaret chunk, { offset:0, groupIndex:3 }



Table = React.createClass
	statics:
		consumableElements: ['table']
		commandHandler: new CommandHandler
		insertLabel: ['Table']
		onInsert: (position, referenceChunk, selection, opts, callback) ->
			newChunk = Chunk.create @

			switch position
				when 'before'
					referenceChunk.addBefore newChunk

				when 'after'
					referenceChunk.addAfter newChunk

			newChunk.selectStart selection

			callback()






			# #console.log 'onInsert', opts
			# if not opts.rows then opts.rows = ~~prompt('Rows?')
			# if not opts.cols then opts.cols = ~~prompt('Cols?')

			# group = TextGroup.create(opts.rows * opts.cols, {}, opts.rows * opts.cols)

			# newChunk = Chunk.create @, {
			# 	textGroup: group
			# 	position: 'center'
			# 	rows: opts.rows
			# 	cols: opts.cols
			# }

			# selection.setFutureCaret atIndex, { groupIndex:0, offset:0 }

			# callback newChunk

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			#console.log 'CNND', GridTextGroup.create(3, 3)
			textGroup: GridTextGroup.create(3, 3)
			position: 'center'
			header: true

		cloneNodeData: (data) ->
			textGroup: data.textGroup.clone()
			position: data.position
			header: data.header

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			content = descriptor.content

			gridTextGroup: GridTextGroup.fromDescriptor content.gridTextGroup
			position: content.position
			header: content.header

		getDataDescriptor: (chunk) ->
			data = chunk.componentContent

			gridTextGroup: data.textGroup.toDescriptor()
			position: data.position
			header: data.header

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			null
			# group = new TextGroup

			# maxNumCols = 0
			# rows = Array.prototype.slice.call el.getElementsByTagName('tr')
			# for row in rows
			# 	cols = Array.prototype.slice.call row.getElementsByTagName('td')
			# 	maxNumCols = Math.max maxNumCols, cols.length
			# 	for col in cols
			# 		group.add StyleableText.createFromElement(col)

			# group.maxItems = group.length

			# [
			# 	Chunk.create @, {
			# 		textGroup: group
			# 		position: 'center'
			# 		rows: rows.length
			# 		cols: maxNumCols
			# 	}
			# ]

	getInitialState: ->
		focus:
			row: 0
			col: 0

	addRow: (index) ->
		console.clear()
		#console.log 'addRow', index
		#console.log @props.chunk.componentContent.textGroup.numRows

		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.addRow index

		@setState {
			focus:
				row: index
				col: @state.focus.col
		}

		#console.log 'addRow2', index
		#console.log @props.chunk.componentContent.textGroup.numRows

		@props.chunk.markForUpdate()
		@props.updateSelectionFn()
		@props.updateFn()

	addCol: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.addCol index

		@setState {
			focus:
				row: @state.focus.row
				col: index
		}

		@props.chunk.markForUpdate()
		@props.updateSelectionFn()
		@props.updateFn()

	removeRow: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if data.textGroup.numRows is 1
			@props.chunk.revert @props.selection
			@props.updateFn()
			return

		data.textGroup.removeRow index

		@setState {
			focus:
				row: Math.min(Math.max(0, index), data.textGroup.numRows - 1)
				col: @state.focus.col
		}

		@props.chunk.markForUpdate()
		@props.updateSelectionFn()
		@props.updateFn()

	removeCol: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.removeCol index

		@setState {
			focus:
				row: @state.focus.row
				col: Math.min(Math.max(0, index), data.textGroup.numCols - 1)
		}

		@props.chunk.markForUpdate()
		@props.updateSelectionFn()
		@props.updateFn()

	setDimensions: (rows, cols) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.setDimensions rows, cols

		@props.updateFn()


	updateControls: (event) ->
		# return
		# if @props.selection?.chunk?.start?.node?
		# 	#console.log 'Table::onMouseUp', @props.selection.chunk.start.chunk.get('index'), ObojoboDraft.components.Text.getOboTextInfo(@props.selection.chunk.start.node)

		# # alert 'was working on a way to get the buttons to show up where i want them to'
		# #console.log event.target
		@props.updateSelectionFn()

		sel = new TextGroupSelection @props.selection.chunk, @props.chunk
		#console.log 'ssel', sel
		if sel.type is 'caret'
			groupIndex = sel.start.groupIndex


			# ti = Text.getOboTextInfo @props.selection.chunk.start.node, 0

			@setState {
				focus:
					@props.chunk.componentContent.textGroup.getCellPositionForIndex groupIndex
			}

			@props.chunk.markForUpdate()
			@props.updateFn()

	onKeyDown: (event) ->
		#console.log 'TABLE ON KEY DOWN'
		if event.keyCode is Keyboard.UP_ARROW
			sel = new TextGroupSelection @props.selection.chunk, @props.chunk
			#console.log '____on key down', sel

			focus =
				row: @state.focus.row - 1
				col: @state.focus.col

			newIndex = @props.chunk.componentContent.textGroup.getIndexForCellPosition focus
			if newIndex isnt -1
				event.preventDefault()
				event.stopPropagation()

				@setState {
					focus: focus
				}
				@skipKeyUp = true
				@props.chunk.markForUpdate()

				return false
			else
				console.clear()
				event.preventDefault()
				event.stopPropagation()
				@props.chunk.prevSibling().selectEnd @props.selection
				@skipKeyUp = true
				@props.updateFn()
				return false
		else if event.keyCode is Keyboard.DOWN_ARROW
			sel = new TextGroupSelection @props.selection.chunk, @props.chunk
			#console.log '____on key down', sel

			focus =
				row: @state.focus.row + 1
				col: @state.focus.col

			newIndex = @props.chunk.componentContent.textGroup.getIndexForCellPosition focus
			if newIndex isnt -1
				event.preventDefault()
				event.stopPropagation()

				@setState {
					focus: focus
				}
				@skipKeyUp = true
				@props.chunk.markForUpdate()

				return false
			else
				console.clear()
				event.preventDefault()
				event.stopPropagation()
				@props.chunk.nextSibling().selectStart @props.selection
				@skipKeyUp = true
				@props.updateFn()
				return false
		else if event.keyCode is Keyboard.RIGHT_ARROW
			sel = new TextGroupSelection @props.selection.chunk, @props.chunk
			#console.log '____on key down', sel

			if @state.focus.col is @props.chunk.componentContent.textGroup.numCols - 1
				focus =
					row: @state.focus.row + 1
					col: 0
			else
				focus =
					row: @state.focus.row
					col: @state.focus.col + 1

			newIndex = @props.chunk.componentContent.textGroup.getIndexForCellPosition focus
			if newIndex isnt -1 and sel.start.text.length is 0
				event.preventDefault()
				event.stopPropagation()

				@setState {
					focus: focus
				}
				@skipKeyUp = true
				@props.chunk.markForUpdate()

				return false
		else if event.keyCode is Keyboard.LEFT_ARROW
			sel = new TextGroupSelection @props.selection.chunk, @props.chunk
			#console.log '____on key down', sel

			if @state.focus.col is 0
				focus =
					row: @state.focus.row - 1
					col: @props.chunk.componentContent.textGroup.numCols - 1
			else
				focus =
					row: @state.focus.row
					col: @state.focus.col - 1

			newIndex = @props.chunk.componentContent.textGroup.getIndexForCellPosition focus
			if newIndex isnt -1 and sel.start.text.length is 0
				event.preventDefault()
				event.stopPropagation()

				@setState {
					focus: focus
				}
				@skipKeyUp = true
				@props.chunk.markForUpdate()

				return false

		true

	onKeyUp: (event) ->
		# return
		# event.preventDefault()
		# return
		if @skipKeyUp
			delete @skipKeyUp
			return

		#console.log 'TABLE ON KEY UP'
		# if @props.chunk.needsUpdate then return true
		@updateControls()
		return true

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate

	componentDidUpdate: ->
		@props.chunk.markUpdated()

	render: ->
		console.log '___RENDER'
		chunk = @props.chunk
		data = chunk.componentContent
		numCols = data.textGroup.numCols

		sel = new TextGroupSelection @props.selection.chunk, chunk
		console.log 'Table.Render', sel
		if sel.type is 'caret'
			#console.log 'oh cool', @state.focus
			groupIndex = data.textGroup.getIndexForCellPosition @state.focus
			#console.log 'compare', sel.start.groupIndex, groupIndex
			if sel.start.groupIndex isnt groupIndex
				#console.log 'lets do it!'
				@props.selection.setFutureCaret @props.chunk, { offset:Math.min(sel.start.offset, data.textGroup.get(groupIndex).text.length), groupIndex:groupIndex }
				desc = @props.selection.getFutureDescriptor()
				#console.log 'desc', desc

				# #console.log 'module', @props, @props.module
				@props.selection.selectFromDescriptor @props.module, desc
		# #console.log cellPos, (cellPos.col / data.textGroup.numCols * 100) + '%'

		alert 'was working on table headers'
		header = ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
				`<td key={index} className={'row-' + rowNum + ' col-' + index}><Text text={textGroupItem.text} groupIndex={rowNum * numCols + index} /></td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`

		rows = [0...data.textGroup.numRows].map (rowNum) ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
				`<td key={index} className={'row-' + rowNum + ' col-' + index}><Text text={textGroupItem.text} groupIndex={rowNum * numCols + index} /></td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`


		`<NonEditableChunk className="obojobo-draft--chunks--table">
			<div className="container">
				{
					sel.type === 'caret'
					?
					<TableControls
						chunk={this.props.chunk}
						focus={this.state.focus}
						addRow={this.addRow}
						addCol={this.addCol}
						removeRow={this.removeRow}
						removeCol={this.removeCol}
					/>
					:
					null
				}
				<table
					key="table"
					contentEditable="true"
					suppressContentEditableWarning={true}
					onMouseUp={this.updateControls}
					onKeyDown={this.onKeyDown}
					onKeyUp={this.onKeyUp}
					onFocus={this.updateControls}
				>
					<thead key="thead">
						{header}
					</thead>
					<tbody key="tbody">
						{rows}
					</tbody>
				</table>
			</div>
		</NonEditableChunk>`


module.exports = Table