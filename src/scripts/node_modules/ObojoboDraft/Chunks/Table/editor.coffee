console.log '@TODO - I need to use different CommandHandlers depending on if editing or not'

require './table.scss'

ObojoboDraft = require 'ObojoboDraft'

CreateForm = require './createform'
GridTextGroup = require './gridtextgroup'
TableControls = require './table-controls'
TableMenu = require './tablemenu'

TextGroupCommandHandler = ObojoboDraft.text.TextGroupCommandHandler
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
TextGroupCursor = ObojoboDraft.text.TextGroupCursor
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk
MockElement = ObojoboDraft.mockDOM.MockElement
MockTextNode = ObojoboDraft.mockDOM.MockTextNode
SimpleMessage = ObojoboDraft.components.modal.SimpleMessage
Question = ObojoboDraft.components.modal.Question
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
FocusableChunk = ObojoboDraft.components.FocusableChunk
Keyboard = ObojoboDraft.page.Keyboard


class CommandHandler extends TextGroupCommandHandler
	selectStart: (selection, chunk) ->
		selection.setFutureCaret chunk, { groupIndex:'anchor:main', offset:0 }

	selectEnd: (selection, chunk) ->
		selection.setFutureCaret chunk, { groupIndex:'anchor:main', offset:0 }

	splitText: (sel, chunk, shiftKey) ->
		return @insertText sel, chunk, "\n"

	deleteSelection: (selection, chunk) ->
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection

		chunk.componentContent.textGroup.clearSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

		if sel.position is 'start' or sel.position is 'contains'
			selection.setFutureCaret chunk, { offset: sel.start.offset, groupIndex: sel.start.groupIndex }

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		[start, end] = if not deleteForwards then [sel.start.offset - 1, sel.start.offset] else [sel.start.offset, sel.start.offset + 1]

		sel.start.text.deleteText start, end

		selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }

	acceptAbsorb: -> false
	absorb: -> false
	split: -> false
	transformSelection: -> false


Table = React.createClass
	statics:
		consumableElements: ['table']
		commandHandler: new CommandHandler
		insertLabel: ['Table']
		onInsert: (position, referenceChunk, selection, opts, callback) ->
			newChunk = Chunk.create @

			switch position
				when 'before'
					referenceChunk.addBefore newChunk

				when 'after'
					referenceChunk.addAfter newChunk

			newChunk.selectStart selection

			callback()

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			##console.log 'CNND', GridTextGroup.create(3, 3)
			textGroup: GridTextGroup.create(3, 3)
			position: 'center'
			header: true

		cloneNodeData: (data) ->
			textGroup: data.textGroup.clone()
			position: data.position
			header: data.header

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			content = descriptor.content

			gridTextGroup: GridTextGroup.fromDescriptor content.gridTextGroup
			position: content.position
			header: content.header

		getDataDescriptor: (chunk) ->
			data = chunk.componentContent

			gridTextGroup: data.textGroup.toDescriptor()
			position: data.position
			header: data.header

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			null

	getInitialState: ->
		focus:
			row: 0
			col: 0
			offset: 'start'

	addRow: (index = null) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if not index? then index = data.textGroup.numRows

		data.textGroup.addRow index

		@setState {
			focus:
				row: index
				col: @state.focus.col
				offset: 'start'
		}

	addCol: (index = null) ->
		console.log 'addCol', index
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if not index? then index = data.textGroup.numCols

		data.textGroup.addCol index

		console.log 'new state'
		console.log {
			focus:
				row: @state.focus.row
				col: index
				offset: 'start'
		}

		@setState {
			focus:
				row: @state.focus.row
				col: index
				offset: 'start'
		}

	removeRow: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if data.textGroup.numRows is 1
			@props.chunk.revert @props.selection
			@props.updateFn()
			return

		data.textGroup.removeRow index

		if @state.focus.row >= index
			@setState {
				focus:
					row: Math.min(index, data.textGroup.numRows - 1)
					col: @state.focus.col
					offset: 'end'
			}

	removeCol: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if data.textGroup.numCols is 1
			@props.chunk.revert @props.selection
			@props.updateFn()
			return

		data.textGroup.removeCol index

		if @state.focus.col >= index
			@setState {
				focus:
					row: @state.focus.row
					col: Math.min(index, data.textGroup.numCols - 1)
					offset: 'end'
			}

	updateControls: (event) ->
		@props.updateSelectionFn()

		sel = new TextGroupSelection @props.chunk, @props.selection

		if sel.type is 'caret'
			groupIndex = sel.start.groupIndex

			@props.chunk.markForUpdate()
			@props.updateFn()

	onKeyDown2: (newFocus) ->
		if @props.chunk.componentContent.textGroup.getIndexForCellPosition(newFocus) isnt -1
			@setState { focus: newFocus }
			@props.chunk.markForUpdate()
		else
			@props.chunk.prevSibling().selectEnd @props.selection
			@props.updateFn()

		@skipKeyUp = true
		return false

	onKeyDown: (event) ->
		arrowKeyPressed = false

		sel = new TextGroupSelection @props.chunk, @props.selection
		return true if sel.type isnt 'caret'

		switch event.keyCode
			when Keyboard.UP_ARROW
				@onKeyDown2 {
					row: @state.focus.row - 1
					col: @state.focus.col
					offset: 'end'
				}

				arrowKeyPressed = true

			when Keyboard.DOWN_ARROW
				@onKeyDown2 {
					row: @state.focus.row + 1
					col: @state.focus.col
					offset: 'end'
				}

				arrowKeyPressed = true

			when Keyboard.RIGHT_ARROW
				if sel.start.offset is sel.start.text.length
					if @state.focus.col is @props.chunk.componentContent.textGroup.numCols - 1
						@onKeyDown2 {
							row: @state.focus.row + 1
							col: 0
							offset: 'start'
						}
					else
						@onKeyDown2 {
							row: @state.focus.row
							col: @state.focus.col + 1
							offset: 'start'
						}

					arrowKeyPressed = true

			when Keyboard.LEFT_ARROW

				if sel.start.offset is 0
					if @state.focus.col is 0
						if @state.focus.row isnt 0
							@onKeyDown2 {
								row: @state.focus.row - 1
								col: @props.chunk.componentContent.textGroup.numCols - 1
								offset: 'end'
							}
					else
						@onKeyDown2 {
							row: @state.focus.row
							col: @state.focus.col - 1
							offset: 'end'
						}

					arrowKeyPressed = true

		if arrowKeyPressed
			event.preventDefault()
			event.stopPropagation()
			return false

		true

	onKeyUp: (event) ->
		if @skipKeyUp
			delete @skipKeyUp
			return

		@updateControls()
		return true

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate

	componentDidUpdate: (prevProps, prevState) ->
		@props.chunk.markUpdated()

		if @props.isEditing and not prevProps.isEditing
			setTimeout (->
				@refs.editTable.focus()
				@updateControls()
			).bind(@)

		sel = new TextGroupSelection @props.chunk, @props.selection

		@selectCell sel

	selectCell: (sel) ->
		chunk = @props.chunk
		data = chunk.componentContent

		console.log 'selectCell', sel.start.groupIndex

		if sel.type is 'caret'
			groupIndex = data.textGroup.getIndexForCellPosition @state.focus
			console.log 'KOMPARE', sel.start.groupIndex, groupIndex
			if sel.start.groupIndex? and sel.start.groupIndex isnt groupIndex
				console.log 'WILL'

				offset = switch @state.focus.offset
					when 'start' then 0
					when 'end' then data.textGroup.get(groupIndex).text.length



				@props.selection.setFutureCaret @props.chunk, { offset:offset, groupIndex:groupIndex }
				desc = @props.selection.getFutureDescriptor()

				console.log 'will select', desc.start.data.groupIndex

				@props.selection.selectFromDescriptor @props.module, desc

	onTableMenuCommand: (info) ->
		@refs.editTable.focus()

		switch info.command
			when 'insertColLeft'
				@addCol info.col

			when 'insertColRight'
				@addCol info.col + 1

			when 'insertRowAbove'
				@addRow info.row

			when 'insertRowBelow'
				@addRow info.row + 1

			when 'deleteCol'
				@removeCol info.col

			when 'deleteRow'
				@removeRow info.row


	onDoubleClick: (event) ->
		if document.elementsFromPoint?
			els = document.elementsFromPoint event.clientX, event.clientY

			for el in els
				if el.getAttribute('data-table-position')?
					attrs = el.getAttribute('data-table-position').split(',')
					if attrs[0] is @props.chunk.get('id')
						return @startEditing ~~attrs[1], ~~attrs[2]

		@startEditing 0, 0

	startEditing: (row = 0, col = 0) ->
		@setFocus row, col, 'end'

		@props.editChunk @props.chunk, { textControlsEnabled:true }

	setFocus: (row, col, offset) ->
		@props.chunk.markForUpdate()

		@setState {
			focus:
				row: row
				col: col
				offset: offset
		}

	render: ->
		if @props.isEditing
			@renderTableWithControls()
		else
			@renderPreview()

	renderTableWithControls: ->
		chunk = @props.chunk
		data = chunk.componentContent
		numCols = data.textGroup.numCols
		numRows = data.textGroup.numRows
		onTableMenuCommand = @onTableMenuCommand

		header = [0...numCols + 1].map (i) ->
			`<th>{i === 0 ? null : <TableMenu onMenuCommand={onTableMenuCommand} type="col" col={i - 1} />}</th>`

		header = `<tr>{header}</tr>`

		rows = [0...numRows - 1].map (i) ->
			`<tr><td><TableMenu onMenuCommand={onTableMenuCommand} type="row" row={i + 1} /></td></tr>`

		`<NonEditableChunk className="obojobo-draft--chunks--table pad">
			<div className="container editing">
				{
					false && this.props.isEditing
					?
					<TableControls
						selection={this.props.selection}
						chunk={this.props.chunk}
						focus={this.state.focus}
						addRow={this.addRow}
						addCol={this.addCol}
						removeRow={this.removeRow}
						removeCol={this.removeCol}
					/>
					:
					null
				}
				<table
					ref="containerTable"
					key="containerTable"
					className='container-table'
				>
					<thead key="thead">
						{header}
					</thead>
					<tbody key="tbody">
						<tr>
							<td><TableMenu onMenuCommand={onTableMenuCommand} type="row" row={0} /></td>
							<td rowSpan={numRows} colSpan={numCols} className="edit-table-cell">
								{this.renderEditTable()}
							</td>
						</tr>
						{rows}
					</tbody>
				</table>
			</div>
		</NonEditableChunk>`

	renderEditTable: ->
		console.log '___RENDER', __ds().startContainer
		# if @state.focus?.col?
			#console.log @state.focus.col
		chunk = @props.chunk
		data = chunk.componentContent
		numCols = data.textGroup.numCols
		setFocus = @setFocus



		if data.header
			row = data.textGroup.items.slice(0, numCols).map (textGroupItem, index) ->
				`<th
					key={index}
					className={'cell row-0 col-' + index}
					data-table-position={chunk.get('id') + ',0,' + index}
					onMouseUp={setFocus.bind(null, 0, index, 'end')}
				>
					<Text text={textGroupItem.text} groupIndex={index} />
				</th>`

			header = `<tr key="header">
				{ row }
			</tr>`
		else
			header = null

		startIndex = if data.header then 1 else 0
		rows = [startIndex...data.textGroup.numRows].map (rowNum) ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
				`<td
					key={index}
					className={'cell row-' + rowNum + ' col-' + index}
					data-table-position={chunk.get('id') + ',' + rowNum + ',' + index}
					onMouseUp={setFocus.bind(null, rowNum, index, 'end')}
				>
					<Text text={textGroupItem.text} groupIndex={rowNum * numCols + index} />
				</td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`


		`<table
			className='edit-table'
			ref="editTable"
			key="editTable"
			contentEditable="true"
			suppressContentEditableWarning={true}
			onMouseUp={this.updateControls}
			onKeyDown={this.onKeyDown}
			onKeyUp={this.onKeyUp}
			onFocus={this.updateControls}
		>
			<thead key="thead">
				{header}
			</thead>
			<tbody key="tbody">
				{rows}
			</tbody>
		</table>`

	renderPreview: ->
		#console.log '___RENDER', @state, __ds().startContainer
		# if @state.focus?.col?
			#console.log @state.focus.col
		chunk = @props.chunk
		data = chunk.componentContent
		numCols = data.textGroup.numCols
		# startEditing = @startEditing

		# sel = new TextGroupSelection chunk, @props.selection

		# @selectCell sel

		if data.header
			row = data.textGroup.items.slice(0, numCols).map (textGroupItem, index) ->
				`<th
					key={index}
					className={'cell row-0 col-' + index}
					data-table-position={chunk.get('id') + ',0,' + index}
				>
					<Text text={textGroupItem.text} groupIndex={index} />
				</th>`

			header = `<tr key="header">
				{ row }
			</tr>`
		else
			header = null

		startIndex = if data.header then 1 else 0
		rows = [startIndex...data.textGroup.numRows].map (rowNum) ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
				`<td
					key={index}
					className={'cell row-' + rowNum + ' col-' + index}
					data-table-position={chunk.get('id') + ',' + rowNum + ',' + index}
				>
					<Text text={textGroupItem.text} groupIndex={rowNum * numCols + index} />
				</td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`


		`<FocusableChunk className="obojobo-draft--chunks--table pad" onDoubleClick={this.onDoubleClick}>
			<div className="container">
				<table
					className="preview-table"
					ref="previewTable"
					key="previewTable"
				>
					<thead key="thead">
						{header}
					</thead>
					<tbody key="tbody">
						{rows}
					</tbody>
				</table>
			</div>
		</FocusableChunk>`


module.exports = Table