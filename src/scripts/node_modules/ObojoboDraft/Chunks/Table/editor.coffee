require './table.scss'

ObojoboDraft = require 'ObojoboDraft'

CreateForm = require './createform'

TextGroupCommandHandler = ObojoboDraft.text.TextGroupCommandHandler
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
TextGroupCursor = ObojoboDraft.text.TextGroupCursor
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk
MockElement = ObojoboDraft.mockDOM.MockElement
MockTextNode = ObojoboDraft.mockDOM.MockTextNode
SimpleMessage = ObojoboDraft.components.modal.SimpleMessage
Question = ObojoboDraft.components.modal.Question
NonEditableChunk = ObojoboDraft.components.NonEditableChunk


class CommandHandler extends TextGroupCommandHandler
	splitText: (sel, chunk, shiftKey) -> null

	deleteSelection: (selection, chunk) ->
		chunk.markDirty()

		sel = new TextGroupSelection selection.chunk, chunk

		chunk.componentContent.textGroup.clearSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

		if sel.position is 'start' or sel.position is 'contains'
			selection.setFutureCaret chunk, { offset: sel.start.offset, groupIndex: sel.start.groupIndex }

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		sel = new TextGroupSelection selection.chunk, chunk
		data = chunk.componentContent

		[start, end] = if not deleteForwards then [sel.start.offset - 1, sel.start.offset] else [sel.start.offset, sel.start.offset + 1]

		sel.start.text.deleteText start, end

		selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }

	acceptAbsorb: -> false
	absorb: -> false
	split: -> false
	transformSelection: -> false

	# navigate: (selection, chunk, oldSelectionDescriptor) ->
	# 	console.log 'navigate', oldSelectionDescriptor.start.data.groupIndex, selection.getSelectionDescriptor().start.data.groupIndex

	# 	currentIndex = selection.getSelectionDescriptor().start.data.groupIndex
	# 	oldIndex     = oldSelectionDescriptor.start.data.groupIndex

	# 	if currentIndex != oldIndex
	# 		selection.setFutureCaret chunk, { offset:0, groupIndex:3 }



Table = React.createClass
	statics:
		consumableElements: ['table']
		commandHandler: new CommandHandler
		insertLabel: ['Table']
		onInsert: (position, referenceChunk, selection, opts, callback) ->
			newChunk = Chunk.create @

			switch position
				when 'before'
					referenceChunk.addBefore newChunk

				when 'after'
					referenceChunk.addAfter newChunk

			newChunk.selectStart selection

			callback()






			# console.log 'onInsert', opts
			# if not opts.rows then opts.rows = ~~prompt('Rows?')
			# if not opts.cols then opts.cols = ~~prompt('Cols?')

			# group = TextGroup.create(opts.rows * opts.cols, {}, opts.rows * opts.cols)

			# newChunk = Chunk.create @, {
			# 	textGroup: group
			# 	position: 'center'
			# 	rows: opts.rows
			# 	cols: opts.cols
			# }

			# selection.setFutureCaret atIndex, { groupIndex:0, offset:0 }

			# callback newChunk

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			textGroup: TextGroup.create(9, {}, 9)
			position: 'center'
			rows: 3
			cols: 3

		cloneNodeData: (data) ->
			textGroup: data.textGroup.clone()
			position: data.position
			rows: data.rows
			cols: data.cols

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			content = descriptor.content

			textGroup: TextGroup.fromDescriptor content.textGroup, parseInt(content.rows, 10) * parseInt(content.cols, 10)
			position: content.position
			rows: content.rows
			cols: content.cols

		getDataDescriptor: (chunk) ->
			data = chunk.componentContent

			textGroup: data.textGroup.toDescriptor()
			position: data.position
			rows: data.rows
			cols: data.cols

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			group = new TextGroup

			maxNumCols = 0
			rows = Array.prototype.slice.call el.getElementsByTagName('tr')
			for row in rows
				cols = Array.prototype.slice.call row.getElementsByTagName('td')
				maxNumCols = Math.max maxNumCols, cols.length
				for col in cols
					group.add StyleableText.createFromElement(col)

			group.maxItems = group.length

			[
				Chunk.create @, {
					textGroup: group
					position: 'center'
					rows: rows.length
					cols: maxNumCols
				}
			]

	addRow: ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		numCols = data.cols

		data.textGroup.maxItems += data.cols

		while numCols
			data.textGroup.add()
			numCols--

		data.rows++

		# @props.selection.setFutureCaret @props.chunk, { offset:0, groupIndex:data.textGroup.length - data.cols - 1 }
		@props.updateFn()

	addCol: ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		numCols = data.cols
		row = data.rows

		data.textGroup.maxItems += data.rows

		while row
			index = row * numCols
			data.textGroup.addAt index
			row--

		data.cols++

		@props.updateFn()

	setDimensions: (rows, cols) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		data.rows = rows
		data.cols = cols
		data.textGroup = TextGroup.create rows * cols, null, rows * cols

		@props.updateFn()

	onCreateDimensionsChange: (rows, cols) ->
		@newTableDimensions =
			rows: rows
			cols: cols

	onModalConfirm: (modal) ->
		modal.close()
		@setDimensions @newTableDimensions.rows, @newTableDimensions.cols
		delete @newTableDimensions

	edit: ->
		data = @props.chunk.componentContent

		@newTableDimensions =
			rows: data.rows
			cols: data.cols

		@props.showModalFn `
			<SimpleMessage confirm={this.onModalConfirm}>
				<CreateForm rows={this.newTableDimensions.rows} cols={this.newTableDimensions.cols} onChange={this.onCreateDimensionsChange} />
			</SimpleMessage>`
		# @props.showModalFn `<Question rejectButtonLabel='No way' confirmButtonLabel='Sure!' cancel={this.hideModal} cancelOnReject>Do you like me?</Question>`
		# if not @props.active
			# @props.activateFn @props.chunk

	onClick: (event) ->
		console.log 'click!'

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate

	componentDidUpdate: ->
		@props.chunk.markUpdated()

	render: ->
		chunk = @props.chunk
		data = chunk.componentContent
		numCols = data.cols

		rows = [0...data.rows].map (rowNum) ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
					`<td key={index}><Text text={textGroupItem.text} groupIndex={rowNum * numCols + index} /></td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`

		`<NonEditableChunk className="obojobo-draft--chunks--table">
			<div>
				<button key="button-1" onClick={this.addRow}>+ Row</button>
				<button key="button-2" onClick={this.addCol}>+ Col</button>
				<button key="button-3" onClick={this.edit}>Edit</button>
			</div>
			<table key="table" contentEditable="true" suppressContentEditableWarning={true} onClick={this.onClick}>
				<tbody key="tbody">
					{rows}
				</tbody>
			</table>
		</NonEditableChunk>`


module.exports = Table