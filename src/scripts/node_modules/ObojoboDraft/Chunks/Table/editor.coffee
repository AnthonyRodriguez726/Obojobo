require './table.scss'

ObojoboDraft = require 'ObojoboDraft'

CreateForm = require './createform'
GridTextGroup = require './gridtextgroup'
TableControls = require './table-controls'

TextGroupCommandHandler = ObojoboDraft.text.TextGroupCommandHandler
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
TextGroupCursor = ObojoboDraft.text.TextGroupCursor
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Text = ObojoboDraft.components.Text
Chunk = ObojoboDraft.models.Chunk
MockElement = ObojoboDraft.mockDOM.MockElement
MockTextNode = ObojoboDraft.mockDOM.MockTextNode
SimpleMessage = ObojoboDraft.components.modal.SimpleMessage
Question = ObojoboDraft.components.modal.Question
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
Keyboard = ObojoboDraft.page.Keyboard


class CommandHandler extends TextGroupCommandHandler
	splitText: (sel, chunk, shiftKey) ->
		return @insertText sel, chunk, "\n"

	deleteSelection: (selection, chunk) ->
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection

		chunk.componentContent.textGroup.clearSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

		if sel.position is 'start' or sel.position is 'contains'
			selection.setFutureCaret chunk, { offset: sel.start.offset, groupIndex: sel.start.groupIndex }

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		sel = new TextGroupSelection chunk, selection
		data = chunk.componentContent

		[start, end] = if not deleteForwards then [sel.start.offset - 1, sel.start.offset] else [sel.start.offset, sel.start.offset + 1]

		sel.start.text.deleteText start, end

		selection.setFutureCaret chunk, { offset: start, groupIndex: sel.start.groupIndex }

	acceptAbsorb: -> false
	absorb: -> false
	split: -> false
	transformSelection: -> false

	# navigate: (selection, chunk, oldSelectionDescriptor) ->
	# 	##console.log 'navigate', oldSelectionDescriptor.start.data.groupIndex, selection.getSelectionDescriptor().start.data.groupIndex

	# 	currentIndex = selection.getSelectionDescriptor().start.data.groupIndex
	# 	oldIndex     = oldSelectionDescriptor.start.data.groupIndex

	# 	if currentIndex != oldIndex
	# 		selection.setFutureCaret chunk, { offset:0, groupIndex:3 }



Table = React.createClass
	statics:
		consumableElements: ['table']
		commandHandler: new CommandHandler
		insertLabel: ['Table']
		onInsert: (position, referenceChunk, selection, opts, callback) ->
			newChunk = Chunk.create @

			switch position
				when 'before'
					referenceChunk.addBefore newChunk

				when 'after'
					referenceChunk.addAfter newChunk

			newChunk.selectStart selection

			callback()






			# ##console.log 'onInsert', opts
			# if not opts.rows then opts.rows = ~~prompt('Rows?')
			# if not opts.cols then opts.cols = ~~prompt('Cols?')

			# group = TextGroup.create(opts.rows * opts.cols, {}, opts.rows * opts.cols)

			# newChunk = Chunk.create @, {
			# 	textGroup: group
			# 	position: 'center'
			# 	rows: opts.rows
			# 	cols: opts.cols
			# }

			# selection.setFutureCaret atIndex, { groupIndex:0, offset:0 }

			# callback newChunk

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			##console.log 'CNND', GridTextGroup.create(3, 3)
			textGroup: GridTextGroup.create(3, 3)
			position: 'center'
			header: true

		cloneNodeData: (data) ->
			textGroup: data.textGroup.clone()
			position: data.position
			header: data.header

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			content = descriptor.content

			gridTextGroup: GridTextGroup.fromDescriptor content.gridTextGroup
			position: content.position
			header: content.header

		getDataDescriptor: (chunk) ->
			data = chunk.componentContent

			gridTextGroup: data.textGroup.toDescriptor()
			position: data.position
			header: data.header

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			null
			# group = new TextGroup

			# maxNumCols = 0
			# rows = Array.prototype.slice.call el.getElementsByTagName('tr')
			# for row in rows
			# 	cols = Array.prototype.slice.call row.getElementsByTagName('td')
			# 	maxNumCols = Math.max maxNumCols, cols.length
			# 	for col in cols
			# 		group.add StyleableText.createFromElement(col)

			# group.maxItems = group.length

			# [
			# 	Chunk.create @, {
			# 		textGroup: group
			# 		position: 'center'
			# 		rows: rows.length
			# 		cols: maxNumCols
			# 	}
			# ]

	getInitialState: ->
		focus:
			row: 0
			col: 0

	addRow: (index) ->
		# console.clear()
		##console.log 'addRow', index
		##console.log @props.chunk.componentContent.textGroup.numRows

		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.addRow index

		@props.chunk.markForUpdate()

		console.log 'addRow setState', index, @state.focus.col
		@preventBlur = true
		@setState {
			focus:
				row: index
				col: @state.focus.col
		}

		##console.log 'addRow2', index
		##console.log @props.chunk.componentContent.textGroup.numRows


		# @props.updateSelectionFn()
		# @props.updateFn()

	addCol: (index) ->
		#console.log '~~~~addcol', __ds().startContainer

		sel = new TextGroupSelection @props.chunk, @props.selection
		#console.log 'sel', sel.type

		# return

		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.addCol index

		# @setState {
		# 	focus:
		# 		row: @state.focus.row
		# 		col: index
		# }

		@props.chunk.markForUpdate()
		# @props.updateSelectionFn()
		# @props.updateFn()

		# @preventBlur = {
		# 	row: @state.focus.row
		# 	col: index
		# }

		# setTimeout (->
		# 	# #console.log 'focus on', @refs.table, @state
		# 	@setState {
		# 		focus:
		# 			row: 0
		# 			col: index
		# 	}
		# # @refs.table.focus()
		# ).bind(@), 1000
		@preventBlur = true
		console.log 'addCol setState', 0, index
		@setState {
			focus:
				row: @state.focus.row
				col: index
		}

		# @forceFocus =
		# 	row: @state.focus.row
		# 	col: index

	removeRow: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		if data.textGroup.numRows is 1
			@props.chunk.revert @props.selection
			@props.updateFn()
			return

		data.textGroup.removeRow index

		@props.chunk.markForUpdate()

		console.log 'removeRow setState', Math.min(Math.max(0, index), data.textGroup.numRows - 1),  @state.focus.col
		@preventBlur = true
		@setState {
			focus:
				row: Math.min(Math.max(0, index), data.textGroup.numRows - 1)
				col: @state.focus.col
		}


		# @props.updateSelectionFn()
		# @props.updateFn()

	removeCol: (index) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.removeCol index

		@props.chunk.markForUpdate()

		console.log 'removeCol setState', @state.focus.row, Math.min(Math.max(0, index), data.textGroup.numCols - 1)
		@preventBlur = true
		@setState {
			focus:
				row: @state.focus.row
				col: Math.min(Math.max(0, index), data.textGroup.numCols - 1)
		}


		# @props.updateSelectionFn()
		# @props.updateFn()

	setDimensions: (rows, cols) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent
		data.textGroup.setDimensions rows, cols

		@props.updateFn()

	onBlur: ->
		# return #@TODO
		# console.clear()
		#console.log '~~~blur', __ds().startContainer, @preventBlur

		@props.chunk.markForUpdate()

		if @preventBlur?
			# delete @preventBlur
			event.preventDefault()
		else

			console.log 'onBlur setState null'
			@setState {
				focus: null
			}

		@props.updateFn()


	updateControls: (event) ->
		console.log 'updateControls', @preventUpdateControls
		if @preventUpdateControls?
			delete @preventUpdateControls
			return
		# return #@TODO
		# return
		#console.log '~~~update controls', __ds().startContainer
		# return
		# if @props.selection?.chunk?.start?.node?
		# 	##console.log 'Table::onMouseUp', @props.selection.chunk.start.chunk.get('index'), ObojoboDraft.components.Text.getOboTextInfo(@props.selection.chunk.start.node)

		# # alert 'was working on a way to get the buttons to show up where i want them to'
		# ##console.log event.target
		@props.updateSelectionFn()

		sel = new TextGroupSelection @props.chunk, @props.selection
		##console.log 'ssel', sel
		if sel.type is 'caret'
			groupIndex = sel.start.groupIndex


			# ti = Text.getOboTextInfo @props.selection.chunk.start.node, 0

			console.log 'updateControls setState', @props.chunk.componentContent.textGroup.getCellPositionForIndex groupIndex
			@setState {
				focus:
					@props.chunk.componentContent.textGroup.getCellPositionForIndex groupIndex
			}

			@props.chunk.markForUpdate()
			@props.updateFn()

	onKeyDown2: (newFocus) ->
		if @props.chunk.componentContent.textGroup.getIndexForCellPosition(newFocus) isnt -1
			@setState { focus: newFocus }
			@props.chunk.markForUpdate()
		else
			@props.chunk.prevSibling().selectEnd @props.selection
			@props.updateFn()

		@skipKeyUp = true
		return false

	onKeyDown: (event) ->
		arrowKeyPressed = false

		switch event.keyCode
			when Keyboard.UP_ARROW
				@onKeyDown2 {
					row: @state.focus.row - 1
					col: @state.focus.col
				}

				arrowKeyPressed = true

			when Keyboard.DOWN_ARROW
				@onKeyDown2 {
					row: @state.focus.row + 1
					col: @state.focus.col
				}

				arrowKeyPressed = true

			when Keyboard.RIGHT_ARROW
				if @state.focus.col is @props.chunk.componentContent.textGroup.numCols - 1
					@onKeyDown2 {
						row: @state.focus.row + 1
						col: 0
					}
				else
					@onKeyDown2 {
						row: @state.focus.row
						col: @state.focus.col + 1
					}

				arrowKeyPressed = true

			when Keyboard.LEFT_ARROW
				if @state.focus.col is 0
					@onKeyDown2 {
						row: @state.focus.row - 1
						col: @props.chunk.componentContent.textGroup.numCols - 1
					}
				else
					@onKeyDown2 {
						row: @state.focus.row
						col: @state.focus.col - 1
					}

				arrowKeyPressed = true

		if arrowKeyPressed
			event.preventDefault()
			event.stopPropagation()
			return false

		true

	onKeyUp: (event) ->
		# return
		# event.preventDefault()
		# return
		if @skipKeyUp
			delete @skipKeyUp
			return

		##console.log 'TABLE ON KEY UP'
		# if @props.chunk.needsUpdate then return true
		@updateControls()
		return true

	shouldComponentUpdate: ->
		@props.chunk.needsUpdate

	componentDidUpdate: ->
		@props.chunk.markUpdated()

		if @preventBlur?
			delete @preventBlur
			# setTimeout (->
			# @preventUpdateControls = true
			# @props.updateSelectionFn()
			# @refs.table.focus()
			# @props.updateFn()
			# @props.updateSelectionFn()
			# sel = new TextGroupSelection @props.chunk, @props.selection
			# @selectCell sel
			# console.clear()
			console.log 'prevent update controls'
			# @updateControls()
			setTimeout (->
				@refs.table.focus()
				# @props.updateSelectionFn()
				@updateControls()
				# @props.updateSelectionFn()
			).bind(@)
			# @props.updateSelectionFn()
			# delete @preventBlur
			# @forceUpdate()

		# sel = new TextGroupSelection @props.chunk, @props.selection
		# # console.clear()
		# console.log sel.type
		# if sel.type isnt 'none'
		# 	@refs.table.focus()

	selectCell: (sel) ->
		chunk = @props.chunk
		data = chunk.componentContent


		#console.log '>>>>>>>>>>>>>>>>>>>Table.Render', sel.type
		if sel.type is 'caret'
			##console.log 'oh cool', @state.focus
			groupIndex = data.textGroup.getIndexForCellPosition @state.focus
			console.log 'groupIndex=======', groupIndex
			#console.log '%%%%%compare', sel.start.groupIndex, groupIndex
			if sel.start.groupIndex isnt groupIndex
				#console.log '%%%%%%%%%%%%%%%%%%%%%%%%%%lets do it!'
				@props.selection.setFutureCaret @props.chunk, { offset:Math.min(sel.start.offset, data.textGroup.get(groupIndex).text.length), groupIndex:groupIndex }
				desc = @props.selection.getFutureDescriptor()
				##console.log 'desc', desc

				# ##console.log 'module', @props, @props.module
				@props.selection.selectFromDescriptor @props.module, desc
		# ##console.log cellPos, (cellPos.col / data.textGroup.numCols * 100) + '%'

	render: ->
		#console.log '___RENDER', @state, __ds().startContainer
		# if @state.focus?.col?
			#console.log @state.focus.col
		chunk = @props.chunk
		data = chunk.componentContent
		numCols = data.textGroup.numCols

		sel = new TextGroupSelection chunk, @props.selection

		@selectCell sel

		if data.header
			row = data.textGroup.items.slice(0, numCols).map (textGroupItem, index) ->
				`<th key={index} className={'cell row-0 col-' + index}><Text text={textGroupItem.text} groupIndex={index} /></th>`

			header = `<tr key="header">
				{ row }
			</tr>`
		else
			header = null

		startIndex = if data.header then 1 else 0
		rows = [startIndex...data.textGroup.numRows].map (rowNum) ->
			row = data.textGroup.items.slice(rowNum * numCols, (rowNum + 1) * numCols).map (textGroupItem, index) ->
				`<td key={index} className={'cell row-' + rowNum + ' col-' + index}><Text text={textGroupItem.text} groupIndex={rowNum * numCols + index} /></td>`

			`<tr key={rowNum}>
				{ row }
			</tr>`


		`<NonEditableChunk className="obojobo-draft--chunks--table pad">
			{
				this.state.focus === null
				?
				<p>null</p>
				:
				<p>{this.state.focus.row}x{this.state.focus.col}</p>
			}

			<div className="container">
				{
					sel.type === 'caret'
					?
					<TableControls
						selection={this.props.selection}
						chunk={this.props.chunk}
						focus={this.state.focus}
						addRow={this.addRow}
						addCol={this.addCol}
						removeRow={this.removeRow}
						removeCol={this.removeCol}
					/>
					:
					null
				}
				<table
					ref="table"
					key="table"
					contentEditable="true"
					suppressContentEditableWarning={true}
					onMouseUp={this.updateControls}
					onKeyDown={this.onKeyDown}
					onKeyUp={this.onKeyUp}
					onFocus={this.updateControls}
					onBlur={this.onBlur}
				>
					<thead key="thead">
						{header}
					</thead>
					<tbody key="tbody">
						{rows}
					</tbody>
				</table>
			</div>
		</NonEditableChunk>`


module.exports = Table