Metadata = require './metadata'
PageCollection = require './pagecollection'
Page = require './page'
API = require 'ObojoboDraft/Common/net/api'

class Module extends Backbone.Model
	urlRoot: "/api/module"
	# idAttribute: "shortId"

	constructor: (@app, id = null) ->
		@id = id
		@metadata = new Metadata()
		@pages = new PageCollection()
		# @chunks = new ChunkCollection()
		# @savedChunks = {}

		@pages.on 'remove', @onPageRemove, @
		@pages.on 'add', @onPageAdd, @
		@pages.on 'reset', @onPagesReset, @

	initIfNeeded: ->
		if @pages.models.length is 0
			@pages.add(new Page())

		for page in @pages.models
			page.initIfNeeded()

	onPageRemove: (model, collection, options) ->
		# @savedChunks[model.get('id')] = model.toJSON()
		model.module = null
		model.markDirty()
		# @deletedChunks.push model
		# @recalcuateIndices()

	onPageAdd: (model, collection, options) ->
		console.log('on page add', arguments)
		model.module = @
		model.set 'draftId', @id

		# @recalcuateIndices()

	onPagesReset: (collection, options) ->
		for page in collection.models
			page.module = @
			page.set 'draftId', @id

		# @recalcuateIndices()

	toJSON: ->
		metadata: @metadata.toJSON()
		pages: @pages.toJSON()

	save: ->
		# console.log('SAVING')

		@saveCount = 0

		for chunk in @chunks.models
			if chunk.dirty
				@saveCount++
				# console.log 'GUNNA SAVE', chunk.modelState.textGroup

				if chunk.isFirst()
					beforeId = null
				else
					beforeId = chunk.prevSibling().id

				chunk.save({
					before_chunk_id: beforeId
				}, {
					success:@onSaved.bind(@)
				})

		# console.log 'GONNA DELETE', @deletedChunks.length
		while @deletedChunks.length > 0
			console.log @deletedChunks.length
			@deletedChunks.pop().destroy()

		@deletedChunks = []

	onSaved: ->
		# console.log 'ON SAVED!', @saveCount
		@saveCount--
		if @saveCount is 0
			# console.log 'UPA DATAA'
			@update()



	fromDescriptor: (descriptor) ->
		@clear()

		newModule = Module.createFromDescriptor @app, descriptor

		@metadata = newModule.metadata
		@pages = newModule.pages

		@markDirty()

	markDirty: ->
		for page in @pages.models
			page.markDirty()

	markForUpdate: ->
		for page in @pages.models
			page.markForUpdate()

	# saveChunk: (chunk) ->
	# 	@savedChunks[chunk.get('id')] = chunk.toJSON()

	# Includes savedChunks @TODO?
	# getChunkById: (id) ->
	# 	console.log '--get chunk by id', id
	# 	chunk = @chunks.get id
	# 	console.log '----found', chunk
	# 	if not chunk?
	# 		console.log '----dig deeper'
	# 		descriptor = @savedChunks[id]
	# 		if descriptor?
	# 			console.log '----BIRTH'
	# 			console.log descriptor
	# 			chunk = new Chunk(descriptor)
	# 			console.log chunk

	# 	chunk


	__print: ->
		# for chunk in @chunks.models
			# console.log chunk.id + ':' + chunk.modelState.textGroup.items.length
		console.log 'CHUNKS:'
		for chunk in @chunks.models
			if chunk.modelState?.textGroup? and chunk.modelState.textGroup.length isnt 0
				for t in chunk.modelState.textGroup.items
					console.log chunk.id + '|' + chunk.get('index') + '|' + chunk.get('type') + ':"' + t.text.value + '"'
				console.log '---'
			else
				console.log chunk.id + '|' + chunk.get('index') + '|' + chunk.get('type') + ':<EMPTY>'
				console.log '---'



Module.createFromDescriptor = (app, descriptor) ->
	m = new Module app, descriptor.id
	# m.metadata = new Metadata descriptor.metadata
	m.metadata = new Metadata()

	pages = []
	for pageDescriptor in descriptor.pages
		pages.push Page.createFromDescriptor(pageDescriptor)

	m.pages.reset pages

	m



module.exports = Module