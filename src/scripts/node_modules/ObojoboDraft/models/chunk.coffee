#"obojobo-draft-document-engine": "git+ssh://git@clu.cdl.ucf.edu:obojobo/obojobo-draft-document-engine.git"

createUUID = require 'ObojoboDraft/util/uuid'

class Chunk extends Backbone.Model
	urlRoot: "/api/chunk"
	sync: (method, model, options) ->
		model.dirty = false
		model.needsUpdate = false

		if method is 'update' or method is 'create'
			options.data = JSON.stringify {chunk: model.toJSON()}
			options.contentType = 'application/json'

		Backbone.sync method, model, options

	constructor: (attrs) ->
		if not attrs.id?
			@new = true
			attrs.id = @createNewLocalId()

		super attrs

		@dirty = false
		@needsUpdate = false
		@editing = false

		if attrs.content
			@componentContent = @getComponent().createNodeDataFromDescriptor(attrs)
		else
			@componentContent = {}

		@on "change", @onChange, @

		@module = null

	url: ->
		if @new? then return @urlRoot
		@urlRoot + '/' + encodeURIComponent(@get('id'))

	save: (attrs, options) ->
		# console.clear()
		console.log 'SAVE TIME'
		if @new?
			@assignNewId()
			options.type = 'post'
			options.success = (->
				if @new then delete @new
				true
			).bind(@)

			console.log options

		super attrs, options

	assignNewId: ->
		@set 'id', @createNewLocalId()

	createNewLocalId: ->
		createUUID()

	onChange: (model, options) ->
		if model.get('index') isnt model.previous('index')
			@dirty = true
			@needsUpdate = true

	defaults: ->
		type: 'none'
		content: null
		contentType: 'json'
		derivedFrom: null
		index: null
		draftId: null

	isOrphan: ->
		not @collection?

	addChunkBefore: (sibling) ->
		return if @isOrphan()

		collection = @collection

		if collection.contains sibling
			collection.remove sibling

		collection.add sibling, { at:@get('index') }

	addChunkAfter: (sibling) ->
		return if @isOrphan()

		collection = @collection

		if collection.contains sibling
			collection.remove sibling

		collection.add sibling, { at:@get('index') + 1 }

	moveTo: (index) ->
		return if @get('index') is index

		refChunk = @collection.at index

		if index < @get('index')
			refChunk.addChunkBefore @
		else
			refChunk.addChunkAfter @

	moveToTop: ->
		@moveTo 0

	moveToBottom: ->
		@moveTo @collection.length - 1

	prevSibling: ->
		return null if @isOrphan() or @isFirst()
		@collection.at @get('index') - 1

	nextSibling: ->
		return null if @isOrphan() or @isLast()
		@collection.at @get('index') + 1

	isFirst: ->
		return false if @isOrphan()
		@get('index') is 0

	isLast: ->
		return false if @isOrphan()
		@get('index') is @collection.length - 1

	isBefore: (otherChunk) ->
		return false if @isOrphan()
		@get('index') < otherChunk.get('index')

	isAfter: (otherChunk) ->
		return false if @isOrphan()
		@get('index') > otherChunk.get('index')

	remove: ->
		if not @isOrphan() then @collection.remove @

	replaceWith: (newChunk) ->
		return if @isOrphan() or newChunk is @

		# index = @get('index')
		# collection = @collection
		# collection.remove @
		# collection.add newChunk, { at:index }

		@addChunkBefore newChunk
		@remove()

	getComponent: ->
		OBO.componentClassMap.getClassForType @get('type')

	callCommandFn: (fn, content) ->
		componentClass = @getComponent()
		selection = null
		if @module?
			selection = @module.app.state.selection
		if not componentClass.getCommandHandler? then return null
		commandHandler = componentClass.getCommandHandler @, selection
		if not commandHandler?[fn] then return null
		commandHandler[fn].apply commandHandler, [selection, @].concat(content)

	callSelectionFn: (fn, content) ->
		componentClass = @getComponent()
		selection = null
		if @module?
			selection = @module.app.state.selection
		selectionHandler = componentClass.getSelectionHandler @, selection
		if not selectionHandler?[fn] then return null
		selectionHandler[fn].apply selectionHandler, [selection, @].concat(content)

	getDomEl: ->
		# document.body.querySelector ".component[data-id='#{@get('id')}']"
		document.body.querySelector ".component[data-component-index='#{@get('index')}']"

	clone: (cloneId = false) ->
		clone = new @constructor {
			type: @get('type')
		}
		clone.componentContent = @getComponent().cloneNodeData @componentContent

		if cloneId
			clone.set 'id', @get('id')

		clone

	markDirty: ->
		@dirty = true
		@needsUpdate = true

	markForUpdate: ->
		@needsUpdate = true

	markUpdated: ->
		@needsUpdate = false

	isEditing: ->
		@module.app.state.editingChunk is @

	toJSON: ->
		contentJSON = @getComponent().getDataDescriptor @

		json =
			type: @get 'type'
			content: contentJSON
			contentType: @get 'contentType'
			derivedFrom: @get 'derivedFrom'
			index: @get('index')
			id: @get 'id'
			draftId: @get 'draftId'

		json

	revert: ->
		newChunk = Chunk.create()

		index = @get('index')
		id = @get('id')

		@clear()

		for attrName, attr of newChunk.attributes
			@set attrName, attr

		@set 'index', index
		@set 'id', id

		@componentContent = newChunk.componentContent

		@

	getCaretEdge: -> @callCommandFn 'getCaretEdge'
	isEmpty: -> @callCommandFn 'isEmpty'
	canRemoveSibling: (sibling) -> @callCommandFn 'canRemoveSibling', [sibling]
	insertText: (textToInsert, stylesToApply, stylesToRemove) -> @callCommandFn 'insertText', [textToInsert, stylesToApply, stylesToRemove]
	deleteText: (deleteForwards) -> @callCommandFn 'deleteText', [deleteForwards]
	onEnter: (shiftKey) -> @callCommandFn 'onEnter', [shiftKey]
	splitText: -> @callCommandFn 'splitText'
	deleteSelection: -> @callCommandFn 'deleteSelection'
	styleSelection: (styleType, styleData) -> @callCommandFn 'styleSelection', [styleType, styleData]
	unstyleSelection: (styleType, styleData) -> @callCommandFn 'unstyleSelection', [styleType, styleData]
	getSelectionStyles: -> @callCommandFn 'getSelectionStyles'
	canMergeWith: (otherChunk) -> @callCommandFn 'canMergeWith', [otherChunk]
	merge: (digestedChunk, mergeText) -> @callCommandFn 'merge', [digestedChunk, mergeText]
	indent: (decreaseIndent) -> @callCommandFn 'indent', [decreaseIndent]
	onTab: (untab) -> @callCommandFn 'onTab', [untab]
	acceptAbsorb: (consumerChunk) -> @callCommandFn 'acceptAbsorb', [consumerChunk]
	absorb: (digestedChunk) -> @callCommandFn 'absorb', [digestedChunk]
	replaceSelection: -> @callCommandFn 'replaceSelection'
	split: -> @callCommandFn 'split'
	getDOMStateBeforeInput: -> @callCommandFn 'getDOMStateBeforeInput'
	getDOMModificationAfterInput: (domStateBefore) -> @callCommandFn 'getDOMModificationAfterInput', [domStateBefore]
	applyDOMModification: (domModifications) -> @callCommandFn 'applyDOMModification', [domModifications]
	onSelectAll: -> @callCommandFn 'onSelectAll'
	getTextMenuCommands: -> @callCommandFn 'getTextMenuCommands'
	paste: (text, html, chunks) -> @callCommandFn 'paste', [text, html, chunks]

	getCopyOfSelection: (cloneId) -> @callSelectionFn 'getCopyOfSelection', [cloneId]
	selectStart: (asRange) -> @callSelectionFn 'selectStart', [asRange]
	selectEnd: (asRange) -> @callSelectionFn 'selectEnd', [asRange]
	selectAll: -> @callSelectionFn 'selectAll'
	getVirtualSelectionStartData: -> @callSelectionFn 'getVirtualSelectionStartData'
	getVirtualSelectionEndData: -> @callSelectionFn 'getVirtualSelectionEndData'
	getDOMSelectionStart: -> @callSelectionFn 'getDOMSelectionStart'
	getDOMSelectionEnd: -> @callSelectionFn 'getDOMSelectionEnd'
	areCursorsEquivalent: (thisCursorData, otherCursorData) -> @callSelectionFn 'areCursorsEquivalent', [thisCursorData, otherCursorData]
	highlightSelection: (comment) -> @callSelectionFn 'highlightSelection', [comment]

Chunk.create = (typeOrClass = null, content = null) ->
	try
		if not typeOrClass?
			componentClass = OBO.componentClassMap.defaultClass
			type = OBO.componentClassMap.getTypeOfClass componentClass
		else if typeof typeOrClass is 'string'
			componentClass = OBO.componentClassMap.getClassForType typeOrClass
			type = typeOrClass
		else
			componentClass = typeOrClass
			type = OBO.componentClassMap.getTypeOfClass typeOrClass

		content ?= componentClass.createNewNodeData()

		chunk = new Chunk {
			type: type
		}
		chunk.componentContent = content
	catch e
		throw e
		componentClass = OBO.componentClassMap.errorClass
		chunk = new Chunk(componentClass)
		# type = ComponentClassMap.getTypeOfClass componentClass

	chunk

module.exports = Chunk