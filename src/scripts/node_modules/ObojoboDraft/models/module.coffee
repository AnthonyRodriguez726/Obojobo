Metadata = require './metadata'
ChunkCollection = require './chunkcollection'
Chunk = require './chunk'

class Module extends Backbone.Model
	urlRoot: "/api/module"
	# idAttribute: "shortId"

	constructor: (id = null) ->
		@id = id
		@metadata = new Metadata()
		@chunks = new ChunkCollection()
		# @savedChunks = {}
		@deletedChunks = []

		@chunks.on 'remove', @onChunkRemove, @
		@chunks.on 'add', @onChunkAdd, @
		@chunks.on 'reset', @onChunksReset, @

	onChunkRemove: (model, collection, options) ->
		# @savedChunks[model.get('id')] = model.toJSON()
		@deletedChunks.push model
		@recalcuateIndices()

	onChunkAdd: (model, collection, options) ->
		model.set 'draftId', @id

		@recalcuateIndices()

	onChunksReset: (collection, options) ->
		for chunk in collection.models
			chunk.set 'draftId', @id

		@recalcuateIndices()

	recalcuateIndices: ->
		for chunk, i in @chunks.models
			chunk.set 'index', i

	toJSON: ->
		metadata: @metadata.toJSON()
		chunks: @chunks.toJSON()

	save: ->
		# console.log('SAVING')

		@saveCount = 0

		for chunk in @chunks.models
			if chunk.dirty
				@saveCount++
				# console.log 'GUNNA SAVE', chunk.componentContent.textGroup

				if chunk.isFirst()
					beforeId = null
				else
					beforeId = chunk.prevSibling().id

				chunk.save({
					before_chunk_id: beforeId
				}, {
					success:@onSaved.bind(@)
				})

		# console.log 'GONNA DELETE', @deletedChunks.length
		while @deletedChunks.length > 0
			console.log @deletedChunks.length
			@deletedChunks.pop().destroy()

		@deletedChunks = []

	onSaved: ->
		# console.log 'ON SAVED!', @saveCount
		@saveCount--
		if @saveCount is 0
			# console.log 'UPA DATAA'
			@update()

	markDirty: ->
		for chunk in @chunks.models
			chunk.markDirty()

	markForUpdate: ->
		for chunk in @chunks.models
			chunk.markForUpdate()

	fromDescriptor: (descriptor) ->
		@clear()

		newModule = Module.createFromDescriptor descriptor

		@metadata = newModule.metadata
		@chunks = newModule.chunks

		@markDirty()

	# saveChunk: (chunk) ->
	# 	@savedChunks[chunk.get('id')] = chunk.toJSON()

	# Includes savedChunks @TODO?
	# getChunkById: (id) ->
	# 	console.log '--get chunk by id', id
	# 	chunk = @chunks.get id
	# 	console.log '----found', chunk
	# 	if not chunk?
	# 		console.log '----dig deeper'
	# 		descriptor = @savedChunks[id]
	# 		if descriptor?
	# 			console.log '----BIRTH'
	# 			console.log descriptor
	# 			chunk = new Chunk(descriptor)
	# 			console.log chunk

	# 	chunk


	__print: ->
		# for chunk in @chunks.models
			# console.log chunk.id + ':' + chunk.componentContent.textGroup.items.length
		console.log 'CHUNKS:'
		for chunk in @chunks.models
			console.log 'chunk be', chunk
			if chunk.componentContent?.textGroup? and chunk.componentContent.textGroup.length isnt 0
				console.log chunk.id + ':"' + chunk.componentContent.textGroup.get(0).text.value + '"'
			else
				console.log chunk.id + ':<EMPTY>'

		console.log ''
		console.log 'SAVED CHUNKS:'
		for id, chunk of @savedChunks
			if chunk.content.textGroup? and chunk.content.textGroup.length isnt 0
				console.log chunk.id + ':"' + chunk.content.textGroup[0].text.value + '"'
			else
				console.log chunk.id + ':<EMPTY>'



Module.createFromDescriptor = (descriptor) ->
	m = new Module descriptor.id
	# m.metadata = new Metadata descriptor.metadata
	m.metadata = new Metadata()

	chunks = []
	for chunkDescriptor in descriptor.chunks
		# chunks.push Chunk.createFromDescriptor(chunkDescriptor)
		# console.log chunkDescriptor
		try
			chunkDescriptor.draftId = descriptor.id
			console.log 'new chunk', chunkDescriptor
			chunks.push new Chunk(chunkDescriptor)
		catch e
			console.log 'ERROR', e

	if chunks.length is 0
		chunks.push Chunk.create()

	m.chunks.reset chunks

	m



module.exports = Module