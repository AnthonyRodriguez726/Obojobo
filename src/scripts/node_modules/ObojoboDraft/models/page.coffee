ChunkCollection = require './chunkcollection'
Chunk = require './chunk'

class Page extends Backbone.Model
	constructor: (attrs) ->
		super(attrs)

		@chunks = new ChunkCollection(@app)
		@deletedChunks = []

		@chunks.on 'remove', @onChunkRemove, @
		@chunks.on 'add', @onChunkAdd, @
		@chunks.on 'reset', @onChunksReset, @

	onChunkRemove: (model, collection, options) ->
		# @savedChunks[model.get('id')] = model.toJSON()
		model.page = null
		model.markDirty()
		@deletedChunks.push model
		@recalcuateIndices()

	onChunkAdd: (model, collection, options) ->
		model.page = @
		model.set 'draftId', @draftId

		@recalcuateIndices()

	onChunksReset: (collection, options) ->
		for chunk in collection.models
			chunk.page = @
			chunk.set 'draftId', @draftId

		@recalcuateIndices()

	recalcuateIndices: ->
		for chunk, i in @chunks.models
			chunk.set 'index', i

	moveChunk: (chunk, newIndex) ->
		@chunks.models.splice(chunk.get('index'), 1)[0]

		@chunks.models.splice newIndex, 0, chunk

		@recalcuateIndices()

		console.log '@TODO - Need to move chunk on server!'
		return

		# console.clear()
		API.chunk.move chunk, chunk.prevSibling(), ((event) ->
			# console.clear()
			console.log event

			for chunk in @chunks.models
				console.log chunk.get('id')

			console.log JSON.parse(event.target.responseText)
		).bind(@)

	toJSON: ->
		chunks: @chunks.toJSON()

	markDirty: ->
		for chunk in @chunks.models
			chunk.markDirty()

	markForUpdate: ->
		for chunk in @chunks.models
			chunk.markForUpdate()



Page.createFromDescriptor = (descriptor) ->
	console.log 'PAGE CREATE FROM descriptor', descriptor
	p = new Page descriptor
	# m.metadata = new Metadata de

	chunks = []
	for chunkDescriptor in descriptor.chunks
		try
			chunkDescriptor.draftId = descriptor.id
			chunks.push new Chunk(chunkDescriptor)
		catch e
			console.error 'ERROR', e
			chunks.push Chunk.create(OBO.componentClassMap.errorClass)


	if chunks.length is 0
		chunks.push Chunk.create()

	p.chunks.reset chunks

	p


module.exports = Page