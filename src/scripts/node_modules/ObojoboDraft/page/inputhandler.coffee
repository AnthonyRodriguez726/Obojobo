ChunkUtil = require './chunkutil'
Keyboard = require './keyboard'

module.exports = class InputHandler
	constructor: ->

	send: (fn, chunkOrChunks, data) ->
		ChunkUtil.send fn, chunkOrChunks, @props.selection, data

	onKeyDown: (event, selection, updateFn, updateSelectionFn, styleBrush) ->
		metaOrCtrlKeyHeld = event.metaKey or event.ctrlKey

		switch event.keyCode
			# DELETE
			when Keyboard.BACKSPACE, Keyboard.DELETE
				event.preventDefault()
				if selection.chunk.type is 'caret'
					caretEdge = ChunkUtil.send 'getCaretEdge', selection.chunk.start.chunk, selection
					deleteForwards = event.keyCode is Keyboard.DELETE
					chunk = selection.chunk.start.chunk
					prev = chunk.prevSibling()
					next = chunk.nextSibling()

					deleteSuccessful = ChunkUtil.send 'deleteText', chunk, selection, [deleteForwards]

					if not deleteSuccessful
						switch
							# If cursor is at the start and this is a backspace
							when (caretEdge is 'start' or caretEdge is 'startAndEnd') and not deleteForwards and prev?
								# If both chunks agree to be merged with each other
								if ChunkUtil.send('canMergeWith', chunk, selection, [prev]) and ChunkUtil.send('canMergeWith', prev, selection, [chunk])
									#... then previousSibling will merge with this chunk
									ChunkUtil.send 'merge', prev, selection, [chunk]
								else if ChunkUtil.send('canRemoveSibling', chunk, selection, [prev])
									#... else previousSibling simply gets deleted
									prev.remove()

							# If cursor is at the end and this is a foward delete
							when (caretEdge is 'end' or caretEdge is 'startAndEnd') and deleteForwards and next?
								# If both chunks agree to be merged with each other
								if ChunkUtil.send('canMergeWith', chunk, selection, [next]) and ChunkUtil.send('canMergeWith', next, selection, [chunk])
									#... then this chunk will merge with nextSibling
									ChunkUtil.send 'merge', chunk, selection, [next]
								else if ChunkUtil.send('canRemoveSibling', chunk, selection, [next])
									#... else nextSibling simply gets deleted
									next.remove()
				else
					ChunkUtil.deleteSelection selection

				updateFn()
				return

			# INDENT
			when Keyboard.TAB
				# updateFn()
				# return true
				event.preventDefault()

				# If more than one chunk is selected...
				if selection.chunk.type is 'chunkSpan'
					# ...indent all of them
					ChunkUtil.send 'indent', selection.chunk.all, selection, [event.shiftKey]
					updateFn()
					return

				# If tabbing at the start of the text...
				caretEdge = ChunkUtil.send 'getCaretEdge', selection.chunk.start.chunk, selection
				if caretEdge is 'start' or caretEdge is 'startAndEnd'
					# ...indent
					ChunkUtil.send 'indent', selection.chunk.start.chunk, selection, [event.shiftKey]
					updateFn()
					return

				# Otherwise, let the chunk figure out what to do
				ChunkUtil.send 'onTab', selection.chunk.start.chunk, selection, [event.shiftKey]
				updateFn()

			# NEW LINE
			when Keyboard.ENTER
				event.preventDefault()
				ChunkUtil.deleteSelection selection
				ChunkUtil.send 'splitText', selection.chunk.start.chunk, selection, [event.shiftKey]
				updateFn()
				return

			#@TODO - are these the only ways to change the cursor with the keyboard?
			when Keyboard.LEFT_ARROW, Keyboard.RIGHT_ARROW, Keyboard.UP_ARROW, Keyboard.DOWN_ARROW
				# @history.add null, selection.getSelectionDescriptor()

				if not styleBrush.isClean
					styleBrush.clean()
					updateFn()
					return

				# @prevSel = selection.getSelectionDescriptor()

		if metaOrCtrlKeyHeld
			switch event.keyCode
				# We want to capture ctrl/cmd+b and other such events
				# to stop the browsers default execCommand behavior.
				when 66 #b
					event.preventDefault()

					ChunkUtil.activateStyle 'b', selection, styleBrush

					updateSelectionFn()
					updateFn()
					return

				when 73 #i
					event.preventDefault()

					ChunkUtil.activateStyle 'i', selection, styleBrush

					updateSelectionFn()
					updateFn()
					return

				when 65 #a
					if selection.chunk.type isnt 'chunkSpan'
						if ChunkUtil.send 'selectAll', selection.chunk.start.chunk, selection
							event.preventDefault()
							# updateSelectionFn()
							updateFn()
							return