ObjectAssign = require 'object-assign'

ChunkStyleList = require './chunkstylelist'
StyleRange = require './stylerange'
StyleType = require './styletype'
HtmlUtil = require 'ObojoboDraft/util/htmlutil'


# ceiling Infinity end values to the length
trimStyleRange = (styleRange, maxLength) ->
	styleRange.end = Math.min styleRange.end, maxLength
	styleRange


class StyleableText
	constructor: (text = '') ->
		@init()
		@insertText(0, text)

	init: ->
		@styleList = new ChunkStyleList
		@value = ''

	clone: ->
		clone = new StyleableText
		clone.value = @value
		clone.styleList = @styleList.clone()

		clone

	getExportedObject: ->
		value: @value
		styleList: @styleList.getExportedObject()

	setText: (text) ->
		@init()
		@insertText 0, text

	replaceText: (from, to, text) ->
		return @deleteText(from, to) if not text? or text.length is 0

		# Goal: The replaced text should adopt the styles of where the range starts.
		# The following combination of commands achieves what we want
		@insertText from + 1, text
		@normalizeStyles()
		@deleteText from, from + 1
		@normalizeStyles()
		@deleteText from + text.length, to + text.length - 1
		@normalizeStyles()

	appendText: (text) ->
		@insertText @length, text

	insertText: (atIndex, text) ->
		insertLength = text.length

		for range in @styleList.styles
			switch range.compareToRange atIndex
				when StyleRange.CONTAINS
					range.end += insertLength

				when StyleRange.AFTER
					range.start += insertLength
					range.end += insertLength

		@value = @value.substring(0, atIndex) + text + @value.substring(atIndex)

		@normalizeStyles()

	deleteText: (from = -1, to = Infinity) ->
		return if from > to

		from = Math.max 0, from
		to = Math.min to, @value.length

		deleteLength = to - from

		for range in @styleList.styles
			switch range.compareToRange from, to
				when StyleRange.CONTAINS
					range.end -= deleteLength

				when StyleRange.INSIDE_LEFT
					range.end = from

				when StyleRange.ENSCAPSULATED_BY
					range.invalidate()

				when StyleRange.INSIDE_RIGHT
					range.start = from
					range.end -= deleteLength

				when StyleRange.AFTER
					range.start -= deleteLength
					range.end -= deleteLength

		@value = @value.substring(0, from) + @value.substring(to)

		@normalizeStyles()

	toggleStyleText: (styleType, from = 0, to = @length, styleData) ->
		styleRange = trimStyleRange new StyleRange(from, to, styleType, styleData), @value.length
		if @styleList.rangeHasStyle from, Math.min(to, @value.length), styleType
			@styleList.remove styleRange
		else
			@styleList.add styleRange

		@normalizeStyles()

	styleText: (styleType, from = 0, to = @length, styleData) ->
		range = new StyleRange(from, to, styleType, styleData)

		styleRange = trimStyleRange range, @value.length
		@styleList.add styleRange

		@normalizeStyles()

	unstyleText: (styleType, from = 0, to = @length) ->
		styleRange = trimStyleRange new StyleRange(from, to, styleType), @value.length
		@styleList.remove styleRange
		@normalizeStyles()

	getStyles: (from, to) ->
		@styleList.getStylesInRange(from, to)

	split: (atIndex) ->
		return null if isNaN(atIndex)

		splitAtEnd = atIndex is @value.length

		sibling = @clone()

		@deleteText atIndex, @value.length

		sibling.deleteText 0, atIndex

		# special case - if splitting at the end of a line
		# we want to shove the last character styles as
		# initial styles into the new sibling.
		if splitAtEnd
			lastCharStyles = @styleList.getStylesInRange @value.length - 1, @value.length
			for style of lastCharStyles
				sibling.styleText style, 0, 0 #@TODO - what about data?

		sibling

	normalizeStyles: ->
		@styleList.normalize()

	merge: (otherText, atIndex = null) ->
		atIndex ?= @value.length

		insertLength = otherText.value.length

		for range in @styleList.styles
			switch range.compareToRange atIndex
				when StyleRange.AFTER
					range.start += insertLength
					range.end += insertLength

		@value = @value.substring(0, atIndex) + otherText.value + @value.substring(atIndex)

		@styleList.normalize()

		for range in otherText.styleList.styles
			curRange = range.clone()
			curRange.start += atIndex
			curRange.end   += atIndex

			@styleList.add curRange

		@styleList.normalize()

	__debug_print: ->
		console.log '   |          |' + @value + ' |'
		fill = ''
		for i in [0..@value.length + 10]
			fill += ' '

		j = 0
		for style in @styleList.styles
			s1 = (style.type + '          ').substr(0, 10) + '|'
			s2 = ''
			for i in [0...style.start]
				s2 += '·'
			s2 += '<'
			for i in [style.start+1...style.end]
				s2 += '='
			s2 += '>'
			for i in [style.end+1...fill.length]
				s2 += '·'
			console.log (j + '   ').substr(0, 3) + '|' + (s1 + s2 + fill).substr(0, fill.length + 1) + '|' + style.start + ',' + style.end + '|' + JSON.stringify(style.data) # + '|' + style.__debug
			j++


Object.defineProperties StyleableText.prototype,
	"length":
		get: -> @value.length


StyleableText.createFromObject = (o) ->
	st = new StyleableText
	st.styleList = ChunkStyleList.createFromObject o.styleList
	st.value = o.value

	st


StyleableText.getStylesOfElement = (el) ->
	# console.warn 'MOVE THIS SOMEWHERE ELSE!!!!'

	return [] if el.nodeType isnt Node.ELEMENT_NODE

	styles = []

	computedStyle = window.getComputedStyle el

	# debugger;

	# console.log '___________', el, computedStyle, computedStyle.getPropertyValue('font-weight')

	switch computedStyle.getPropertyValue 'font-weight'
		when "bold", "bolder", "700", "800", "900" then styles.push { type:StyleType.BOLD }

	switch computedStyle.getPropertyValue 'text-decoration'
		when "line-through" then styles.push { type:StyleType.STRIKETHROUGH }

	switch computedStyle.getPropertyValue 'font-style'
		when "italic" then styles.push { type:StyleType.ITALIC }

	switch computedStyle.getPropertyValue('font-family').toLowerCase()
		when "monospace" then styles.push { type:StyleType.MONOSPACE }

	# switch computedStyle.getPropertyValue('vertical-align') + "|" + computedStyle.getPropertyValue('font-size')
	# 	when "super|smaller" then styles.push { type:StyleType.SUPERSCRIPT }
	# 	when "sub|smaller"   then styles.push { type:StyleType.SUBSCRIPT }

	switch el.tagName.toLowerCase()
		#when 'b'               then styles.push { type:StyleType.BOLD }
		when 'a'               then styles.push { type:StyleType.LINK, data:el.getAttribute('href') }
		when 'q'               then styles.push { type:StyleType.QUOTE, data:el.getAttribute('cite') }
		#@TODO:
		# when 'abbr', 'acronym' then styles.push { type:StyleType.COMMENT, data:el.getAttribute('title') }
		when 'sup'             then styles.push { type:StyleType.SUPERSCRIPT, data:1 }
		when 'sub'             then styles.push { type:StyleType.SUPERSCRIPT, data:-1 }
		# @TODO:
		# when 'span'
		# 	if el.classList.contains('comment') and el.hasAttribute('data-additional')
		# 		styles.push { type:StyleType.COMMENT, data:el.getAttribute('data-additional') }

	styles

StyleableText.createFromElement = (node) ->
	if not node?
		return new StyleableText()

	# console.warn '@TODO - MOVE THIS method somewhere else!'

	if not arguments[1]?
		state = {
			curText: new StyleableText
			texts: []
		}
		StyleableText.createFromElement node, state

		state.texts.push state.curText
		state.curText.styleList.normalize()

		return state.texts

	state = arguments[1]

	switch node.nodeType
		when Node.TEXT_NODE
			state.curText.value += node.nodeValue
		when Node.ELEMENT_NODE
			if state.curText.length > 0 and not HtmlUtil.isElementInline(node)
				state.texts.push state.curText
				state.curText.styleList.normalize()

				state.curText = new StyleableText()

			styles = StyleableText.getStylesOfElement node
			ranges = []
			for style in styles
				styleRange = new StyleRange state.curText.value.length, Infinity, style.type, style.data
				ranges.push styleRange

			for childNode in node.childNodes
				StyleableText.createFromElement childNode, state

			for range in ranges
				range.end = state.curText.value.length
				state.curText.styleList.add range


# @TODO
window.__st = StyleableText

module.exports = StyleableText