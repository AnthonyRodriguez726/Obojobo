ObjectAssign = require 'object-assign'
StyleableText = require './styleabletext'

createData = (data, template) ->
	clone = ObjectAssign {}, data

	for key of clone
		if not template[key]?
			delete clone[key]

	for key of template
		if not clone[key]?
			if typeof template[key] is 'object'
				clone[key] = ObjectAssign {}, template[key]
			else
				clone[key] = template[key]

	clone

defaultCloneFn = (data) ->
	ObjectAssign {}, data

defaultMergeFn = (consumer, digested) ->
	ObjectAssign consumer, digested


class TextGroupItem
	constructor: (@text = new StyleableText(), @data = {}, @parent = null) ->

	clone: (cloneDataFn = defaultCloneFn) ->
		new TextGroupItem @text.clone(), cloneDataFn(@data), null

Object.defineProperties TextGroupItem.prototype, {
	"index": "get": ->
		if @parent is null then return -1
		@parent.indexOf @
}

getItemsArray = (itemOrItems) ->
	if itemOrItems instanceof TextGroupItem
		[itemOrItems]
	else
		itemOrItems

addChildToGroup = (itemOrItems, group, atIndex = null) ->
	items = getItemsArray itemOrItems

	if atIndex is null
		group.items = group.items.concat items
	else
		group.items = group.items.slice(0, atIndex).concat(items).concat(group.items.slice(atIndex))

	for item in items
		item.parent = group

removeChildFromGroup = (itemOrItems, group) ->
	console.log 'removeChildFromGroup', itemOrItems, group
	removedItems = []
	items = getItemsArray itemOrItems

	for item in items
		removed = group.items.splice(item.index, 1)[0]
		removed.parent = null
		removedItems.push removed

	removedItems

removeAllChildrenFromGroup = (group) ->
	for item in group.items
		item.parent = null

	group.items = []


class TextGroup
	constructor: (@maxItems = Infinity, dataTemplate = {}, initialItems = []) ->
		@items = []
		addChildToGroup initialItems, @
		@dataTemplate = Object.freeze ObjectAssign({}, dataTemplate)

	clear: ->
		removeAllChildrenFromGroup @

	indexOf: (item) ->
		@items.indexOf(item)

	init: (numItems = 1) ->
		@clear()

		while numItems--
			@add()

		@

	fill: ->
		return if @maxItems is Infinity

		while not @isFull
			@add()

		@

	add: (text, data) ->
		return @ if @isFull

		addChildToGroup new TextGroupItem(text, createData(data, @dataTemplate)), @

		@

	addAt: (index, text, data) ->
		return @ if @isFull

		addChildToGroup new TextGroupItem(text, createData(data, @dataTemplate)), @, index

		@

	addGroup: (group, cloneDataFn = defaultCloneFn) ->
		itemsToAdd = []
		for item in group.items
			clone = item.clone cloneDataFn
			itemsToAdd.push new TextGroupItem(clone.text, createData(clone.data, @dataTemplate))

		addChildToGroup itemsToAdd, @

		@

	get: (index) ->
		@items[index]

	remove: (index) ->
		removeChildFromGroup(@items[index], @)[0]

	clone: (cloneDataFn = defaultCloneFn) ->
		clonedItems = []

		for item in @items
			clonedItems.push item.clone(cloneDataFn)

		new TextGroup @maxItems, @dataTemplate, clonedItems

	toDescriptor: (dataToDescriptorFn = defaultCloneFn) ->
		desc = []

		for item in @items
			desc.push { text:item.text.getExportedObject(), data:dataToDescriptorFn(item.data) }

		desc

	toSlice: (from, to = Infinity) ->
		console.log 'from', from, 'to', to
		@__debug_print()
		console.log 'remove a child'
		removeChildFromGroup @items.slice(0, from), @
		@__debug_print()
		console.log 'remove final child'
		removeChildFromGroup @items.slice(to), @
		console.log 'RESULT'
		@__debug_print()
		@

	split: (index) ->
		siblingItems = @items[index+1..]
		@items = @items[0..index]

		new TextGroup @maxItems, @dataTemplate, siblingItems

	splitText: (index, groupIndex, cloneDataFn = defaultCloneFn) ->
		item = @items[index]

		newItem = new TextGroupItem item.text.split(groupIndex), cloneDataFn(item.data)

		addChildToGroup newItem, @, index + 1

		newItem

	merge: (index, mergeDataFn = defaultMergeFn) ->
		digestedItem = @items.splice(index + 1, 1)[0]
		consumerItem = @items[index]

		consumerItem.data = createData(mergeDataFn(consumerItem.data, digestedItem.data), @dataTemplate)

		consumerItem.text.merge digestedItem.text
		@

	deleteSpan: (startIndex, startTextIndex, endIndex, endTextIndex, mergeFn = defaultMergeFn) ->
		startItem = @items[startIndex]
		endItem   = @items[endIndex]
		startText = startItem.text
		endText   = endItem.text

		if startText is endText
			startText.deleteText startTextIndex, endTextIndex
			return

		startText.deleteText startTextIndex, startText.length
		endText.deleteText 0, endTextIndex

		newItems = []
		for item, i in @items
			if i < startIndex or i > endIndex
				newItems.push item
			else if i is startIndex
				newItems.push startItem
			else if i is endIndex
				newItems.push endItem

		removeAllChildrenFromGroup @
		addChildToGroup newItems, @
		@merge startIndex

	clearSpan: (startIndex, startTextIndex, endIndex, endTextIndex) ->
		startItem = @items[startIndex]
		endItem   = @items[endIndex]
		startText = startItem.text
		endText   = endItem.text

		if startText is endText
			startText.deleteText startTextIndex, endTextIndex
			return

		startText.deleteText startTextIndex, startText.length
		endText.deleteText 0, endTextIndex

		for item, i in @items
			if i > startIndex and i < endIndex
				item.text.init()

		@

	styleText: (startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData) ->
		@applyStyleFunction 'styleText', arguments

	unstyleText: (startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData) ->
		@applyStyleFunction 'unstyleText', arguments

	#@TODO - This won't work correctly
	toggleStyleText: (startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData) ->
		@applyStyleFunction 'toggleStyleText', arguments

	applyStyleFunction: (fn, args) ->
		[startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData] = args

		# console.log 'APPLY STYLE FUNCTION', startIndex, startTextIndex, endIndex, endTextIndex, styleType, styleData

		startItem = @items[startIndex]
		endItem   = @items[endIndex]
		startText = startItem.text
		endText   = endItem.text

		if startText is endText
			startText[fn] startTextIndex, endTextIndex, styleType, styleData
			return


		foundStartText = false
		for item in @items
			if item.text is startText
				item.text[fn] startTextIndex, startText.length, styleType, styleData
				foundStartText = true
			else if item.text is endText
				item.text[fn] 0, endTextIndex, styleType, styleData
				break
			else if foundStartText
				item.text[fn] 0, item.text.length, styleType, styleData

		@

	getStyles: (startIndex, startTextIndex, endIndex, endTextIndex) ->
		startItem = @items[startIndex]
		endItem   = @items[endIndex]

		if not startItem? or not endItem? then return {}

		startText = startItem.text
		endText   = endItem.text

		if not startText? or not endText? then return {}

		if startText is endText
			return startText.getStyles startTextIndex, endTextIndex

		numTexts = 0
		allStyles = {}
		foundStartText = false
		for item in @items
			styles = {}

			if item.text is startText
				numTexts++
				styles = item.text.getStyles startTextIndex, startText.length
				foundStartText = true
			else if item.text is endText
				numTexts++
				styles = item.text.getStyles 0, endTextIndex
			else if foundStartText
				numTexts++
				styles = item.text.getStyles 0, item.text.length

			for style of styles
				if allStyles[style]?
					allStyles[style]++
				else
					allStyles[style] = 1

			if item.text is endText then break

		returnedStyles = {}
		for style of allStyles
			if allStyles[style] is numTexts
				returnedStyles[style] = style

		returnedStyles


	__debug_print: ->
		console.log '========================'
		for item in @items
			item.text.__debug_print()
			console.log JSON.stringify item.data
			console.log '---------------------'


Object.defineProperties TextGroup.prototype, {
	"length":
		"get": -> @items.length

	"first":
		"get": -> @items[0]

	"last":
		"get": -> @items[@items.length - 1]

	"isFull":
		"get": -> @items.length is @maxItems

	"isEmpty":
		"get": -> @items.length is 0
}

TextGroup.fromDescriptor = (descriptor, maxItems, dataTemplate, restoreDataDescriptorFn = defaultCloneFn) ->
	items = []
	for item in descriptor
		items.push new TextGroupItem(StyleableText.createFromObject(item.text), restoreDataDescriptorFn(item.data))

	new TextGroup maxItems, dataTemplate, items

TextGroup.create = (maxItems = Infinity, dataTemplate = {}, numItemsToCreate = 1) ->
	group = new TextGroup maxItems, dataTemplate
	group.init numItemsToCreate

	group


#@TODO
window.TextGroup = TextGroup


module.exports = TextGroup