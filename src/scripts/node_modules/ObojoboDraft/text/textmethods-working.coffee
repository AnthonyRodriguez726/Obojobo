Text = require 'ObojoboDraft/components/text'
TextGroup = require './textgroup'
linkify = require 'ObojoboDraft/util/linkify'
TextGroupCursor = require './textgroupcursor'

POS = require './textpositionmethods' #@TODO

mergeDataFn = (consumer, digested) -> consumer

methods =
	# STATE QUERIES
	# ================================================
	getCaretEdge: (selection, chunk) ->
		info = POS.getCaretInfo selection.chunk.start, chunk
		data = chunk.componentContent

		return if not info.text?

		if info.groupIndex is 0 and info.offset <= 0
			if data.textGroup.length is 1 and info.text.length is 0 then return 'startAndEnd'
			return 'start'
		if info.groupIndex is data.textGroup.length - 1 and info.offset >= data.textGroup.last.text.length then return 'end'
		'inside'

	canRemoveSibling: (selection, chunk) -> true

	# CARET OPERATIONS
	# ================================================
	insertText: (selection, chunk, textToInsert, stylesToApply = null, stylesToRemove = null) ->
		chunk.markDirty()

		# stylesToApply = null
		# stylesToRemove = null
		# console.log '@TODO - broke this to test stuff'

		info = POS.getCaretInfo selection.chunk.start, chunk
		info = POS.getAllTheDetails selection.chunk, chunk

		return if not info.text?

		info.text.insertText info.offset, textToInsert

		if stylesToApply?
			for style in stylesToApply
				info.text.styleText info.offset, info.offset + 1, style

		if stylesToRemove?
			for style in stylesToRemove
				info.text.unstyleText info.offset, info.offset + 1, style

		if textToInsert is ' ' and not info.text.getStyles(info.offset - 1, info.offset)['a']?
			linkify info.text

		selection.setFutureCaret selection.chunk.start.chunk, { offset: info.offset + textToInsert.length, groupIndex: info.groupIndex }

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		info = POS.getCaretInfo selection.chunk.start, chunk
		data = chunk.componentContent

		return if not info.text?

		# If backspacing at the start and the chunk is indented...
		if not deleteForwards and info.offset is 0 and info.groupIndex is 0 and data.indent? and ~~data.indent > 0
			# ...decrease indent
			data.indent--
			return true

		# If backspacing and the start of a text that's not the first text...
		if not deleteForwards and info.offset is 0 and info.text isnt data.textGroup.first.text
			# ...merge that text with the previous one
			selection.setFutureCaret chunk, { offset: data.textGroup.get(info.groupIndex - 1).text.length, groupIndex: info.groupIndex - 1}
			data.textGroup.merge info.groupIndex - 1, mergeDataFn
			return true

		# If using delete key on the end of a text that's not the last text...
		if deleteForwards and info.offset is info.text.length and info.text isnt data.textGroup.last.text and data.textGroup.length > 1
			# ...merge that text with the next one
			selection.setFutureCaret chunk, { offset: info.offset, groupIndex: info.groupIndex }
			data.textGroup.merge info.groupIndex, mergeDataFn
			return true

		# If backspacing at the start of the first text nothing to delete, so unsuccessful
		if not deleteForwards and info.offset is 0 and info.text is data.textGroup.first.text
			return false

		# Likewise, if using delete key at the end of the last text then nothing to delete, so unsuccessful
		if deleteForwards and info.offset is info.text.length and info.text is data.textGroup.last.text
			return false

		# Otherwise, delete the text
		[start, end] = if not deleteForwards then [info.offset - 1, info.offset] else [info.offset, info.offset + 1]

		info.text.deleteText start, end

		# console.log 'deleteText'
		# info.text.__debug_print()

		selection.setFutureCaret chunk, { offset: start, groupIndex: info.groupIndex }
		true

	splitText: (selection, chunk, shiftKey) ->
		chunk.markDirty()

		info = POS.getCaretInfo selection.chunk.start, chunk

		return if not info.text?

		newText = info.text.split info.offset

		clonedNode = chunk.clone()
		clonedNode.componentContent.textGroup.first.text = newText
		chunk.addAfter clonedNode

		selection.setFutureCaret clonedNode, { offset: 0, groupIndex: 0 }

	# MODIFY SELECTION OPERATIONS
	# ================================================

	deleteSelection: (selection, chunk) ->
		chunk.markDirty()

		span = POS.getSelSpanInfo selection.chunk, chunk

		chunk.componentContent.textGroup.deleteSpan span.start.groupIndex, span.start.offset, span.end.groupIndex, span.end.offset, @mergeTextGroups

		pos = selection.chunk.getPosition chunk
		if pos is 'start' or pos is 'contains'
			selection.setFutureCaret chunk, { offset: span.start.offset, groupIndex: span.start.groupIndex }

	styleSelection: (selection, chunk, styleType, styleData) ->
		chunk.markDirty()

		span = POS.getSelSpanInfo selection.chunk, chunk
		data = chunk.componentContent

		data.textGroup.styleText span.start.groupIndex, span.start.offset, span.end.groupIndex, span.end.offset, styleType, styleData

	unstyleSelection: (selection, chunk, styleType, styleData) ->
		chunk.markDirty()

		span = POS.getSelSpanInfo selection.chunk, chunk
		data = chunk.componentContent

		data.textGroup.unstyleText span.start.groupIndex, span.start.offset, span.end.groupIndex, span.end.offset, styleType, styleData

	getSelectionStyles: (selection, chunk) ->
		# console.log 'getSelectionStyles', arguments, chunk.get('index')

		span = POS.getSelSpanInfo selection.chunk, chunk
		data = chunk.componentContent

		#@todo:
		if not span.start? or not span.end? then return {}

		data.textGroup.getStyles span.start.groupIndex, span.start.offset, span.end.groupIndex, span.end.offset

	# NO SELECTION OPERATIONS
	# ================================================

	# acceptMerge: (selection, digestedChunk, consumerChunk) -> true

	# Allows the chunk to be merged to do what it needs to
	# willBeMergedDelete: (selection, digestedChunk, consumerChunk) ->
	# 	console.log 'willBeMergedDelete', arguments
	# 	digestedChunk.remove()
	# 	false

	# willBeMergedAccept: (selection, digestedChunk, consumerChunk) ->
	# 	console.log 'willBeMergedAccept'
	# 	true

	# willBeMergedReject: (selection, digestedChunk, consumerChunk) ->
	# 	false

	canMergeWith: (selection, digestedChunk, consumerChunk) ->
		digestedChunk.componentContent.textGroup? and consumerChunk.componentContent.textGroup?

	# mergeDelete: (selection, consumerChunk, digestedChunk) ->
		# consumerChunk.replaceWith digestedChunk

		# startInfo = POS.getStartInfo digestedChunk
		# selection.setFutureCaret digestedChunk, { groupIndex:startInfo.groupIndex, offset:startInfo.offset }

	merge: (selection, consumerChunk, digestedChunk) ->
		consumerChunk.markDirty()

		consumerData = consumerChunk.componentContent
		digestedData = digestedChunk.componentContent

		if not digestedData.textGroup?
			digestedChunk.remove()
			return

		oldTextLength = consumerData.textGroup.last.text.length
		oldIndex = consumerData.textGroup.length - 1

		consumerData.textGroup.last.text.merge digestedData.textGroup.first.text
		digestedData.textGroup.remove 0

		while not consumerData.textGroup.isFull and digestedData.textGroup.length > 0
			item = digestedData.textGroup.first
			consumerData.textGroup.add item.text, item.data
			digestedData.textGroup.remove 0

		if digestedData.textGroup.length is 0
			digestedChunk.remove()

		selection.setFutureCaret consumerChunk, { offset: oldTextLength, groupIndex: oldIndex }

	# insertTab: (selection, chunk, untab) ->
	# 	chunk.markDirty()

	# 	if selection.chunk.type is 'chunkSpan'
	# 		return @indent selection, chunk, untab



	indent: (selection, chunk, decreaseIndent) ->
		chunk.markDirty()

		# if selection.chunk.type is 'caret'
		# 	info = POS.getCaretInfo selection.chunk.start, chunk
		# 	if info.groupIndex isnt 0 or info.offset isnt 0
		# 		return @insertText selection, chunk, "\t"

		data = chunk.componentContent

		if data.indent?
			if not decreaseIndent
				data.indent++
			else if data.indent > 0
				data.indent--

	onTab: (selection, chunk, untab) ->
		@deleteSelection selection, chunk
		@insertText selection, chunk, ["\t"]

	#@TODO - GET RID OF THIS
	init: (selection, chunk) ->
		chunk.componentContent.textGroup.init 0

	# Return true if chunkToBeDigested is OK with its contents being absorbed by consumerChunk
	acceptAbsorb: (selection, chunkToBeDigested, consumerChunk) ->
		chunkToBeDigested.componentContent.textGroup? and consumerChunk.componentContent.textGroup?

	# consumerChunk will absorb the contents of digestedChunk
	# returns the newly created chunks
	absorb: (selection, consumerChunk, digestedChunk) ->
		return [] if not digestedChunk.callComponentFn 'acceptAbsorb', selection, [consumerChunk]

		addedChunks = []
		digestedTextGroup = digestedChunk.componentContent.textGroup

		while not digestedTextGroup.isEmpty
			newChunk = consumerChunk.clone()
			newTextGroup = newChunk.componentContent.textGroup
			newTextGroup.clear()

			while not newTextGroup.isFull and not digestedTextGroup.isEmpty
				item = digestedTextGroup.remove(0)
				newTextGroup.add item.text, item.data

			addedChunks.push newChunk
			digestedChunk.addBefore newChunk

		digestedChunk.remove()

		addedChunks

	# The selection will be transformed into one or more newChunk chunks
	transformSelection: (selection, newChunk) ->
		data = newChunk.componentContent

		if selection.chunk.type isnt 'chunkSpan'
			selection.chunk.start.chunk.callComponentFn 'split', selection
			newChunks = newChunk.callComponentFn 'absorb', selection, [selection.chunk.start.chunk]

			firstChunk = newChunks[0]
			lastChunk = newChunks[newChunks.length - 1]
		else
			selection.chunk.start.chunk.callComponentFn 'split', selection
			newTopChunks = newChunk.callComponentFn 'absorb', selection, [selection.chunk.start.chunk]

			for digestableChunk in selection.chunk.inbetween
				newChunk.callComponentFn 'absorb', selection, [digestableChunk]

			selection.chunk.end.chunk.callComponentFn 'split', selection
			newBottomChunks = newChunk.callComponentFn 'absorb', selection, [selection.chunk.end.chunk]

			firstChunk = newTopChunks[0]
			lastChunk = newBottomChunks[newBottomChunks.length - 1]

		startInfo = POS.getStartInfo firstChunk
		endInfo = POS.getEndInfo lastChunk
		selection.setFutureStart firstChunk, { groupIndex:startInfo.groupIndex, offset:startInfo.offset }
		selection.setFutureEnd lastChunk, { groupIndex:endInfo.groupIndex, offset:endInfo.offset }

	# split chunk into a possible total of three new chunks - one before the selection, one containing the selection and one after the selection
	split: (selection, chunk) ->
		chunk.markDirty()

		span = POS.getSelSpanInfo selection.chunk, chunk
		data = chunk.componentContent

		allTextSelected = span.start.groupIndex is 0 and span.end.groupIndex is data.textGroup.length - 1
		return if allTextSelected

		top = chunk.clone()
		middle = chunk
		bottom = chunk.clone()

		top.componentContent.textGroup.slice    0,                      span.start.groupIndex
		middle.componentContent.textGroup.slice span.start.groupIndex,   span.end.groupIndex + 1
		bottom.componentContent.textGroup.slice span.end.groupIndex + 1, Infinity

		if top.componentContent.textGroup.length > 0
			middle.addBefore top

		if bottom.componentContent.textGroup.length > 0
			middle.addAfter bottom

	# absorb: (selection, chunk, chunksToAbsorb) ->
	# 	console.log 'split', arguments

	# 	span = POS.getSelSpanInfo selection.chunk, chunk
	# 	range = selection.chunk.getRange(chunk.getDomEl())
	# 	data = chunk.componentContent

	# 	allTextSelected = span.start.groupIndex is 0 and span.end.groupIndex is data.textGroup.length - 1

	# 	console.log allTextSelected

	# 	return if allTextSelected

	# 	top = chunk.clone()
	# 	middle = chunk
	# 	bottom = chunk.clone()

	# 	top.componentContent.textGroup.slice    0,                      span.start.groupIndex
	# 	middle.componentContent.textGroup.slice span.start.groupIndex,   span.end.groupIndex + 1
	# 	bottom.componentContent.textGroup.slice span.end.groupIndex + 1, Infinity

	# 	console.log top, middle, bottom

	# 	if top.componentContent.textGroup.length > 0
	# 		middle.addBefore top

	# 	if bottom.componentContent.textGroup.length > 0
	# 		middle.addAfter bottom

	# 		middle.callComponentFn 'transformSelf', sel, [newChunk]

	# transformSelf: (selection, chunk, newChunk) ->
	# 	oldTextGroup = chunk.componentContent.textGroup
	# 	newTextGroup = newChunk.componentContent.textGroup

	# 	# oldTextGroup.clear()

	# 	curChunk = false
	# 	while not newTextGroup.isFull
	# 		newTextGroup.add
	# 	oldTextGroup.addGroup newTextGroup

	# STORING SELECTION OPERATIONS
	# ================================================

	saveSelection: (selection, chunk, cursor) ->
		info = POS.getCaretInfo cursor, chunk

		groupIndex: info.groupIndex
		offset:     info.offset

	# Take descriptor at savedSelData and turn it into selection.chunk.*
	restoreSelection: (selection, chunk, type, savedSelData) ->
		node = POS.getTextNode chunk, savedSelData.groupIndex
		return null if not node?

		domPos = Text.getDomPosition savedSelData.offset, node

		if type is 'start'
			selection.chunk.setStart domPos.textNode, domPos.offset
		else if type is 'end'
			selection.chunk.setEnd domPos.textNode, domPos.offset

	# # Take selection.chunk.future* and turn it into selection.chunk.*
	# updateSelection: (selection, chunk, type) ->
	# 	if type is 'start' or type is 'inside'
	# 		node = POS.getTextNode chunk, selection.chunk.futureStart.data.groupIndex
	# 		o = Text.getDomPosition selection.chunk.futureStart.data.offset, node
	# 		selection.chunk.setStart o.textNode, o.offset

	# 	if type is 'end' or type is 'inside'
	# 		node = POS.getTextNode chunk, selection.chunk.futureEnd.data.groupIndex
	# 		o = Text.getDomPosition selection.chunk.futureEnd.data.offset, node
	# 		selection.chunk.setEnd o.textNode, o.offset

	selectStart: (selection, chunk) ->
		info = POS.getStartInfo chunk
		selection.setFutureCaret chunk, { groupIndex:info.groupIndex, offset:info.offset }

	selectEnd: (selection, chunk) ->
		info = POS.getEndInfo chunk
		selection.setFutureCaret chunk, { groupIndex:info.groupIndex, offset:info.offset }

	# TEXT MENU OPERATIONS
	# ================================================

	getTextMenuCommands: (selection, chunk) ->
		[
			{
				label: 'Bold'
				image: '/img/editor/textmenu/bold.svg'
				fn: (selection, chunk) ->
					if selection.styles['b']
						chunk.callComponentFn 'unstyleSelection', selection, ['b']
					else
						chunk.callComponentFn 'styleSelection', selection, ['b']

			},
			{
				label: 'Italic'
				image: '/img/editor/textmenu/italic.svg'
				fn: (selection, chunk) ->
					if selection.styles['i']
						chunk.callComponentFn 'unstyleSelection', selection, ['i']
					else
						chunk.callComponentFn 'styleSelection', selection, ['i']
			},
			{
				label: 'Link...'
				image: '/img/editor/textmenu/link.svg'
				pre: -> { href: prompt('Href?') }
				fn: (selection, chunk, data) ->
					return if not data?.href?
					chunk.callComponentFn 'styleSelection', selection, ['a', { href:data.href }]
			},
			{
				label: 'Sup'
				image: '/img/editor/textmenu/sup.svg'
				fn: (selection, chunk) ->
					chunk.callComponentFn 'styleSelection', selection, ['sup', 1]
			},
			{
				label: 'Sub'
				image: '/img/editor/textmenu/sub.svg'
				fn: (selection, chunk) ->
					chunk.callComponentFn 'styleSelection', selection, ['sup', -1]
			},
		]

	# decorate: (component) ->
	# 	console.log 'DECORATE', methods, component
	# 	for method, methodName in methods
	# 		console.log method, methodName
	# 		continue if methodName is 'decorate'
	# 		component[methodName] = method

module.exports = methods