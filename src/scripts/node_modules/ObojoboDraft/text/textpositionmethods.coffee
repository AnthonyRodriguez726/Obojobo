# Handy methods for dealing with the selection of text groups

Text = require 'ObojoboDraft/components/text'

TextPositionMethods =
	getCaretInfo: (cursor, chunk) ->
		if not cursor.isText then return null

		info = Text.getOboTextInfo cursor.textNode, cursor.offset
		info.text = TextPositionMethods.getText chunk, info.groupIndex

		# console.log 'getCaretInfo', info

		info

	getText: (chunk, index) ->
		data = chunk.componentContent

		if isNaN(parseInt(index, 10)) or index < 0 or index >= data.textGroup.length then return null

		data.textGroup.get(index).text

	getStartInfo: (chunk) ->
		data = chunk.componentContent

		groupIndex: 0
		offset:    0
		text:      data.textGroup.first.text

	getEndInfo: (chunk) ->
		data = chunk.componentContent

		groupIndex: data.textGroup.length - 1
		offset:    data.textGroup.last.text.length
		text:      data.textGroup.last.text

	getSelSpanInfo: (sel, chunk) ->
		data = chunk.componentContent

		textGroup = data.textGroup

		switch sel.getPosition chunk
			when 'start'
				start: TextPositionMethods.getCaretInfo sel.start, chunk
				end:   TextPositionMethods.getEndInfo chunk

			when 'end'
				start: TextPositionMethods.getStartInfo chunk
				end:   TextPositionMethods.getCaretInfo sel.end, chunk

			when 'contains'
				start: TextPositionMethods.getCaretInfo sel.start, chunk
				end:   TextPositionMethods.getCaretInfo sel.end, chunk

			when 'inside'
				start: TextPositionMethods.getStartInfo chunk
				end:   TextPositionMethods.getEndInfo chunk

			else
				start: null
				end: null

	getTextNode: (chunk, groupIndex) ->
		chunk.getDomEl().querySelector "*[data-group-index='#{groupIndex}']"

	getAllTheDetails: (sel, chunk) ->
		data = chunk.componentContent

		textGroup = data.textGroup

		chunkStart =
			groupIndex: 0
			offset:    0
			text:      data.textGroup.first.text

		chunkEnd =
			groupIndex: data.textGroup.length - 1
			offset:    data.textGroup.last.text.length
			text:      data.textGroup.last.text

		position = sel.getPosition chunk

		spanInfo = switch position
			when 'start'
				start: TextPositionMethods.getCaretInfo sel.start, chunk
				end:   chunkEnd

			when 'end'
				start: chunkStart
				end:   TextPositionMethods.getCaretInfo sel.end, chunk

			when 'contains'
				start: TextPositionMethods.getCaretInfo sel.start, chunk
				end:   TextPositionMethods.getCaretInfo sel.end, chunk

			when 'inside'
				start: chunkStart
				end:   chunkEnd

			else
				start: null
				end: null

		type: sel.type
		position: position
		chunkStart: chunkStart
		chunkEnd: chunkEnd
		start: spanInfo.start
		end: spanInfo.end




	# reselectSpan: (sel, chunk, span = null) ->
	# 	console.log '@TODO this is busted'
	# 	span ?=  TextPositionMethods.getSelSpanInfo sel, chunk
	# 	range = text.getRange(chunk.getDomEl())
	# 	if range is 'start' or range is 'both'
	# 		sel.setFutureStart chunk, { offset: span.start.offset, groupIndex: span.start.groupIndex }
	# 	if range is 'end' or range is 'both'
	# 		sel.setFutureEnd chunk, { offset: span.end.offset, groupIndex: span.end.groupIndex }


module.exports = TextPositionMethods