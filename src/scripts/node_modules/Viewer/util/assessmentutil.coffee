Dispatcher = window.ObojoboDraft.Common.flux.Dispatcher

AssessmentUtil =
	getAssessmentForModel: (state, model) ->
		if model.get('type') is 'ObojoboDraft.Sections.Assessment'
			assessmentModel = model
		else
			assessmentModel = model.getParentOfType 'ObojoboDraft.Sections.Assessment'

		if not assessmentModel then return null

		assessment = state.assessments[assessmentModel.get('id')]
		if not assessment then return null

		assessment

	getCurrentAttemptForModel: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state, model
		if not assessment then return null

		assessment.current

	getLastAttemptForModel: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state, model
		if not assessment or assessment.length is 0 then return null

		assessment.attempts[assessment.attempts.length - 1]

	getAttemptAverage: (attempt) ->
		total = 0
		numQuestions = 0

		console.log '@TODO - Maybe instead of checking for Questions look for items that have some sort of "scorable" property?'

		scores = Object.values(attempt.scores)
		finalTotal = scores.reduce (total, score) ->
			total + score

		finalTotal / scores.length

	getLastAttemptAverageForModel: (state, model) ->
		lastAttempt = AssessmentUtil.getLastAttemptForModel(state, model)
		if not lastAttempt then return null

		AssessmentUtil.getAttemptAverage lastAttempt

	getAllAveragesForModel: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state, model
		if assessment is null or assessment.attempts.length is 0 then return null

		scores = []
		for attempt in assessment.attempts
			scores.push AssessmentUtil.getAttemptAverage(attempt)

		scores

	getHighestAssessmentScoreForModel: (state, model) ->
		assessment = AssessmentUtil.getAssessmentForModel state,model
		if assessment is null or assessment.attempts.length is 0 then return null

		AssessmentUtil.getAllAveragesForModel(state, model).reduce (a, b) -> Math.max a, b

	startAttempt: (model) ->
		Dispatcher.dispatch {
			type: 'startAttempt',
			value:
				model: model
		}

	endAttempt: (model) ->
		Dispatcher.dispatch {
			type: 'endAttempt',
			value:
				model: model
		}

	registerQuestionForAttempt: (question) ->
		Dispatcher.dispatch {
			type: 'registerQuestionForAttempt',
			value:
				model: question
		}

	registerDataForAttempt: (model, key, value) ->
		Dispatcher.dispatch {
			type: 'registerDataForAttempt',
			value:
				model: model,
				dataKey: key,
				dataValue: value
		}


module.exports = AssessmentUtil