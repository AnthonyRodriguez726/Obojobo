require './figure.scss'

CommandHandler = require './commandhandler'
commandHandler = new CommandHandler()

ObojoboDraft = require 'ObojoboDraft'
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
StyleableText = ObojoboDraft.text.StyleableText
TextGroup = ObojoboDraft.text.TextGroup
Text = ObojoboDraft.components.Text
Anchor = ObojoboDraft.components.Anchor
Chunk = ObojoboDraft.models.Chunk
DOMSelection = ObojoboDraft.page.DOMSelection
Keyboard = ObojoboDraft.page.Keyboard
NonEditableChunk = ObojoboDraft.components.NonEditableChunk
SingleInputBubble = ObojoboDraft.components.modal.bubble.SingleInputBubble
DOMUtil = ObojoboDraft.page.DOMUtil

positions = ['left', 'center', 'right']

Figure = React.createClass
	statics:
		type: 'ObojoboDraft.Chunks.Figure'
		getCommandHandler: (chunk) -> null

		# OBONODE DATA METHODS
		# ================================================
		createNewNodeData: ->
			textGroup: TextGroup.create(1)
			url: null
			position: 'center'

		cloneNodeData: (data) ->
			textGroup: data.textGroup.clone()
			url: data.url
			position: data.position

		# SERIALIZATION/DECODE METHODS
		# ================================================
		createNodeDataFromDescriptor: (descriptor) ->
			textGroup: TextGroup.fromDescriptor descriptor.content.textGroup, 1
			url: descriptor.content.url
			position: descriptor.content.position

		getDataDescriptor: (chunk) ->
			data = chunk.componentContent

			textGroup: data.textGroup.toDescriptor()
			url: data.url
			position: data.position

		# HTML METHODS
		# ================================================
		createNewNodesFromElement: (el) ->
			group = TextGroup.create(1)
			group.first.text = StyleableText.createFromElement(el)

			[
				Chunk.create @, {
					textGroup: group
					indent: 0
				}
			]

	setPosition: (position) ->
		@props.chunk.markDirty()

		data = @props.chunk.componentContent

		data.position = position

		@setState { chunk:@props.chunk }
		@props.updateFn()

	decreasePosition: ->
		data = @props.chunk.componentContent
		index = positions.indexOf(data.position) - 1

		if index < 0 then return

		@setPosition positions[index]

	increasePosition: ->
		data = @props.chunk.componentContent
		index = positions.indexOf(data.position) + 1

		if index > positions.length - 1 then return

		@setPosition positions[index]

	setPositionLeft: (event) ->
		event.preventDefault()
		@setPosition 'left'

	setPositionCenter: (event) ->
		event.preventDefault()
		@setPosition 'center'

	setPositionRight: (event) ->
		event.preventDefault()
		@setPosition 'right'

	onAnchorKeyDown: (event) ->
		switch event.keyCode
			when Keyboard.LEFT_ARROW
				event.preventDefault()
				@decreasePosition()
				return

			when Keyboard.RIGHT_ARROW
				event.preventDefault()
				@increasePosition()
				return

	setImageURL: ->
		@props.chunk.markDirty()
		@props.editChunk @props.chunk

	onChange: (newValue) ->
		@props.chunk.markDirty()
		console.log 'YT on Change', newValue
		# @props.chunk.markDirty()
		# data = @props.chunk.componentContent
		# data.videoId = newValue
		@setState { userImageURL:newValue }

	onClose: ->
		@props.chunk.markDirty()
		@props.chunk.componentContent.url = @state.userImageURL

		@setState {
			chunk: @props.chunk
		}

		# @props.setTextMode on
		@props.stopEditing()

		@props.selection.setFutureCaret @props.chunk.get('index'), { groupIndex:'anchor:img-anchor', offset:0 }
		@props.updateFn()

	# shouldComponentUpdate: ->
	# 	@props.chunk.needsUpdate

	componentDidUpdate: ->
		@props.chunk.markUpdated()

	render: ->
		data = @props.chunk.componentContent

		# focusedInCaption = (new TextGroupSelection @props.selection.chunk, @props.chunk).includes data.textGroup.first
		focusedInCaption = DOMSelection.includes @refs.caption
		focusedInAnchor = DOMSelection.includes @refs.anchorContainer

		`<NonEditableChunk className="obojobo-draft--chunks--figure" ref="component">
			<figure className={data.position + (data.textGroup.first.text.length === 0 && !focusedInCaption ? ' empty-caption' : '') + (focusedInAnchor ? ' focus-anchor' : '')} unselectable="on">
				<div className='anchor-container' ref="anchorContainer">
					<Anchor focusOutline name="img-anchor" onKeyDown={this.onAnchorKeyDown} />
					<img src={data.url} unselectable="on" />
					<div className="position-controls">
						<button onMouseDown={this.setPositionLeft}>Left</button>
						<button onMouseDown={this.setPositionCenter}>Center</button>
						<button onMouseDown={this.setPositionRight}>Right</button>
					</div>
					<div className="img-controls">
						<button onMouseDown={this.setImageURL}>Set image from URL</button>
						<button onMouseDown={this.todo}>Upload image</button>
					</div>
				</div>
				<figcaption contentEditable="true" suppressContentEditableWarning={true} ref="caption">
					<Text text={data.textGroup.first.text} groupIndex="0" />
				</figcaption>
			</figure>
			{ this.props.isEditing ? <SingleInputBubble label="Image URL" value={this.state.userImageURL} onChange={this.onChange} onClose={this.onClose} onCancel={this.onCancel} /> : null }
		</NonEditableChunk>`

OBO.registerChunk Figure, {
	insertItem:
		label: 'Figure'
		icon: require 'svg-url?noquotes!./assets/insert-icon.svg'
		onInsert: ObojoboDraft.chunk.insertWithText
}
OBO.addToolbarItem {
	type: 'button'
	label: 'Figure'
	icon: require 'svg-url?noquotes!./assets/toolbar-icon.svg'
	onClick: (toolbarItem, editorState) ->
		newChunk = Chunk.create Figure
		newChunk.transformSelection editorState.selection
}

module.exports = Figure