TextGroupCommandHandler = Editor.command.TextGroupCommandHandler

ObojoboDraft = window.ObojoboDraft
TextGroupSelection = ObojoboDraft.text.TextGroupSelection
Chunk = ObojoboDraft.models.Chunk

module.exports = class CommandHandler extends TextGroupCommandHandler
	recalculateStartValues: (refTextGroup, listStyles) ->
		indents = {}

		for item in refTextGroup.items
			indentLevel = item.data.indent
			if not indents[indentLevel]?
				indents[indentLevel] = 1
			else
				indents[indentLevel]++

		for indentLevel, startAddition of indents
			style = listStyles.getSetStyles indentLevel
			if style.start isnt null
				style.start += startAddition

	splitText: (selection, chunk, shiftKey) ->
		chunk.markDirty()

		console.log 'split text???'

		tgs = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		item = data.textGroup.get(tgs.start.groupIndex)

		if item.text.length is 0
			if item.data.indent > 0
				item.data.indent--

				# selection.setFutureCaret chunk, { offset:0, groupIndex:tgs.start.groupIndex }
				tgs.setCaretToTextStart tgs.start.groupIndex

				return

			caretInLastItem = tgs.start.text is data.textGroup.last.text

			if not caretInLastItem
				afterNode = chunk.clone()
				afterNode.componentContent.textGroup = data.textGroup.split tgs.start.groupIndex

			inbetweenNode = Chunk.create()

			data.textGroup.remove tgs.start.groupIndex

			chunk.addAfter inbetweenNode

			if not caretInLastItem
				@recalculateStartValues data.textGroup, afterNode.componentContent.listStyles
				inbetweenNode.addAfter afterNode

				if chunk.componentContent.textGroup.isEmpty
					chunk.remove()

			# selection.setFutureCaret inbetweenNode, { offset:0, groupIndex:0 }
			inbetweenNode.selectStart()
			return

		data.textGroup.splitText tgs.start.groupIndex, tgs.start.offset

		# selection.setFutureCaret chunk, { offset:0, groupIndex:tgs.start.groupIndex + 1}
		tgs.setCaretToTextStart tgs.start.groupIndex + 1

	indent: (selection, chunk, decreaseIndent) ->
		chunk.markDirty()

		data = chunk.componentContent
		tgs = new TextGroupSelection chunk, selection.virtual

		# console.log sel

		# selection.setFutureFromDescriptor selection.getSelectionDescriptor()
		# console.log selection.futureStart, selection.futureEnd

		if tgs.type is 'caret'
			# info = POS.getCaretInfo selection.chunk.start, chunk

			# If the first list item has the cursor
			if tgs.start.isFirstText
				# Indent the whole list instead
				return super selection, chunk, decreaseIndent

			# Else indent the list item with the cursor
			@applyIndent data.textGroup.get(tgs.start.groupIndex).data, decreaseIndent
			return

		# If the first list item is in some way selected
		if tgs.start.isFirstText
			# Indent the whole list instead
			return super selection, chunk, decreaseIndent

		# Else indent each list item in the selection
		curIndex = tgs.start.groupIndex
		while curIndex <= tgs.end.groupIndex
			@applyIndent data.textGroup.get(curIndex).data, decreaseIndent
			curIndex++

		# POS.reselectSpan chunk, span


	onTab: (selection, chunk, unTab) ->
		chunk.markDirty()

		data = chunk.componentContent
		tgs = new TextGroupSelection chunk, selection.virtual

		if tgs.type is 'caret'
			if tgs.start.isTextStart
				@indent selection, chunk, unTab
			else
				super selection, chunk, unTab
			return

		if tgs.start.groupIndex isnt tgs.end.groupIndex or tgs.start.isTextStart
			@indent selection, chunk, unTab
		else
			super selection, chunk, unTab

	applyIndent: (data, decreaseIndent) ->
		if not decreaseIndent
			data.indent++
		else if data.indent > 0
			data.indent--

	getTextMenuCommands: (selection, chunk) ->
		commands = super selection, chunk
		commands.push {
			label: 'Indent'
			fn: (selection, chunk) ->
				# chunk.callComponentFn 'indent', selection, [false]
				chunk.indent selection, false

		}
		commands.push {
			label: 'Unindent'
			fn: (selection, chunk) ->
				# chunk.callComponentFn 'indent', selection, [true]
				chunk.indent selection, true
		}

		commands

	# replaceSelection: (selection, newChunk) ->
	# 	console.log '__replaceSelection', arguments
	# 	console.clear()
	# 	data = newChunk.componentContent

	# 	# if selection.chunk.type is 'caret' and selection.startChunk.acceptAbsorb selection, newChunk
	# 	if selection.chunk.type is 'caret'
	# 		selection.startChunk.addAfter newChunk
	# 		newChunk.absorb selection, selection.startChunk
	# 		return

	# 	super selection, newChunk

	deleteSelection: (selection, chunk) ->
		selType = selection.chunk.type
		textGroup = chunk.componentContent.textGroup

		super selection, chunk

		# if more than one chunk was selected and the whole list was deleted then assume
		# we want to revert this list to a SingleText.
		if textGroup.length is 1 and textGroup.first.text.length is 0 and selType is 'chunkSpan'
			chunk.revert()

	deleteText: (selection, chunk, deleteForwards) ->
		chunk.markDirty()

		console.log 'deleteText', @, @recalculateStartValues

		tgs = new TextGroupSelection chunk, selection.virtual
		data = chunk.componentContent

		s = tgs.start

		# If backspacing at the start of one of the list items (that isn't the first)
		if not deleteForwards and not s.isFirstText and s.isTextStart and data.textGroup.get(s.groupIndex).data.indent > 0
			#...then unindent
			data.textGroup.get(s.groupIndex).data.indent--
			return true

		# if backspacing at the start of an item that is at minimum indent (and we're not attempting to un-indent the whole list)
		if not deleteForwards and s.isTextStart and data.textGroup.get(s.groupIndex).data.indent is 0 and (s.groupIndex > 0 or data.indent is 0)
			newChunk = Chunk.create()
			# consumed = chunk.clone()
			# consumed.componentContent.textGroup.toSlice s.groupIndex, s.groupIndex + 1
			# newChunk.callComponentFn 'absorb', selection, [newChunk, consumed]
			#@TODO - this assumes too much, should use 'absorb'
			newChunk.componentContent.textGroup.first.text = data.textGroup.get(s.groupIndex).text

			if s.isFirstText
				top    = chunk
				bottom = chunk.clone()

				bottom.componentContent.textGroup.__debug_print()
				bottom.componentContent.textGroup.toSlice 1
				bottom.componentContent.textGroup.__debug_print()
				@recalculateStartValues bottom.componentContent.textGroup, top.componentContent.listStyles

				top.replaceWith newChunk
				newChunk.addAfter bottom

			else if s.isLastText
				top = chunk

				top.componentContent.textGroup.toSlice 0, data.textGroup.length - 2

				top.addAfter newChunk
			else
				top    = chunk
				middle = newChunk
				bottom = chunk.clone()

				top.componentContent.textGroup.toSlice 0, s.groupIndex - 1
				bottom.componentContent.textGroup.toSlice s.groupIndex + 1
				@recalculateStartValues top.componentContent.textGroup, bottom.componentContent.listStyles

				top.addAfter middle
				middle.addAfter bottom





			# selection.setFutureCaret newChunk, { offset:0, groupIndex:0 }
			newChunk.selectStart()

			return true

		super selection, chunk, deleteForwards