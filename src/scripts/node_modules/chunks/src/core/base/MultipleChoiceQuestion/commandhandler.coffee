TextGroupCommandHandler = require 'Editor/command/TextGroupCommandHandler'

module.exports = class CommandHandler extends TextGroupCommandHandler
	selectAll: (selection, chunk) ->
		if not chunk.editing then return @selectStart selection, chunk

		sel = new TextGroupSelection chunk, selection

		if sel.start.groupIndex is sel.end.groupIndex
			selection.setFutureStart chunk, { offset: 0, groupIndex: sel.start.groupIndex }
			selection.setFutureEnd chunk, { offset: chunk.componentContent.textGroup.get(sel.start.groupIndex).text.length, groupIndex: sel.start.groupIndex }

			return true

		false

	selectStart: (selection, chunk) ->
		if not chunk.editing then return selection.setFutureCaret chunk, { offset:0, groupIndex:'anchor:main' }
		super selection, chunk

	selectEnd: (selection, chunk) ->
		if not chunk.editing then return selection.setFutureCaret chunk, { offset:0, groupIndex:'anchor:main' }
		super selection, chunk

	split: (selection, chunk) -> false
	splitText: (selection, chunk, shiftKey) ->
		chunk.insertText selection, "\n"

	getTextMenuCommands: (selection, chunk) ->
		if not chunk.editing then return []
		super selection, chunk

	deleteText: (selection, chunk, deleteForwards) ->
		if not chunk.editing then return chunk.revert selection
		super selection, chunk, deleteForwards

	canMergeWith: (selection, digestedChunk, consumerChunk) ->
		false

	deleteSelection: (selection, chunk) ->
		chunk.markDirty()
		data = chunk.componentContent

		# span = POS.getSelSpanInfo selection.chunk, chunk
		sel = new TextGroupSelection chunk, selection

		if sel.end.groupIndex isnt sel.start.groupIndex
			sel.end.groupIndex = sel.start.groupIndex
			sel.end.offset = data.textGroup.get(sel.start.groupIndex).text.length

		chunk.componentContent.textGroup.deleteSpan sel.start.groupIndex, sel.start.offset, sel.end.groupIndex, sel.end.offset

		pos = selection.chunk.getPosition chunk
		if pos is 'start' or pos is 'contains'
			selection.setFutureCaret chunk, sel.start.toObject()

	acceptAbsorb: (selection, chunkToBeDigested, consumerChunk) -> false
	absorb: (selection, consumerChunk, digestedChunk) -> false