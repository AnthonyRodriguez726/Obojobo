require './editorapp.scss'
require './indent.scss'

Toolbar = require './toolbar'
SideMenu = require './sidemenu'
ChunkOptionsMenu = require './chunkoptionsmenu'
StylesMenu = require './stylesmenu'
LoadingModal = require './loadingmodal'
DebugMenu = require './debugmenu'
Modal = require './modal'
Selection = require './selection'
StyleBrush = require './stylebrush'
EditorPage = require './editorpage'
History = require '../history/history'

# MutationPainter = require 'editor/debug/mutationpainter'
# MutationPainter.observe()

ObojoboDraft = window.ObojoboDraft
OBO = window.OBO

TextMenu = ObojoboDraft.components.TextMenu
ChunkUtil = ObojoboDraft.chunk.util.ChunkUtil
StyleType = ObojoboDraft.text.StyleType
Screen = ObojoboDraft.page.Screen
Module = ObojoboDraft.models.Module
Chunk = ObojoboDraft.models.Chunk
Metadata = ObojoboDraft.models.Metadata
ChunkCollection = ObojoboDraft.models.ChunkCollection
DOMSelection = ObojoboDraft.selection.DOMSelection

EditorApp = React.createClass

	getInitialState: ->
		module = @props.module or new Module()
		if module.chunks.length is 0
			module.chunks.add Chunk.create()

		module.app = @

		@history = new History
		@selection = new Selection module
		@textModifiers = []
		@moduleChanged = false

		@toolbarItemsListeningForSelectionUpdate = []
		for item in @props.toolbarItems
			if item.onSelectionUpdate?
				@toolbarItemsListeningForSelectionUpdate.push item

		window.__force = (->
			@saveAndRenderModule()
		).bind(@)
		window.__history = @history
		window.__lo = module
		window.__s = @selection
		window.__sd = ( ->
			console.log JSON.stringify(@selection.getSelectionDescriptor(), null, 2)
		).bind(@)
		window.__editor = @
		window.__tg = (index) ->
			module.chunks.at(index).componentContent.textGroup
		window.__tgs = ((index) ->
			new ObojoboDraft.textGroup.TextGroupSelection module.chunks.at(index), @state.selection.virtual
		).bind(@)
		window.__editChunk = ( (index, controlsEnabled) ->
			@editChunk __lo.chunks.at(index), controlsEnabled
			__force({})
		).bind(@)

		window.__undo = @undo
		window.__redo = @redo

		window.EditorApp = @

		return (
			module: module
			styleBrush: new StyleBrush()
			modalElement: null
			editingChunk: null
			textControlsEnabled: true
			sideMenuEnabled: true
			toolbarControlsEnabled: true
			loading: false
			selection: @selection
			key: 0
		)



	_onTextMenuCommand: (commandLabel) ->
		@selection.runTextCommands commandLabel
		@updateSelectionFromDOM()
		@saveAndRenderModule()

	_onSideMenuStartDrag: ->
		@setState { textControlsEnabled:false, toolbarControlsEnabled:false }

	_onSideMenuDrop: ->
		@setState { textControlsEnabled:true, toolbarControlsEnabled:true }

		@refs.editorPage.forcePageRerender { callback: (->
			@saveAndRenderModule()
		).bind(@)}

	_onSideMenuClick: (position, componentClass) ->
		@setState { loading:true }

		console.time 'sideMenuClick'

		self = @
		onInsert = @props.insertItems.get(componentClass.type).onInsert

		if position is 'before'
			onInsert componentClass, 'before', self.selection.startChunk, self.selection, ->
				self.setState { loading:false }
				self.saveAndRenderModule()

		else
			newChunk = onInsert componentClass, 'after', self.selection.endChunk, self.selection, ->
				self.setState { loading:false }
				self.saveAndRenderModule()

		console.timeEnd 'sideMenuClick'

	_onToolbarCommand: (command, data) ->
		command.onClick command, @state, @selection, data
		@saveAndRenderModule()

		# Hack
		window.setTimeout ( ->
			@selection.selectDOM()
		).bind(@)

	_onKeyDown: (event) ->
		# console.log 'EditorApp::_onKeyDown', event

		if event.metaKey or event.ctrlKey
			switch event.keyCode
				when 90 #z
					event.preventDefault()
					if event.shiftKey then @redo() else @undo()

				when 89 #y
					event.preventDefault()
					@redo()

				when 83 #s
					event.preventDefault()

					if event.shiftKey
						location.hash = encodeURIComponent('json:' + JSON.stringify(@state.module.toJSON()))
					else
						@state.module.save()

	_onMouseUp: (event) ->
		if @editingChunk is null and not DOMSelection.includes(ReactDOM.findDOMNode(this.refs.editorPage))
			@renderModule()






	encodeState: ->
		module: @state.module.toJSON()
		styleBrush: @state.styleBrush.toObject()
		modalElement: '@TODO'
		editingChunkIndex: if @state.editingChunk? then @state.editingChunk.get('index') else -1
		textControlsEnabled: @state.textControlsEnabled
		sideMenuEnabled: @state.sideMenuEnabled
		toolbarControlsEnabled: @state.toolbarControlsEnabled
		loading: @state.loading
		selection: @state.selection.getSelectionDescriptor()

	restoreState: (o) ->
		@state.module.fromDescriptor o.module
		@state.selection.virtual.fromObject o.selection

		if o.editingChunkIndex is -1
			@

		# @futureSelection = o.selection
		@needSelectionUpdate = true

		@setState {
			module: @state.module
			styleBrush: StyleBrush.fromObject o.styleBrush
			editingChunk: if o.editingChunkIndex is -1 then null else @state.module.chunks.at(o.editingChunkIndex)
			textControlsEnabled: o.textControlsEnabled
			sideMenuEnabled: o.sideMenuEnabled
			toolbarControlsEnabled: o.toolbarControlsEnabled
			loading: o.loading
			selection: @state.selection
			key: @state.key + 1
		}

	# saveAndRenderModule: (skipSave = false) ->
	saveAndRenderModule: ->
		if @saveModule() then @renderModule()

	saveModule: ->
		console.time 'history'
		@moduleChanged = @history.add @encodeState()
		console.timeEnd 'history'

		window.localStorage.__module = JSON.stringify(@state.module.toJSON())


	renderModule: ->
		@needSelectionUpdate = true

		@setState {
			module: @state.module
		}

	updateSelectionFromDOM: (selectDOM = true) ->
		@selection.update @state.module

		if selectDOM
			@selection.selectDOM()

		for item in @toolbarItemsListeningForSelectionUpdate
			if item.onSelectionUpdate
				item.onSelectionUpdate item, @state, @selection #@TODO - editorState should be a passable object

		@setState {
			selection: @selection
		}

	# send: (fn, chunkOrChunks, data) ->
	# 	ChunkUtil.send fn, chunkOrChunks, @selection, data

	undo: ->
		history = @history.undo()
		@restoreState history

	redo: ->
		history = @history.redo()
		@restoreState history

	showModal: (component) ->
		@setState { modalElement:component }

	editChunk: (chunk, controlsEnabled = {}) ->
		# chunk.startEditing()
		chunk.markForUpdate()

		if not controlsEnabled.textControlsEnabled    then controlsEnabled.textControlsEnabled = false
		if not controlsEnabled.sideMenuEnabled        then controlsEnabled.sideMenuEnabled = false
		if not controlsEnabled.toolbarControlsEnabled then controlsEnabled.toolbarControlsEnabled = false

		@setState {
			editingChunk: chunk
			textControlsEnabled: controlsEnabled.textControlsEnabled
			sideMenuEnabled: controlsEnabled.sideMenuEnabled
			toolbarControlsEnabled: controlsEnabled.toolbarControlsEnabled
		}

	stopEditing: ->
		if @state.editingChunk
			# @state.editingChunk.stopEditing()
			@state.editingChunk.markForUpdate()

		@setState {
			editingChunk: null
			sideMenuEnabled: true
			textControlsEnabled: true
			toolbarControlsEnabled: true
		}

		@updateSelectionFromDOM()

	setLoading: (val) ->
		@setState { loading:val }

	triggerKeyListeners: ->
		if @moduleChanged
			delete @moduleChanged

			console.time 'textListeners'
			for listener in OBO.textListeners
				listener.match @selection, @
			console.timeEnd 'textListeners'

	componentDidMount: ->
		@screen = new Screen(@refs.main)

		ReactDOM.findDOMNode(this.refs.editorPage).focus()
		@updateSelectionFromDOM()

		document.addEventListener 'keydown', @_onKeyDown.bind(@)

		#prime the pumps
		@saveModule()

	componentDidUpdate: ->
		if @needSelectionUpdate?
			delete @needSelectionUpdate

			@selection.selectDOM()
			@updateSelectionFromDOM()



	render: ->
		console.time 'renderEditor'

		saveHistoryFn = @saveHistory
		showModalFn = @showModal
		setLoadingFn = @setLoading
		selection = @selection
		saveAndRenderModuleFn = @saveAndRenderModule
		updateSelectionFromDOMFn = @updateSelectionFromDOM
		setControlsStateFn = @setControlsState

		if @state.loading or @state.modalElement?
			sideMenuEnabled = false
			textControlsEnabled = false
			toolbarControlsEnabled = false
		else
			sideMenuEnabled = @state.sideMenuEnabled
			textControlsEnabled = @state.textControlsEnabled
			toolbarControlsEnabled = @state.toolbarControlsEnabled


		return `<div className="editor--components--editor-app"  onMouseUp={this._onMouseUp} key={this.state.key}>
			<div className={'toolbar-wrapper' + (!textControlsEnabled ? ' disabled' : '')}>
				<Toolbar selection={this.selection} commandHandler={this._onToolbarCommand} commands={this.props.toolbarItems} enabled={toolbarControlsEnabled} />
			</div>
			<main ref="main">
				<div className='wrapper'>
					<div className="guidelines" />
					<EditorPage
						module={this.state.module}
						selection={this.selection}
						styleBrush={this.state.styleBrush}
						saveAndRenderModuleFn={saveAndRenderModuleFn}
						updateSelectionFromDOMFn={updateSelectionFromDOMFn}
						showModalFn={showModalFn}
						setLoadingFn={setLoadingFn}
						editChunk={this.editChunk}
						stopEditing={this.stopEditing}
						editingChunk={this.state.editingChunk}
						enabled={textControlsEnabled}
						pageEdit={this.state.editingChunk === null}
						screen={this.screen}
						triggerKeyListeners={this.triggerKeyListeners}
						ref="editorPage"
					/>

					<div ref="controls" className="controls">
						<DebugMenu selection={this.selection} history={this.history} controlsEl={this.refs.controls} />
						<SideMenu
							renderModuleFn={this.renderModule}
							selection={this.selection}
							module={this.state.module}
							handlerFn={this._onSideMenuClick}
							insertItems={this.props.insertItems}
							controlsEl={this.refs.controls}
							onStartDrag={this._onSideMenuStartDrag}
							onDrop={this._onSideMenuDrop}
							enabled={sideMenuEnabled}
						/>
						<TextMenu
							relativeToElement={this.refs.controls}
							selectionRect={this.state.selection.rect}
							commandHandler={this._onTextMenuCommand}
							commands={this.state.selection.textCommands}
							enabled={textControlsEnabled}
						/>
					</div>
				</div>
			</main>
			<Modal modalElement={this.state.modalElement} showModalFn={showModalFn} />
			<LoadingModal show={this.state.loading} />
		</div>`


module.exports = EditorApp