console.log '@TODO - forcePageRender should just use callbacks'
console.log '@TODO - need more granular disableControls - i.e. allow text controls but not side menu controls'
console.log '@TODO - sometimes drag and drop puts things in the wrong spot'
console.log '@TODO - Using arrow keys the selection is a step behind'
console.log '@TODO - Need a better name than "compoment"'
console.log '@TODO - consider css namespacing'

console.log '@TODO - Allow full rich text editing inside a modal window, should you want it'
console.log '@TODO - Is there a way to better handle state of chunks like doing with chunkSelectionState?'
console.log '@TODO - Clicking the list button doesnt copy the content'
console.log '@TODO - make TextMethods the default'

require './editorapp.scss'
require './indent.scss'

Toolbar = require './toolbar'
TextMenu = require './textmenu'
# ContextMenu = require './contextmenu'
SideMenu = require './sidemenu'
ChunkOptionsMenu = require './chunkoptionsmenu'
StylesMenu = require './stylesmenu'
LoadingModal = require './loadingmodal'
DebugMenu = require './debugmenu'
Modal = require './modal'
Selection = require './selection'
StyleBrush = require './stylebrush'
EditorPage = require './editorpage'
History = require '../history/history'
Assets = require '../assets'


# MutationPainter = require 'editor/debug/mutationpainter'
# MutationPainter.observe()

ObojoboDraft = require 'ObojoboDraft'
ChunkUtil = ObojoboDraft.page.ChunkUtil

# Command = require '../commands/command'
StyleType = ObojoboDraft.text.StyleType
Screen = ObojoboDraft.page.Screen

ComponentClassMap = ObojoboDraft.util.ComponentClassMap



Module = ObojoboDraft.models.Module
Chunk = ObojoboDraft.models.Chunk
Metadata = ObojoboDraft.models.Metadata
ChunkCollection = ObojoboDraft.models.ChunkCollection
DOMSelection = ObojoboDraft.page.DOMSelection







EditorApp = React.createClass

	getInitialState: ->
		# loDescriptor = require('../../debug/fakelo')

		# module = Module.createFromDescriptor {"metadata":{},"chunks":[{"type":"ObojoboDraft.Chunks.SingleTextt","content":{"indent":0,"textGroup":[{"text":{"value":"asdf","styleList":null},"data":{}}],"type":"p"},"contentType":"json","derivedFrom":null,"index":0,"draftId":null}]}
		module = @props.module or new Module()
		if module.chunks.length is 0
			module.chunks.add Chunk.create()

		#@TODO - Temporary
		module.update = (->
			@setState { lastSaveTime: Date.now() }
		).bind(@)
		# setInterval((->
		# 	@state.module.save() #@TODO - dont save if currently saving
		# ).bind(@), 3000)

		@history = new History
		@selection = new Selection module
		@textModifiers = []

		@toolbarItemsListeningForSelectionUpdate = []
		for item in @props.toolbarItems
			if item.onSelectionUpdate?
				@toolbarItemsListeningForSelectionUpdate.push item


		window.__history = @history
		window.__lo = module
		window.__s = @selection

		window.EditorApp = @

		return (
			module: module
			selection: @selection #@TODO
			styleBrush: new StyleBrush()
			spellingSuggestions: []
			modalElement: null
			lastSaveTime: Date.now()
			editingChunk: null
			stopEditingListener: null
			textControlsEnabled: true
			sideMenuEnabled: true
			toolbarControlsEnabled: true
			loading: false
			screen: null
		)

	send: (fn, chunkOrChunks, data) ->
		ChunkUtil.send fn, chunkOrChunks, @state.selection, data

	undo: ->
		history = @history.undo()
		if history.lo
			@forceModule history.lo
		if history.selection
			# console.log JSON.stringify(history.selection, null, 2)
			@state.selection.setFutureFromDescriptor history.selection

	redo: ->
		history = @history.redo()
		if history.lo
			@forceModule history.lo
		if history.selection
			# console.log JSON.stringify(history.selection, null, 2)
			@state.selection.setFutureFromDescriptor history.selection

	forceModule: (descriptor) ->
		@state.module.fromDescriptor descriptor
		@state.module.markForUpdate()
		@setState { module:@state.module }

	componentDidMount: ->
		ReactDOM.findDOMNode(this.refs.editorPage).focus()
		@updateSelection()

		#prime the pumps
		@history.add @state.module.toJSON(), @selection.getSelectionDescriptor()

		@setState { screen:new Screen(@refs.main) }

	onTextMenuCommand: (commandLabel) ->
		@selection.runTextCommands commandLabel
		@update()

	onSideMenuStartDrag: ->
		@setState { textControlsEnabled:false, toolbarControlsEnabled:false }

	onSideMenuDrop: ->
		# console.clear()
		@setState { textControlsEnabled:true, toolbarControlsEnabled:true }

		@refs.editorPage.forcePageRerender { callback: (->
			if @selection.chunk.all.length is 1
				@selection.chunk.start.chunk.selectAll @selection
			else
				@selection.chunk.start.chunk.selectStart @selection, true
				@selection.chunk.end.chunk.selectEnd @selection, true
			@update()
		).bind(@)}

	onSideMenuClick: (position, componentClass) ->
		# console.log 'componentClass', componentClass
		@setState { loading:true }

		console.time 'sideMenuClick'

		self = @
		# setTimeout ->

		onInsert = @props.insertItems.get(componentClass.type).onInsert


		if position is 'before'
			onInsert componentClass, 'before', self.selection.chunk.start.chunk, self.selection, ->
				self.setState { loading:false }
				console.timeEnd 'sideMenuClick'
				self.update()

		else
			newChunk = onInsert componentClass, 'after', self.selection.chunk.end.chunk, self.selection, ->
				self.setState { loading:false }
				self.update()


	onToolbarCommand: (command, data) ->
		# return
		command.onClick command, @state, data
		@update()

	showModal: (component) ->
		@setState { modalElement:component }

	update: ->
		# page = ReactDOM.findDOMNode this.refs.editorPage
		# console.log 'active element be', document.activeElement, page.contains(document.activeElement)
		# if not page.contains(document.activeElement)
		# 	updateFn = @update
		# 	setTimeout ->
		# 		page.focus()
		# 		updateFn()
		# 	, 1000

		# 	return

		# special case - force at least one chunk!
		if @state.module.chunks.length is 0
			@state.module.chunks.add Chunk.create()

		if not @state.selection.futureStart and not @state.selection.futureEnd
			# console.log 'yeah man'
			@state.selection.setFutureFromSelection()

		console.time 'history'
		# console.log 'add to history'
		# console.log JSON.stringify(@state.selection.getFutureDescriptor(), null, 2)
		@history.add @state.module.toJSON(), @state.selection.getFutureDescriptor()
		console.timeEnd 'history'

		@setState {
			module: @state.module
			selection: @state.selection
			styleBrush: @state.styleBrush
		}

		# if forceFullUpdate
		# 	@state.module.markForUpdate()
		# 	@forceUpdate()

	updateSelection: ->
		# console.log 'updateSelection', DOMSelection.get().startContainer
		# return

		@state.selection.update @state.module

		for item in @toolbarItemsListeningForSelectionUpdate
			if item.onSelectionUpdate
				item.onSelectionUpdate item, @state

		# if needsUpdate then @update()


		# textTypeCommand = @state.toolbarCommands[0]

		# if @state.selection.chunk?.start?.chunk?
		# 	type = @state.selection.chunk.start.chunk.get('type')
		# 	headingLevel = 0
		# 	if type is 'ObojoboDraft.Chunks.Heading'
		# 		headingLevel = @state.selection.chunk.start.chunk.componentContent.headingLevel

		# 	for chunk in @state.selection.chunk.all
		# 		if chunk.get('type') isnt type
		# 			type = null
		# 			break
		# 		else if type is 'ObojoboDraft.Chunks.Heading' and chunk.componentContent.headingLevel isnt headingLevel
		# 			type = null
		# 			break

		# 	if type?
		# 		switch type + headingLevel
		# 			when 'ObojoboDraft.Chunks.Heading1'
		# 				textTypeCommand.selectedOption = 'Heading 1'
		# 			when 'ObojoboDraft.Chunks.Heading2'
		# 				textTypeCommand.selectedOption = 'Heading 2'
		# 			else
		# 				textTypeCommand.selectedOption = 'Normal Text'
		# 	else
		# 		textTypeCommand.selectedOption = null

		# boldCommand = @state.toolbarCommands[2]
		# boldBrushState = @state.styleBrush.getStyleState(StyleType.BOLD)
		# boldState = boldBrushState is 'apply' or (boldBrushState isnt 'remove' and @state.selection.styles[StyleType.BOLD])
		# boldCommand.state = if boldState then 'on' else 'off'

		# italicCommand = @state.toolbarCommands[3]
		# italicBrushState = @state.styleBrush.getStyleState(StyleType.ITALIC)
		# italicState = italicBrushState is 'apply' or (italicBrushState isnt 'remove' and @state.selection.styles[StyleType.ITALIC])
		# italicCommand.state = if italicState then 'on' else 'off'

		@setState {
			selection: @state.selection
			# toolbarItems: @props.toolbarItems
		}

	onKeyDown: (event) ->
		# console.log 'EditorApp::onKeyDown', event

		if event.metaKey or event.ctrlKey
			switch event.keyCode
				when 90 #z
					event.preventDefault()
					if event.shiftKey then @redo() else @undo()

				when 89 #y
					event.preventDefault()
					@redo()

				when 83 #s
					event.preventDefault()

					if event.shiftKey
						location.hash = encodeURIComponent('json:' + JSON.stringify(@state.module.toJSON()))
					else
						@state.module.save()

	onMouseUp: (event) ->
		if not DOMSelection.includes(ReactDOM.findDOMNode(this.refs.editorPage))
			this.refs.editorPage.selectPageEnd()

	componentDidUpdate: ->
		console.timeEnd 'renderEditor'

	# setControlsState: (val) ->
	# 	@setState { controlsEnabled:val }

	editChunk: (chunk, controlsEnabled = {}, stopEditingListener = ->) ->
		# console.log '$$$$$$$$$$$$$$$$$$$editChunk', arguments

		chunk.startEditing()

		if not controlsEnabled.textControlsEnabled    then controlsEnabled.textControlsEnabled = false
		if not controlsEnabled.sideMenuEnabled        then controlsEnabled.sideMenuEnabled = false
		if not controlsEnabled.toolbarControlsEnabled then controlsEnabled.toolbarControlsEnabled = false

		@setState {
			editingChunk: chunk
			stopEditingListener: stopEditingListener
			textControlsEnabled: controlsEnabled.textControlsEnabled
			sideMenuEnabled: controlsEnabled.sideMenuEnabled
			toolbarControlsEnabled: controlsEnabled.toolbarControlsEnabled
		}

	stopEditing: ->
		# console.log 'STOP EDITING', @state.stopEditingListener()
		if @state.editingChunk
			# console.log 'mark for update', @state.editingChunk
			@state.stopEditingListener()
			@state.editingChunk.stopEditing()
			# console.log @state.editingChunk.needsUpdate

		@setState {
			editingChunk: null
			stopEditingListener: null
			sideMenuEnabled: true
			textControlsEnabled: true
			toolbarControlsEnabled: true
		}

		# @forceUpdate()
		@updateSelection()
		# @update()

	setLoading: (val) ->
		@setState { loading:val }

	render: ->
		console.time 'renderEditor'

		saveHistoryFn = @saveHistory
		showModalFn = @showModal
		setLoadingFn = @setLoading
		selection = @selection
		updateFn = @update
		updateSelectionFn = @updateSelection
		setControlsStateFn = @setControlsState

		if @state.loading or @state.modalElement?
			sideMenuEnabled = false
			textControlsEnabled = false
			toolbarControlsEnabled = false
		else
			sideMenuEnabled = @state.sideMenuEnabled
			textControlsEnabled = @state.textControlsEnabled
			toolbarControlsEnabled = @state.toolbarControlsEnabled

		# console.log 'controls enabled', controlsEnabled
		#

		return `<div className="editor--components--editor-app" onKeyDown={this.onKeyDown} onMouseUp={this.onMouseUp}>
			<div className={'toolbar-wrapper' + (!textControlsEnabled ? ' disabled' : '')}>
				<Toolbar selection={this.state.selection} commandHandler={this.onToolbarCommand} commands={this.props.toolbarItems} enabled={toolbarControlsEnabled} />
			</div>
			<main ref="main">
				<div className='wrapper'>
					<EditorPage
						module={this.state.module}
						selection={this.state.selection}
						styleBrush={this.state.styleBrush}
						updateFn={updateFn}
						updateSelectionFn={updateSelectionFn}
						showModalFn={showModalFn}
						setLoadingFn={setLoadingFn}
						editChunk={this.editChunk}
						stopEditing={this.stopEditing}
						editingChunk={this.state.editingChunk}
						enabled={textControlsEnabled}
						pageEdit={this.state.editingChunk === null}
						screen={this.state.screen}
						ref="editorPage"
					/>
					<div ref="controls" className="controls">
						<DebugMenu selection={this.state.selection} history={this.history} controlsEl={this.refs.controls} />
						<SideMenu
							selection={this.state.selection}
							module={this.state.module}
							handlerFn={this.onSideMenuClick}
							insertItems={this.props.insertItems}
							controlsEl={this.refs.controls}
							onStartDrag={this.onSideMenuStartDrag}
							onDrop={this.onSideMenuDrop}
							enabled={sideMenuEnabled}
						/>
						<TextMenu
							selection={this.state.selection}
							commandHandler={this.onTextMenuCommand}
							controlsEl={this.refs.controls}
							enabled={textControlsEnabled}
						/>
					</div>
				</div>
			</main>
			<Modal modalElement={this.state.modalElement} showModalFn={showModalFn} />
			<LoadingModal show={this.state.loading} />
		</div>`


module.exports = EditorApp