console.log '@TODO - All of the command handlers should move out to Editor since they all have to do with editing!!!!'
console.log '@TODO - forcePageRender should just use callbacks'
console.log '@TODO - need more granular disableControls - i.e. allow text controls but not side menu controls'
console.log '@TODO - Need a better name than "compoment"'
console.log '@TODO - consider css namespacing'
console.log '@TODO - Allow full rich text editing inside a modal window, should you want it'
console.log '@TODO - Is there a way to better handle state of chunks like doing with chunkSelectionState?'
console.log '@TODO - pasting doesnt work right in mult choice questions'
console.log '@TODO - turn classes like pad into sass mixins'
console.log '@TODO - Now we have the concept of anchors it would be cool to have selection.start.isAnchor'
console.log '@TODO - Dont like that Im getting the dom selection for curChunkSel when the chunk selection should be up to date theoretically'
console.log '@TODO - Shortcuts like Ctrl+S to save trigger screen tween'

require './editorapp.scss'
require './indent.scss'

Toolbar = require './toolbar'
TextMenu = require './textmenu'
SideMenu = require './sidemenu'
ChunkOptionsMenu = require './chunkoptionsmenu'
StylesMenu = require './stylesmenu'
LoadingModal = require './loadingmodal'
DebugMenu = require './debugmenu'
Modal = require './modal'
Selection = require './selection'
StyleBrush = require './stylebrush'
EditorPage = require './editorpage'
History = require '../history/history'
Assets = require '../assets'

# MutationPainter = require 'editor/debug/mutationpainter'
# MutationPainter.observe()

ObojoboDraft = window.ObojoboDraft
ChunkUtil = ObojoboDraft.page.ChunkUtil

StyleType = ObojoboDraft.text.StyleType
Screen = ObojoboDraft.page.Screen
ComponentClassMap = ObojoboDraft.util.ComponentClassMap
Module = ObojoboDraft.models.Module
Chunk = ObojoboDraft.models.Chunk
Metadata = ObojoboDraft.models.Metadata
ChunkCollection = ObojoboDraft.models.ChunkCollection
DOMSelection = ObojoboDraft.page.DOMSelection


EditorApp = React.createClass

	getInitialState: ->
		module = @props.module or new Module()
		if module.chunks.length is 0
			module.chunks.add Chunk.create()

		console.log '@TODO - super hack:'
		module.editor = @

		@history = new History
		@selection = new Selection module
		@textModifiers = []

		@toolbarItemsListeningForSelectionUpdate = []
		for item in @props.toolbarItems
			if item.onSelectionUpdate?
				@toolbarItemsListeningForSelectionUpdate.push item

		window.__force = (->
			# @setState { key:0 }
			@saveAndRenderModule()
		).bind(@)
		window.__history = @history
		window.__lo = module
		window.__s = @selection
		window.__editor = @
		window.__tg = (index) ->
			module.chunks.at(index).componentContent.textGroup
		window.__tgs = ((index) ->
			new ObojoboDraft.text.TextGroupSelection module.chunks.at(index), @state.selection.virtual
		).bind(@)
		window.__editChunk = ( (index, controlsEnabled) ->
			@editChunk __lo.chunks.at(index), controlsEnabled
			__force({})
		).bind(@)
		window.__saveSel = ( ->
			[@selection.chunk.start.chunk.saveSelection(@selection, 'start'),@selection.chunk.start.chunk.saveSelection(@selection, 'end')]
		).bind(@)
		window.__restoreSel = ( (selArr) ->
			@selection.chunk.start.chunk.restoreSelection @selection, 'start', selArr[0]
			@selection.chunk.start.chunk.restoreSelection @selection, 'end', selArr[1]
			@selection.chunk.select()
		).bind(@)
		window.__selAll = ( () ->
			@selection.chunk.start.chunk.selectAll @selection
		).bind(@)
		window.__test = ( () ->
			c = @selection.virtual.start.chunk

			c.deleteSelection @selection
			c.insertText @selection, 'XYZ', ['b']
			console.log 'sb', @selection.virtual.start.data.offset
			console.log 'eb', @selection.virtual.end.data.offset
			@selection.virtual.end.data.offset += 3
			console.log 'sa', @selection.virtual.start.data.offset
			console.log 'ea', @selection.virtual.end.data.offset
			virtSel = @selection.virtual

			@setState {
				module: @state.module
			}

			setTimeout ( ->
				console.log @selection.virtual.start is @selection.virtual.end
				console.log @selection.virtual
				console.log 's3', @selection.virtual.start.data.offset
				console.log 'e3', @selection.virtual.end.data.offset
				console.log @selection.virtual.end.data is @selection.virtual.start.data
				@selection.virtual.end.data.offset += 3

				console.log 's4', @selection.virtual.start.data.offset
				console.log 'e4', @selection.virtual.end.data.offset

				s = c.getDOMSelectionStart()
				e = c.getDOMSelectionEnd()
				console.log 's', s
				console.log 'e', e
				DOMSelection.set s.textNode, s.offset, e.textNode, e.offset
			).bind(@), 1000
		).bind(@)
		window.__undo = @undo
		window.__redo = @redo

		window.EditorApp = @

		@shouldUpdateSelectionFromDOM = false

		return (
			module: module
			styleBrush: new StyleBrush()
			# spellingSuggestions: []
			modalElement: null
			# lastSaveTime: Date.now()
			editingChunk: null
			textControlsEnabled: true
			sideMenuEnabled: true
			toolbarControlsEnabled: true
			loading: false
			# update: @update #@TODO
			# updates: []
			selection: @selection
			key: 0
		)

	# addModuleUpdate: ->
	# 	@state.updates.push 'module'
	# 	@setState { updates:@state.updates }

	# addSelectionUpdate: ->
	# 	@state.updates.push 'selection'
	# 	@setState { updates:@state.updates }

	encodeState: ->
		module: @state.module.toJSON()
		styleBrush: @state.styleBrush.toObject()
		modalElement: '@TODO'
		editingChunkIndex: if @state.editingChunk? then @state.editingChunk.get('index') else -1
		textControlsEnabled: @state.textControlsEnabled
		sideMenuEnabled: @state.sideMenuEnabled
		toolbarControlsEnabled: @state.toolbarControlsEnabled
		loading: @state.loading
		selection: @state.selection.getSelectionDescriptor()

	restoreState: (o) ->
		@state.module.fromDescriptor o.module
		@state.selection.virtual.fromObject o.selection

		if o.editingChunkIndex is -1
			@

		# @futureSelection = o.selection
		@needSelectionUpdate = true

		@setState {
			module: @state.module
			styleBrush: StyleBrush.fromObject o.styleBrush
			editingChunk: if o.editingChunkIndex is -1 then null else @state.module.chunks.at(o.editingChunkIndex)
			textControlsEnabled: o.textControlsEnabled
			sideMenuEnabled: o.sideMenuEnabled
			toolbarControlsEnabled: o.toolbarControlsEnabled
			loading: o.loading
			selection: @state.selection
			key: @state.key + 1
		}

	saveAndRenderModule: (skipSave = false) ->
		console.log 'SARM'
		# special case - force at least one chunk!
		if @state.module.chunks.length is 0
			@state.module.chunks.add Chunk.create()

		# if not @selection.futureStart and not @selection.futureEnd
		# 	@selection.setFutureFromSelection()

		# @selection.update @state.module

		if not skipSave
			saveResult = @saveModule()

		if not saveResult then return

		# @futureSelection = @selection.virtual.clone()

		@renderModule()

	saveModule: ->
		console.time 'history'
		@history.add @encodeState()
		console.timeEnd 'history'

	renderModule: ->
		@needSelectionUpdate = true

		@setState {
			module: @state.module
		}

	updateSelectionFromDOM: ->
		console.log 'USFD'


		@selection.update @state.module
		@selection.selectDOM()



		# @props.selection.__selectFromVirtualSelection()

		for item in @toolbarItemsListeningForSelectionUpdate
			if item.onSelectionUpdate
				item.onSelectionUpdate item, @state, @selection #@TODO - editorState should be a passable object

		# if not @sanity?
		# 	@sanity = 0

		# @sanity++

		# if @sanity > 1000
		# 	console.log 'SANITY NOW'
		# 	return

		@setState {
			selection: @selection
		}
		# @forceUpdate()

	send: (fn, chunkOrChunks, data) ->
		ChunkUtil.send fn, chunkOrChunks, @selection, data

	undo: ->
		history = @history.undo()
		# if history.lo
		# 	@forceModule history.lo
		# if history.selection
		# 	@selection.setFutureFromDescriptor history.selection
		@restoreState history

		# console.clear()
		# @history.__debug_print()

	redo: ->
		history = @history.redo()
		# if history.lo
		# 	@forceModule history.lo
		# if history.selection
		# 	@selection.setFutureFromDescriptor history.selection
		@restoreState history

		# console.clear()
		# @history.__debug_print()

	# forceModule: (descriptor) ->
	# 	@state.module.fromDescriptor descriptor
	# 	@state.module.markForUpdate()
	# 	@setState { module:@state.module }

	componentDidMount: ->
		@screen = new Screen(@refs.main)

		ReactDOM.findDOMNode(this.refs.editorPage).focus()
		@updateSelectionFromDOM()

		# @updateSelectionFromDOM()
		document.addEventListener 'keydown', @onKeyDown.bind(@)

		# setInterval @saveModule.bind(@), 1000


		#prime the pumps
		# @history.add @state.module.toJSON(), @selection.getSelectionDescriptor()
		@history.add @encodeState()

	componentDidUpdate: ->



		# @history.__debug_print()

		# if document.activeElement is document.body
		# 	setTimeout ( ->

		# 		console.log @refs.editorPage
		# 		@refs.editorPage.focusOnEditor()
		# 	).bind(@)

		if @needSelectionUpdate?
			delete @needSelectionUpdate



			# setTimeout ( ->

			@selection.selectDOM()
			@updateSelectionFromDOM()
			# ).bind(@), 1000


		# setTimeout ( ->
		# 	console.log 'focus is', document.activeElement

		# 	if document.activeElement is document.body
		# 		console.log 'FOCUS FIX'
		# 		node = @selection.dom.startContainer
		# 		while node isnt null
		# 			console.log 'CONSIDER', node
		# 			if node.getAttribute 'contenteditable'
		# 				console.log 'FOCUS!'
		# 				node.focus()
		# 				break

		# 			node = node.parentElement
		# ).bind(@), 1000

		# if @futureSelection?
		# 	@state.selection.fromObject @futureSelection
		# 	delete @futureSelection
		# 	@setState { selection:@state.selection }
		# else
		# 	@selection.selectDOM()


		# if @shouldUpdateSelectionFromDOM
		# 	delete @shouldUpdateSelectionFromDOM
		# 	@updateSelectionFromDOM()

	onTextMenuCommand: (commandLabel) ->
		@selection.runTextCommands commandLabel
		@updateSelectionFromDOM()
		@saveAndRenderModule()



	onSideMenuStartDrag: ->
		@setState { textControlsEnabled:false, toolbarControlsEnabled:false }

	onSideMenuDrop: ->
		@setState { textControlsEnabled:true, toolbarControlsEnabled:true }

		@refs.editorPage.forcePageRerender { callback: (->
			@saveAndRenderModule()
		).bind(@)}

	onSideMenuClick: (position, componentClass) ->
		@setState { loading:true }

		console.time 'sideMenuClick'

		self = @
		onInsert = @props.insertItems.get(componentClass.type).onInsert

		if position is 'before'
			onInsert componentClass, 'before', self.selection.startChunk, self.selection, ->
				self.setState { loading:false }
				self.saveAndRenderModule()

		else
			newChunk = onInsert componentClass, 'after', self.selection.endChunk, self.selection, ->
				self.setState { loading:false }
				self.saveAndRenderModule()

		console.timeEnd 'sideMenuClick'

	onToolbarCommand: (command, data) ->
		command.onClick command, @state, @selection, data
		@saveAndRenderModule()

		# Hack
		window.setTimeout ( ->
			@selection.selectDOM()
		).bind(@)

	showModal: (component) ->
		@setState { modalElement:component }

	# componentDidUpdate: ->
	# 	if @state.updates.length > 0
	# 		updateType = @state.updates.shift()
	# 		switch updateType
	# 			when 'module'    then @saveAndRenderModule()
	# 			when 'selection' then @updateSelectionFromDOM()

	onKeyDown: (event) ->
		# console.log 'EditorApp::onKeyDown', event

		if event.metaKey or event.ctrlKey
			switch event.keyCode
				when 90 #z
					event.preventDefault()
					if event.shiftKey then @redo() else @undo()

				when 89 #y
					event.preventDefault()
					@redo()

				when 83 #s
					event.preventDefault()

					if event.shiftKey
						location.hash = encodeURIComponent('json:' + JSON.stringify(@state.module.toJSON()))
					else
						@state.module.save()

	onMouseUp: (event) ->
		if not DOMSelection.includes(ReactDOM.findDOMNode(this.refs.editorPage))
			this.refs.editorPage.selectPageEnd()

	editChunk: (chunk, controlsEnabled = {}) ->
		# chunk.startEditing()
		chunk.markForUpdate()

		if not controlsEnabled.textControlsEnabled    then controlsEnabled.textControlsEnabled = false
		if not controlsEnabled.sideMenuEnabled        then controlsEnabled.sideMenuEnabled = false
		if not controlsEnabled.toolbarControlsEnabled then controlsEnabled.toolbarControlsEnabled = false

		@setState {
			editingChunk: chunk
			textControlsEnabled: controlsEnabled.textControlsEnabled
			sideMenuEnabled: controlsEnabled.sideMenuEnabled
			toolbarControlsEnabled: controlsEnabled.toolbarControlsEnabled
		}

	stopEditing: ->
		if @state.editingChunk
			# @state.editingChunk.stopEditing()
			@state.editingChunk.markForUpdate()

		@setState {
			editingChunk: null
			sideMenuEnabled: true
			textControlsEnabled: true
			toolbarControlsEnabled: true
		}

		@updateSelectionFromDOM()

	setLoading: (val) ->
		@setState { loading:val }

	render: ->
		console.time 'renderEditor'

		saveHistoryFn = @saveHistory
		showModalFn = @showModal
		setLoadingFn = @setLoading
		selection = @selection
		saveAndRenderModuleFn = @saveAndRenderModule
		updateSelectionFromDOMFn = @updateSelectionFromDOM
		setControlsStateFn = @setControlsState

		if @state.loading or @state.modalElement?
			sideMenuEnabled = false
			textControlsEnabled = false
			toolbarControlsEnabled = false
		else
			sideMenuEnabled = @state.sideMenuEnabled
			textControlsEnabled = @state.textControlsEnabled
			toolbarControlsEnabled = @state.toolbarControlsEnabled


		return `<div className="editor--components--editor-app"  onMouseUp={this.onMouseUp} key={this.state.key}>
			<div className={'toolbar-wrapper' + (!textControlsEnabled ? ' disabled' : '')}>
				<Toolbar selection={this.selection} commandHandler={this.onToolbarCommand} commands={this.props.toolbarItems} enabled={toolbarControlsEnabled} />
			</div>
			<main ref="main">
				<div className='wrapper'>
					<EditorPage
						module={this.state.module}
						selection={this.selection}
						styleBrush={this.state.styleBrush}
						saveAndRenderModuleFn={saveAndRenderModuleFn}
						updateSelectionFromDOMFn={updateSelectionFromDOMFn}
						showModalFn={showModalFn}
						setLoadingFn={setLoadingFn}
						editChunk={this.editChunk}
						stopEditing={this.stopEditing}
						editingChunk={this.state.editingChunk}
						enabled={textControlsEnabled}
						pageEdit={this.state.editingChunk === null}
						screen={this.screen}
						ref="editorPage"
					/>
					<div className="guidelines" />
					<div ref="controls" className="controls">
						<DebugMenu selection={this.selection} history={this.history} controlsEl={this.refs.controls} />
						<SideMenu
							renderModuleFn={this.renderModule}
							selection={this.selection}
							module={this.state.module}
							handlerFn={this.onSideMenuClick}
							insertItems={this.props.insertItems}
							controlsEl={this.refs.controls}
							onStartDrag={this.onSideMenuStartDrag}
							onDrop={this.onSideMenuDrop}
							enabled={sideMenuEnabled}
						/>
						<TextMenu
							selection={this.selection}
							commandHandler={this.onTextMenuCommand}
							controlsEl={this.refs.controls}
							enabled={textControlsEnabled}
						/>
					</div>
				</div>
			</main>
			<Modal modalElement={this.state.modalElement} showModalFn={showModalFn} />
			<LoadingModal show={this.state.loading} />
		</div>`


module.exports = EditorApp