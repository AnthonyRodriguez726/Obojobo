console.log '@TODO - All of the command handlers should move out to Editor since they all have to do with editing!!!!'
console.log '@TODO - forcePageRender should just use callbacks'
console.log '@TODO - need more granular disableControls - i.e. allow text controls but not side menu controls'
console.log '@TODO - Need a better name than "compoment"'
console.log '@TODO - consider css namespacing'
console.log '@TODO - Allow full rich text editing inside a modal window, should you want it'
console.log '@TODO - Is there a way to better handle state of chunks like doing with chunkSelectionState?'
console.log '@TODO - pasting doesnt work right in mult choice questions'
console.log '@TODO - turn classes like pad into sass mixins'
console.log '@TODO - Now we have the concept of anchors it would be cool to have selection.start.isAnchor'
console.log '@TODO - Dont like that Im getting the dom selection for curChunkSel when the chunk selection should be up to date theoretically'
console.log '@TODO - Shortcuts like Ctrl+S to save trigger screen tween'

require './editorapp.scss'
require './indent.scss'

Toolbar = require './toolbar'
TextMenu = require './textmenu'
SideMenu = require './sidemenu'
ChunkOptionsMenu = require './chunkoptionsmenu'
StylesMenu = require './stylesmenu'
LoadingModal = require './loadingmodal'
DebugMenu = require './debugmenu'
Modal = require './modal'
Selection = require './selection'
StyleBrush = require './stylebrush'
EditorPage = require './editorpage'
History = require '../history/history'
Assets = require '../assets'

# MutationPainter = require 'editor/debug/mutationpainter'
# MutationPainter.observe()

ObojoboDraft = window.ObojoboDraft
ChunkUtil = ObojoboDraft.page.ChunkUtil

StyleType = ObojoboDraft.text.StyleType
Screen = ObojoboDraft.page.Screen
ComponentClassMap = ObojoboDraft.util.ComponentClassMap
Module = ObojoboDraft.models.Module
Chunk = ObojoboDraft.models.Chunk
Metadata = ObojoboDraft.models.Metadata
ChunkCollection = ObojoboDraft.models.ChunkCollection
DOMSelection = ObojoboDraft.page.DOMSelection


EditorApp = React.createClass

	getInitialState: ->
		module = @props.module or new Module()
		if module.chunks.length is 0
			module.chunks.add Chunk.create()

		@history = new History
		@selection = new Selection module
		@textModifiers = []

		@toolbarItemsListeningForSelectionUpdate = []
		for item in @props.toolbarItems
			if item.onSelectionUpdate?
				@toolbarItemsListeningForSelectionUpdate.push item

		window.__history = @history
		window.__lo = module
		window.__s = @selection
		window.__tg = (index) ->
			module.chunks.at(index).componentContent.textGroup



		window.EditorApp = @

		return (
			module: module
			selection: @selection #@TODO
			styleBrush: new StyleBrush()
			spellingSuggestions: []
			modalElement: null
			lastSaveTime: Date.now()
			editingChunk: null
			stopEditingListener: null
			textControlsEnabled: true
			sideMenuEnabled: true
			toolbarControlsEnabled: true
			loading: false
			update: @update #@TODO
		)

	send: (fn, chunkOrChunks, data) ->
		ChunkUtil.send fn, chunkOrChunks, @state.selection, data

	undo: ->
		history = @history.undo()
		if history.lo
			@forceModule history.lo
		if history.selection
			@state.selection.setFutureFromDescriptor history.selection

	redo: ->
		history = @history.redo()
		if history.lo
			@forceModule history.lo
		if history.selection
			@state.selection.setFutureFromDescriptor history.selection

	forceModule: (descriptor) ->
		@state.module.fromDescriptor descriptor
		@state.module.markForUpdate()
		@setState { module:@state.module }

	componentDidMount: ->
		@screen = new Screen(@refs.main)

		ReactDOM.findDOMNode(this.refs.editorPage).focus()

		@updateSelection()

		#prime the pumps
		@history.add @state.module.toJSON(), @selection.getSelectionDescriptor()

	onTextMenuCommand: (commandLabel) ->
		@selection.runTextCommands commandLabel
		@update()

	onSideMenuStartDrag: ->
		@setState { textControlsEnabled:false, toolbarControlsEnabled:false }

	onSideMenuDrop: ->
		@setState { textControlsEnabled:true, toolbarControlsEnabled:true }

		@refs.editorPage.forcePageRerender { callback: (->
			if @selection.chunk.all.length is 1
				@selection.startChunk.selectAll @selection
			else
				@selection.startChunk.selectStart @selection, true
				@selection.chunk.end.chunk.selectEnd @selection, true
			@update()
		).bind(@)}

	onSideMenuClick: (position, componentClass) ->
		@setState { loading:true }

		console.time 'sideMenuClick'

		self = @
		onInsert = @props.insertItems.get(componentClass.type).onInsert

		if position is 'before'
			onInsert componentClass, 'before', self.selection.startChunk, self.selection, ->
				self.setState { loading:false }
				self.update()

		else
			newChunk = onInsert componentClass, 'after', self.selection.chunk.end.chunk, self.selection, ->
				self.setState { loading:false }
				self.update()

		console.timeEnd 'sideMenuClick'

	onToolbarCommand: (command, data) ->
		command.onClick command, @state, data
		@update()

	showModal: (component) ->
		@setState { modalElement:component }

	update: ->
		# special case - force at least one chunk!
		if @state.module.chunks.length is 0
			@state.module.chunks.add Chunk.create()

		if not @state.selection.futureStart and not @state.selection.futureEnd
			@state.selection.setFutureFromSelection()

		console.time 'history'
		@history.add @state.module.toJSON(), @state.selection.getFutureDescriptor()
		window.localStorage.__module = JSON.stringify(@state.module.toJSON()) #@TODO
		console.timeEnd 'history'

		@setState {
			module: @state.module
			selection: @state.selection
			styleBrush: @state.styleBrush
		}

	updateSelection: ->
		@state.selection.update @state.module

		for item in @toolbarItemsListeningForSelectionUpdate
			if item.onSelectionUpdate
				item.onSelectionUpdate item, @state

		@setState {
			selection: @state.selection
		}

	onKeyDown: (event) ->
		# console.log 'EditorApp::onKeyDown', event

		if event.metaKey or event.ctrlKey
			switch event.keyCode
				when 90 #z
					event.preventDefault()
					if event.shiftKey then @redo() else @undo()

				when 89 #y
					event.preventDefault()
					@redo()

				when 83 #s
					event.preventDefault()

					if event.shiftKey
						location.hash = encodeURIComponent('json:' + JSON.stringify(@state.module.toJSON()))
					else
						@state.module.save()

	onMouseUp: (event) ->
		if not DOMSelection.includes(ReactDOM.findDOMNode(this.refs.editorPage))
			this.refs.editorPage.selectPageEnd()

	editChunk: (chunk, controlsEnabled = {}, stopEditingListener = ->) ->
		chunk.startEditing()

		if not controlsEnabled.textControlsEnabled    then controlsEnabled.textControlsEnabled = false
		if not controlsEnabled.sideMenuEnabled        then controlsEnabled.sideMenuEnabled = false
		if not controlsEnabled.toolbarControlsEnabled then controlsEnabled.toolbarControlsEnabled = false

		@setState {
			editingChunk: chunk
			stopEditingListener: stopEditingListener
			textControlsEnabled: controlsEnabled.textControlsEnabled
			sideMenuEnabled: controlsEnabled.sideMenuEnabled
			toolbarControlsEnabled: controlsEnabled.toolbarControlsEnabled
		}

	stopEditing: ->
		if @state.editingChunk
			@state.stopEditingListener()
			@state.editingChunk.stopEditing()

		@setState {
			editingChunk: null
			stopEditingListener: null
			sideMenuEnabled: true
			textControlsEnabled: true
			toolbarControlsEnabled: true
		}

		@updateSelection()

	setLoading: (val) ->
		@setState { loading:val }

	render: ->
		console.time 'renderEditor'

		saveHistoryFn = @saveHistory
		showModalFn = @showModal
		setLoadingFn = @setLoading
		selection = @selection
		updateFn = @update
		updateSelectionFn = @updateSelection
		setControlsStateFn = @setControlsState

		if @state.loading or @state.modalElement?
			sideMenuEnabled = false
			textControlsEnabled = false
			toolbarControlsEnabled = false
		else
			sideMenuEnabled = @state.sideMenuEnabled
			textControlsEnabled = @state.textControlsEnabled
			toolbarControlsEnabled = @state.toolbarControlsEnabled


		return `<div className="editor--components--editor-app" onKeyDown={this.onKeyDown} onMouseUp={this.onMouseUp}>
			<div className={'toolbar-wrapper' + (!textControlsEnabled ? ' disabled' : '')}>
				<Toolbar selection={this.state.selection} commandHandler={this.onToolbarCommand} commands={this.props.toolbarItems} enabled={toolbarControlsEnabled} />
			</div>
			<main ref="main">
				<div className='wrapper'>
					<EditorPage
						module={this.state.module}
						selection={this.state.selection}
						styleBrush={this.state.styleBrush}
						updateFn={updateFn}
						updateSelectionFn={updateSelectionFn}
						showModalFn={showModalFn}
						setLoadingFn={setLoadingFn}
						editChunk={this.editChunk}
						stopEditing={this.stopEditing}
						editingChunk={this.state.editingChunk}
						enabled={textControlsEnabled}
						pageEdit={this.state.editingChunk === null}
						screen={this.screen}
						ref="editorPage"
					/>
					<div className="guidelines" />
					<div ref="controls" className="controls">
						<DebugMenu selection={this.state.selection} history={this.history} controlsEl={this.refs.controls} />
						<SideMenu
							selection={this.state.selection}
							module={this.state.module}
							handlerFn={this.onSideMenuClick}
							insertItems={this.props.insertItems}
							controlsEl={this.refs.controls}
							onStartDrag={this.onSideMenuStartDrag}
							onDrop={this.onSideMenuDrop}
							enabled={sideMenuEnabled}
						/>
						<TextMenu
							selection={this.state.selection}
							commandHandler={this.onTextMenuCommand}
							controlsEl={this.refs.controls}
							enabled={textControlsEnabled}
						/>
					</div>
				</div>
			</main>
			<Modal modalElement={this.state.modalElement} showModalFn={showModalFn} />
			<LoadingModal show={this.state.loading} />
		</div>`


module.exports = EditorApp