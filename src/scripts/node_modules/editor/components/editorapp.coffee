require './editorapp.scss'
require './indent.scss'

toolbarConfig = require "json!../../../../../toolbar-config.json"
insertMenuConfig = require "json!../../../../../insert-menu-config.json"

Toolbar = require './toolbar'
TextMenu = require './textmenu'
# ContextMenu = require './contextmenu'
SideMenu = require './sidemenu'
ChunkOptionsMenu = require './chunkoptionsmenu'
StylesMenu = require './stylesmenu'
LoadingModal = require './loadingmodal'
DebugMenu = require './debugmenu'
Modal = require './modal'
Selection = require './selection'
StyleBrush = require './stylebrush'
EditorPage = require './editorpage'
Util = require './util'
History = require '../history/history'




# MutationPainter = require 'editor/debug/mutationpainter'
# MutationPainter.observe()

ObojoboDraft = require 'ObojoboDraft'

Assets = ObojoboDraft.Assets

for item in toolbarConfig.commands
	if item.img?
		item.img = Assets[item.img]



# Command = require '../commands/command'
StyleType = ObojoboDraft.text.StyleType
Screen = ObojoboDraft.page.Screen

ComponentClassMap = ObojoboDraft.util.ComponentClassMap



Module = ObojoboDraft.models.Module
Chunk = ObojoboDraft.models.Chunk
Metadata = ObojoboDraft.models.Metadata
ChunkCollection = ObojoboDraft.models.ChunkCollection
DOMSelection = ObojoboDraft.page.DOMSelection




console.log '@TODO - Allow full rich text editing inside a modal window, should you want it'
console.log '@TODO - Is there a way to better handle state of chunks like doing with chunkSelectionState?'
console.log '@TODO - Clicking the list button doesnt copy the content'
console.log '@TODO - make TextMethods the default'



EditorApp = React.createClass

	getInitialState: ->
		# loDescriptor = require('../../debug/fakelo')

		# module = Module.createFromDescriptor loDescriptor
		module = @props.module or new Module()
		if module.chunks.length is 0
			module.chunks.add Chunk.create()

		#@TODO - Temporary
		module.update = (->
			@setState { lastSaveTime: Date.now() }
		).bind(@)
		# setInterval((->
		# 	@state.module.save() #@TODO - dont save if currently saving
		# ).bind(@), 3000)

		@history = new History
		@selection = new Selection module
		@textModifiers = []

		window.__history = @history
		window.__lo = module
		window.__s = @selection

		window.EditorApp = @

		return (
			module: module
			selection: @selection #@TODO
			styleBrush: new StyleBrush()
			spellingSuggestions: []
			modalElement: null
			lastSaveTime: Date.now()
			# controlsEnabled: true
			editingChunk: null
			toolbarCommands: toolbarConfig.commands
			loading: false
			screen: null
		)

	send: (fn, chunkOrChunks, data) ->
		Util.send fn, chunkOrChunks, @state.selection, data

	undo: ->
		history = @history.undo()
		if history.lo
			@forceModule history.lo
		if history.selection
			# console.log JSON.stringify(history.selection, null, 2)
			@state.selection.setFutureFromDescriptor history.selection

	redo: ->
		history = @history.redo()
		if history.lo
			@forceModule history.lo
		if history.selection
			# console.log JSON.stringify(history.selection, null, 2)
			@state.selection.setFutureFromDescriptor history.selection

	forceModule: (descriptor) ->
		@state.module.fromDescriptor descriptor
		@state.module.markForUpdate()
		@setState { module:@state.module }

	componentDidMount: ->
		ReactDOM.findDOMNode(this.refs.editorPage).focus()
		@updateSelection()

		#prime the pumps
		@history.add @state.module.toJSON(), @selection.getSelectionDescriptor()

		@setState { screen:new Screen(@refs.main) }

	onTextMenuCommand: (commandLabel) ->
		@selection.runTextCommands commandLabel
		@update()

	onSideMenuClick: (position, componentClass) ->
		@setState { loading:true }

		console.time 'sideMenuClick'

		self = @
		# setTimeout ->


		if position is 'before'
			componentClass.onInsert 'before', self.selection.chunk.start.chunk, self.selection, null, ->
				self.setState { loading:false }
				console.timeEnd 'sideMenuClick'
				self.update()

		else
			newChunk = componentClass.onInsert 'after', self.selection.chunk.end.chunk, self.selection, null, ->
				self.setState { loading:false }
				self.update()


	onToolbarCommand: (command, data) ->
		# ReactDOM.findDOMNode(this.refs.editorPage).focus()

		switch command.id
			when 'textType'
				switch data.option
					when 'Heading 1'
						newChunk = Chunk.create 'ObojoboDraft.Chunks.Heading'
						newChunk.componentContent.headingLevel = 1
					when 'Heading 2'
						newChunk = Chunk.create 'ObojoboDraft.Chunks.Heading'
						newChunk.componentContent.headingLevel = 2
					when 'Normal Text'
						newChunk = Chunk.create 'ObojoboDraft.Chunks.SingleText'

				@send 'transformSelection', newChunk
				# @selectionShouldUpdateAfterRender = true
				@update()
			when 'bold'
				Util.activateStyle StyleType.BOLD, @state.selection, @state.styleBrush
				@update()
			when 'italic'
				Util.activateStyle StyleType.ITALIC, @state.selection, @state.styleBrush
				@update()

			when 'indent'
				@send 'indent', @selection.chunk.all, [false]
				@update()
			when 'unindent'
				@send 'indent', @selection.chunk.all, [true]
				@update()
			when 'image'
				@replaceSelection 'ObojoboDraft.Chunks.Figure'
			when 'table'
				@replaceSelection 'ObojoboDraft.Chunks.Table', data
			when 'insert'
				componentClass = ComponentClassMap.getClassForType data.listItem
				@replaceSelection componentClass
			when 'ul'
				newChunk = Chunk.create 'ObojoboDraft.Chunks.List'
				@send 'transformSelection', newChunk
				@update()

			when 'ol'
				newChunk = Chunk.create 'ObojoboDraft.Chunks.List'
				newChunk.componentContent.listStyles.type = 'ordered'
				@send 'transformSelection', newChunk
				@update()




	# replaceSelectionWAS_WORKING: (componentClass, data = null) ->
	# 	newChunk = null

	# 	Util.deleteSelection @selection

	# 	switch @send('getCaretEdge', @selection.chunk.start.chunk)
	# 		when 'start'
	# 			newChunk = componentClass.onInsert @selection, @selection.chunk.start.chunk.get('index'), data, @update
	# 			@selection.chunk.start.chunk.addBefore newChunk
	# 		when 'end'
	# 			newChunk = componentClass.onInsert @selection, @selection.chunk.start.chunk.get('index') + 1, data, @update
	# 			@selection.chunk.start.chunk.addAfter newChunk
	# 		when 'startAndEnd'
	# 			newChunk = componentClass.onInsert @selection, @selection.chunk.start.chunk.get('index'), data, @update
	# 			@selection.chunk.start.chunk.replaceWith newChunk
	# 			console.log '@TODO - WHAT ABOUT SELECTIONS? DO THIS WORK?'
	# 		else
	# 			@send 'splitText', @selection.chunk.start.chunk
	# 			newChunk = componentClass.onInsert @selection, @selection.chunk.start.chunk.get('index'), data, @update
	# 			@selection.chunk.start.chunk.addAfter newChunk

	# 	@send 'selectStart', newChunk

	# 	@update()

	replaceSelection: (componentClass, data = null) ->
		Util.deleteSelection @selection

		newChunk = Chunk.create componentClass #, data

		switch @send('getCaretEdge', @selection.chunk.start.chunk)
			when 'start'
				@selection.chunk.start.chunk.addBefore newChunk
			when 'end'
				@selection.chunk.start.chunk.addAfter newChunk
			when 'startAndEnd'
				@selection.chunk.start.chunk.replaceWith newChunk
			else
				@send 'splitText', @selection.chunk.start.chunk
				@selection.chunk.start.chunk.addAfter newChunk

		@update()

	showModal: (component) ->
		@setState { modalElement:component }

	update: ->
		# page = ReactDOM.findDOMNode this.refs.editorPage
		# console.log 'active element be', document.activeElement, page.contains(document.activeElement)
		# if not page.contains(document.activeElement)
		# 	updateFn = @update
		# 	setTimeout ->
		# 		page.focus()
		# 		updateFn()
		# 	, 1000

		# 	return

		# special case - force at least one chunk!
		if @state.module.chunks.length is 0
			@state.module.chunks.add Chunk.create()

		if not @state.selection.futureStart and not @state.selection.futureEnd
			# console.log 'yeah man'
			@state.selection.setFutureFromSelection()

		console.time 'history'
		# console.log 'add to history'
		# console.log JSON.stringify(@state.selection.getFutureDescriptor(), null, 2)
		@history.add @state.module.toJSON(), @state.selection.getFutureDescriptor()
		console.timeEnd 'history'

		@setState {
			module: @state.module
			selection: @state.selection
			styleBrush: @state.styleBrush
		}

		# if forceFullUpdate
		# 	@state.module.markForUpdate()
		# 	@forceUpdate()

	updateSelection: ->
		@state.selection.update @state.module

		textTypeCommand = @state.toolbarCommands[0]

		if @state.selection.chunk?.start?.chunk?
			type = @state.selection.chunk.start.chunk.get('type')
			headingLevel = 0
			if type is 'ObojoboDraft.Chunks.Heading'
				headingLevel = @state.selection.chunk.start.chunk.componentContent.headingLevel

			for chunk in @state.selection.chunk.all
				if chunk.get('type') isnt type
					type = null
					break
				else if type is 'ObojoboDraft.Chunks.Heading' and chunk.componentContent.headingLevel isnt headingLevel
					type = null
					break

			if type?
				switch type + headingLevel
					when 'ObojoboDraft.Chunks.Heading1'
						textTypeCommand.selectedOption = 'Heading 1'
					when 'ObojoboDraft.Chunks.Heading2'
						textTypeCommand.selectedOption = 'Heading 2'
					else
						textTypeCommand.selectedOption = 'Normal Text'
			else
				textTypeCommand.selectedOption = null

		boldCommand = @state.toolbarCommands[2]
		boldBrushState = @state.styleBrush.getStyleState(StyleType.BOLD)
		boldState = boldBrushState is 'apply' or (boldBrushState isnt 'remove' and @state.selection.styles[StyleType.BOLD])
		boldCommand.state = if boldState then 'on' else 'off'

		italicCommand = @state.toolbarCommands[3]
		italicBrushState = @state.styleBrush.getStyleState(StyleType.ITALIC)
		italicState = italicBrushState is 'apply' or (italicBrushState isnt 'remove' and @state.selection.styles[StyleType.ITALIC])
		italicCommand.state = if italicState then 'on' else 'off'

		@setState {
			selection: @state.selection
			toolbarCommands: @state.toolbarCommands
		}

	onKeyDown: (event) ->
		# console.log 'EditorApp::onKeyDown', event

		if event.metaKey or event.ctrlKey
			switch event.keyCode
				when 90 #z
					event.preventDefault()
					if event.shiftKey then @redo() else @undo()

				when 89 #y
					event.preventDefault()
					@redo()

				when 83 #s
					event.preventDefault()
					@state.module.save()

	onMouseUp: (event) ->
		if not DOMSelection.includes(ReactDOM.findDOMNode(this.refs.editorPage))
			this.refs.editorPage.selectPageEnd()

	componentDidUpdate: ->
		console.timeEnd 'renderEditor'

	# setControlsState: (val) ->
	# 	@setState { controlsEnabled:val }

	editChunk: (chunk) ->
		@setState { editingChunk:chunk }

	setLoading: (val) ->
		@setState { loading:val }

	render: ->
		console.time 'renderEditor'

		saveHistoryFn = @saveHistory
		showModalFn = @showModal
		setLoadingFn = @setLoading
		selection = @selection
		updateFn = @update
		updateSelectionFn = @updateSelection
		setControlsStateFn = @setControlsState
		controlsEnabled = @state.editingChunk is null and @state.modalElement is null and not @state.loading

		return `<div className={'editor--components--editor-app ' + (controlsEnabled ? 'controls-enabled' : 'controls-disabled')} onKeyDown={this.onKeyDown} onMouseUp={this.onMouseUp}>
			<div className={'toolbar-wrapper' + (!controlsEnabled ? ' disabled' : '')}>
				<Toolbar selection={this.state.selection} commandHandler={this.onToolbarCommand} commands={this.state.toolbarCommands} />
			</div>
			<main ref="main">
				<div className='wrapper'>
					<EditorPage
						module={this.state.module}
						selection={this.state.selection}
						styleBrush={this.state.styleBrush}
						updateFn={updateFn}
						updateSelectionFn={updateSelectionFn}
						showModalFn={showModalFn}
						setLoadingFn={setLoadingFn}
						editChunk={this.editChunk}
						editingChunk={this.state.editingChunk}
						enabled={controlsEnabled}
						screen={this.state.screen}
						ref="editorPage"
					/>
					<div ref="controls" className={'controls' + (!controlsEnabled ? ' disabled' : '')}>
						<DebugMenu selection={this.state.selection} history={this.history} controlsEl={this.refs.controls} />
						<SideMenu selection={this.state.selection} handlerFn={this.onSideMenuClick} inserts={insertMenuConfig} controlsEl={this.refs.controls} />
						<TextMenu selection={this.state.selection} commandHandler={this.onTextMenuCommand} controlsEl={this.refs.controls} />
					</div>
				</div>
			</main>
			<Modal modalElement={this.state.modalElement} showModalFn={showModalFn} />
			<LoadingModal show={this.state.loading} />
		</div>`

		# React.createElement 'div', {
		# 	onKeyDown: @onKeyDown
		# 	},
		# 	React.createElement Toolbar, {
		# 		selection: @state.selection
		# 		commandHandler: @onToolbarCommand
		# 		commands: @state.toolbarCommands
		# 		}
		# 	React.createElement DebugMenu, { selection:@state.selection, history:@history }, null
		# 	React.createElement SideMenu, {
		# 		selection: @state.selection
		# 		handlerFn: @onSideMenuClick
		# 		inserts: ComponentClassMap.getInserts()
		# 		}
		# 	React.createElement ChunkOptionsMenu, {
		# 		selection: @state.selection
		# 		handlerFn: @onSideMenuClick
		# 		}
		# 	React.createElement TextMenu, { selection:@state.selection, commandHandler:@onTextMenuCommand }
		# 	# React.createElement 'div', { style:{color:'gray', position:'absolute', left:0, top:20} }, "Last saved " + (new Date(@state.lastSaveTime))
		# 	React.createElement EditorPage, {
		# 		module:@state.module,
		# 		selection:@state.selection,
		# 		styleBrush:@state.styleBrush,
		# 		updateFn:updateFn,
		# 		updateSelectionFn:updateSelectionFn,
		# 		showModalFn:showModalFn
		# 	}
		# 	React.createElement Modal, { modalElement:@state.modalElement, showModalFn:showModalFn }


module.exports = EditorApp