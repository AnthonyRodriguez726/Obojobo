require './sidemenu.scss'

SideMenuList = require './sidemenu/sidemenulist'
SideMenuHandle = require './sidemenu/sidemenuhandle'

dragula = require 'Dragula'

ObojoboDraft = require 'ObojoboDraft'
DOMUtil = ObojoboDraft.page.DOMUtil

MARGIN = 15
WIDTH = 30
HEIGHT = 30

SideMenu = React.createClass
	getInitialState: ->
		chunkRect: @props.selection.chunkRect
		draggedNode: null

	componentWillReceiveProps: (nextProps) ->
		@setState {
			chunkRect: nextProps.selection.chunkRect
		}

	onBeforeClick: (componentClass) ->
		@props.handlerFn 'before', componentClass

	onAfterClick: (componentClass) ->
		@props.handlerFn 'after', componentClass

	setupDragAndDrop: ->
		if @drake then @drake.destroy()

		thisEl = ReactDOM.findDOMNode(@)

		@drake = dragula [@props.controlsEl],
			moves: (el) -> el is thisEl

		@drake.on 'drag', @onDrag
		@drake.on 'dragend', @onDragEnd

	onDrag: (el) ->
		chunk = @props.selection.chunk.start.chunk
		chunkEl = chunk.getDomEl()
		chunkEl.classList.add 'dragged'

		chunkCloneEl = chunkEl.cloneNode true
		chunkCloneEl.setAttribute 'data-id', '0'
		chunkCloneEl.style.width = @state.chunkRect.width + 'px'
		chunkCloneEl.style.height = @state.chunkRect.height + 'px'

		document.addEventListener 'mousemove', @boundMouseMoveListener

		@setState {
			draggedNode: chunkCloneEl
		}

		true

	onMouseMove: (event) ->
		if not @lastClientY then @lastClientY = event.clientY

		if event.clientY > @lastClientY
			@direction = 'down'
		else if event.clientY < @lastClientY
			@direction = 'up'

		chunk = @props.selection.chunk.start.chunk
		selChunk = chunk.getDomEl()

		el = document.elementFromPoint(window.innerWidth / 2, event.clientY)

		mouseChunkIndex = ~~DOMUtil.findParentAttr(el, 'data-component-index')

		if mouseChunkIndex?
			mouseChunk = @props.module.chunks.at mouseChunkIndex

			if mouseChunk isnt chunk
				mouseChunkEl = mouseChunk.getDomEl()
				@dragNewIndex = mouseChunk.get('index')
				switch @direction
					when 'up' then mouseChunkEl.parentElement.insertBefore selChunk, mouseChunkEl
					when 'down' then mouseChunkEl.parentElement.insertBefore selChunk, mouseChunkEl.nextSibling


		@lastClientY = event.clientY

		true

	onDragEnd: ->
		document.removeEventListener 'mousemove', @boundMouseMoveListener

		# @refs.cloneContainer.removeChild @refs.cloneContainer.children[0]

		chunk = @props.selection.chunk.start.chunk
		# oldIndex = chunk.get('index')
		# newIndex = @dragNewIndex

		# chunk = @props.module.chunks.models.splice(oldIndex, 1)[0]
		# @props.module.chunks.models.splice newIndex, 0, chunk

		# @props.module.recalcuateIndices()
		@props.module.moveChunk chunk, @dragNewIndex

		@props.onDrop chunk

		@setState {
			draggedNode: null
		}

		# setTimeout @setupDragAndDrop#.bind(@)

	componentDidMount: ->
		@boundMouseMoveListener = @onMouseMove.bind(@)

		setTimeout ( ->
			@setupDragAndDrop()
		).bind(@), 1000

	render: ->
		chunkRect = @state.chunkRect

		if not chunkRect or not @props.controlsEl then return null

		ctrlRect = @props.controlsEl.getBoundingClientRect()

		top = chunkRect.top - ctrlRect.top - MARGIN
		bottom = chunkRect.bottom - ctrlRect.top - MARGIN

		styles =
			top: top

		`<div className={'editor--components--side-menu' + (this.state.draggedNode ? ' dragging' : '')} style={styles}>
			<SideMenuHandle yPos={HEIGHT / 2} height={bottom - top} />
			<SideMenuList inserts={this.props.inserts} onMouseDown={this.onBeforeClick} yPos={0} />
			<SideMenuList inserts={this.props.inserts} onMouseDown={this.onAfterClick} yPos={bottom - top} />
			{
				this.state.draggedNode
				?
				<div className="clone-container" ref="cloneContainer" dangerouslySetInnerHTML={{ __html:this.state.draggedNode.outerHTML }}></div>
				:
				null
			}
		</div>`


module.exports = SideMenu